abyss.cpp:    Level->level_width = map_getWidth(abyss);
abyss.cpp:    Level->level_length = map_getLength(abyss);
abyss.cpp:    for(j=0; j<Level->level_length; j++) {
abyss.cpp:        for(i=0; i<Level->level_width; i++) {
abyss.cpp:            Level->site[i][j].roomnumber = RS_ADEPT;
abyss.cpp:                Level->site[i][j].locchar = VOID_CHAR;
abyss.cpp:                Level->site[i][j].p_locf = L_VOID;
abyss.cpp:                Level->site[i][j].locchar = VOID_CHAR;
abyss.cpp:                Level->site[i][j].p_locf = L_VOID_STATION;
abyss.cpp:                Level->site[i][j].locchar = FLOOR;
abyss.cpp:                Level->site[i][j].p_locf = L_VOICE1;
abyss.cpp:                Level->site[i][j].locchar = FLOOR;
abyss.cpp:                Level->site[i][j].p_locf = L_VOICE2;
abyss.cpp:                Level->site[i][j].locchar = FLOOR;
abyss.cpp:                Level->site[i][j].p_locf = L_VOICE3;
abyss.cpp:                Level->site[i][j].locchar = WATER;
abyss.cpp:                Level->site[i][j].p_locf = L_WATER_STATION;
abyss.cpp:                Level->site[i][j].locchar = FIRE;
abyss.cpp:                Level->site[i][j].p_locf = L_FIRE_STATION;
abyss.cpp:                Level->site[i][j].locchar = HEDGE;
abyss.cpp:                Level->site[i][j].p_locf = L_EARTH_STATION;
abyss.cpp:                Level->site[i][j].locchar = WHIRLWIND;
abyss.cpp:                Level->site[i][j].p_locf = L_AIR_STATION;
abyss.cpp:                Level->site[i][j].locchar = WALL;
abyss.cpp:                Level->site[i][j].locchar = FLOOR;
aux1.cpp:    if ((Level->depth == 0 && Current_Environment != E_DLAIR) ||
aux1.cpp:    Level->tunnelled++;
aux1.cpp:    if ((Level->tunnelled) > (Level->level_length)/4)
aux1.cpp:    if ((Level->tunnelled) >(Level->level_length)/2)
aux1.cpp:    if ((Level->tunnelled) > (3*(Level->level_length))/4)
aux1.cpp:    if ((Level->tunnelled) > Level->level_length) {
aux1.cpp:        p_death("dungeon cave-in");
aux1.cpp:        if (Level->depth < 10) {
aux1.cpp:            Str1[6] = Level->depth + '0';
aux1.cpp:            Str1[6] = (Level->depth / 10) + '0';
aux1.cpp:            Str1[7] = (Level->depth % 10) + '0';
aux1.cpp:            if ((Level->site[Player.x][Player.y].locchar == ALTAR) &&
aux1.cpp:                    (Level->site[Player.x][Player.y].aux == Player.patron))
aux1.cpp:        switch(Level->site[x][y].p_locf) {
aux1.cpp:    else if (Level->site[x][y].creature != NULL) {
aux1.cpp:            Level->site[x][y].creature->fight_monster();
aux1.cpp:    else if ((Level->site[x][y].locchar == WALL) ||
aux1.cpp:             (Level->site[x][y].locchar == STATUE) ||
aux1.cpp:             (Level->site[x][y].locchar == PORTCULLIS) ||
aux1.cpp:             (Level->site[x][y].locchar == CLOSED_DOOR) ||
aux1.cpp:              ((Level->site[x][y].locchar == HEDGE) ||
aux1.cpp:               (Level->site[x][y].locchar == LAVA) ||
aux1.cpp:               (Level->site[x][y].locchar == ABYSS) ||
aux1.cpp:               (Level->site[x][y].locchar == VOID_CHAR) ||
aux1.cpp:               (Level->site[x][y].locchar == FIRE) ||
aux1.cpp:               (Level->site[x][y].locchar == WHIRLWIND) ||
aux1.cpp:               (Level->site[x][y].locchar == WATER) ||
aux1.cpp:               (Level->site[x][y].locchar == LIFT) ||
aux1.cpp:               (Level->site[x][y].locchar == TRAP)))) {
aux1.cpp:        if ((Level->site[x][y].locchar == HEDGE) ||
aux1.cpp:                (Level->site[x][y].locchar == LAVA) ||
aux1.cpp:                (Level->site[x][y].locchar == FIRE) ||
aux1.cpp:                (Level->site[x][y].locchar == WHIRLWIND) ||
aux1.cpp:                (Level->site[x][y].locchar == ABYSS) ||
aux1.cpp:                (Level->site[x][y].locchar == VOID_CHAR) ||
aux1.cpp:                (Level->site[x][y].locchar == WATER) ||
aux1.cpp:                (Level->site[x][y].locchar == RUBBLE) ||
aux1.cpp:                (Level->site[x][y].locchar == LIFT) ||
aux1.cpp:                (Level->site[x][y].locchar == TRAP)) {
aux1.cpp:                if (Level->site[x][y].locchar != WATER ||
aux1.cpp:                        Level->site[x][y].p_locf != L_WATER) {
aux1.cpp:            if ((Level->site[x][y].locchar==OPEN_DOOR) ||
aux1.cpp:                    (Level->site[x][y].locchar==CLOSED_DOOR)) {
aux1.cpp:        if ((Level->site[x][y].p_locf >= TRAP_BASE) &&
aux1.cpp:                (Level->site[x][y].locchar != TRAP) &&
aux1.cpp:                (Level->site[x][y].p_locf <= TRAP_BASE+NUMTRAPS)) {
aux1.cpp:            Level->site[x][y].locchar = TRAP;
aux1.cpp:    Player.speed = 5 - min(4,(statmod(Player.agi)/2));
aux1.cpp:            Player.speed += (min(0,(Player.rank[MONKS] -1)));
aux1.cpp:        if (Player.possessions[O_WEAPON_HAND]->used &&
aux1.cpp:                ((Player.possessions[O_WEAPON_HAND]->objchar==WEAPON)||
aux1.cpp:                 (Player.possessions[O_WEAPON_HAND]->objchar==MISSILEWEAPON))) {
aux1.cpp:                Player.possessions[O_WEAPON_HAND]->hit +
aux1.cpp:                Player.possessions[O_WEAPON_HAND]->plus;
aux1.cpp:                Player.possessions[O_WEAPON_HAND]->dmg +
aux1.cpp:                Player.possessions[O_WEAPON_HAND]->plus;
aux1.cpp:            Player.possessions[O_SHIELD]->aux +
aux1.cpp:            Player.possessions[O_SHIELD]->plus;
aux1.cpp:        Player.absorption += Player.possessions[O_ARMOR]->dmg;
aux1.cpp:            Player.possessions[O_ARMOR]->plus -
aux1.cpp:            Player.possessions[O_ARMOR]->aux;
aux1.cpp:    /* special case -- break star gem */
aux1.cpp:    if (o->id == OB_STARGEM) {
aux1.cpp:            Player.alignment -= 200;
aux1.cpp:            Objects[o->id].uniqueness = UNIQUE_UNMADE; /* FIXED! 12/30/98 */
aux1.cpp:        if (o->fragility < random_range(30)) {
aux1.cpp:            if (o->objchar == STICK && o->charge > 0) {
aux1.cpp:                strcat(Str1,(o->blessing >= 0 ? o->truename : o->cursestr));
aux1.cpp:                nprint1(" Ka-Blamm!!!");
aux1.cpp:                manastorm(Player.x, Player.y, o->charge*o->level*10);
aux1.cpp:            else if ((o->blessing > 0) && (o->level > random_range(10))) {
aux1.cpp:            else if ((o->blessing < -1) && (o->level > random_range(10))) {
aux1.cpp:            else if (o->plus > 0) {
aux1.cpp:                o->plus--;
aux1.cpp:                if (o->blessing > 0) print1("You hear a faint despairing cry!");
aux1.cpp:                else if (o->blessing < 0) print1("You hear an agonized scream!");
aux1.cpp:        if (dtype == NORMAL_DAMAGE) Player.hp -= max(1,(dmg-Player.absorption));
aux1.cpp:        else Player.hp -= dmg;
aux1.cpp:    Player.hp = -1;
aux1.cpp:            movecursor(x,y,-1,0);
aux1.cpp:            movecursor(x,y,0,-1);
aux1.cpp:            movecursor(x,y,-1,1);
aux1.cpp:            movecursor(x,y,-1,-1);
aux1.cpp:            movecursor(x,y,1,-1);
aux1.cpp:        if (Level->site[Player.x+Dirs[0][i]][Player.y+Dirs[1][i]].creature
aux1.cpp:            Level->site[Player.x+Dirs[0][i]][Player.y+Dirs[1][i]].creature->fight_monster();
aux1.cpp:        p_damage(-5*Player.food,UNSTOPPABLE,"starvation");
aux1.cpp:    static int oldroomno = -1;
aux1.cpp:    static int oldlevel = -1;
aux1.cpp:    int roomno = Level->site[Player.x][Player.y].roomnumber;
aux1.cpp:            showroom(Level->site[Player.x][Player.y].roomnumber);
aux1.cpp:            (oldlevel != Level->depth)) {
aux1.cpp:        oldlevel = Level->depth;
aux1.cpp:            Str3[6] = ((level/10)-2) + '0';
aux2.cpp:    return((stat-10)/2);
aux2.cpp:    else if (Lunarity == -1) dmult = dmult / 2;
aux2.cpp:    if (m->uniqueness == COMMON) strcat(Str3,"the ");
aux2.cpp:    strcat(Str3,m->name);
aux2.cpp:    m->m_damage(dmult * random_range(dmg),dtype);
aux2.cpp:    if ((Verbosity != TERSE) && (random_range(10)==3) && (m->hp > 0))
aux2.cpp:            if (m->uniqueness == COMMON) strcat(Str3,"the ");
aux2.cpp:            strcat(Str3,m->name);
aux2.cpp:        strcat(Str1,Player.possessions[O_WEAPON_HAND]->objstr);
aux2.cpp:/* deal with each possible stati -- values are per move */
aux2.cpp:            Player.status[HASTED]--;
aux2.cpp:        Player.status[POISONED]--;
aux2.cpp:            Player.immunity[i]--;
aux2.cpp:        Player.status[IMMOBILE]--;
aux2.cpp:        Player.status[SLEPT]--;
aux2.cpp:            Player.mana--;
aux2.cpp:            Player.status[REGENERATING]--;
aux2.cpp:            Player.status[SLOWED]--;
aux2.cpp:        Player.status[RETURNING]--;
aux2.cpp:            Player.status[AFRAID]--;
aux2.cpp:            ((Player.alignment < -10) && (Phase/2 == 0))) {
aux2.cpp:             ((Player.alignment < -10) && (Phase/2 == 6))) {
aux2.cpp:        Lunarity = -1;
aux2.cpp:            if ((Player.possessions[i]->id == OB_TORCH) && /*torch */
aux2.cpp:                    (Player.possessions[i]->aux > 0)) {
aux2.cpp:                Player.possessions[i]->aux--;
aux2.cpp:                if (Player.possessions[i]->aux==0) {
aux2.cpp:                    if (Player.possessions[i]->number > 1) {
aux2.cpp:                        Player.possessions[i]->number--;
aux2.cpp:                        Player.possessions[i]->aux = 6;
aux2.cpp:                        Player.possessions[i]->usef = I_NO_OP;
aux2.cpp:                        Player.possessions[i]->cursestr =
aux2.cpp:                            Player.possessions[i]->truename =
aux2.cpp:                                Player.possessions[i]->objstr = "burnt-out torch";
aux2.cpp:        Player.status[SHADOWFORM]--;
aux2.cpp:            Player.immunity[NORMAL_DAMAGE]--;
aux2.cpp:            Player.immunity[ACID]--;
aux2.cpp:            Player.immunity[THEFT]--;
aux2.cpp:            Player.immunity[INFECTION]--;
aux2.cpp:        Player.status[ILLUMINATION]--;
aux2.cpp:        Player.status[VULNERABLE]--;
aux2.cpp:        Player.status[DEFLECTION]--;
aux2.cpp:        Player.status[ACCURATE]--;
aux2.cpp:        Player.status[HERO]--;
aux2.cpp:        Player.status[LEVITATING]--;
aux2.cpp:        Player.status[DISEASED]--;
aux2.cpp:        Player.status[INVISIBLE]--;
aux2.cpp:        Player.status[BLINDED]--;
aux2.cpp:        Player.status[TRUESIGHT]--;
aux2.cpp:        Player.status[BERSERK]--;
aux2.cpp:        Player.status[ALERT]--;
aux2.cpp:        Player.status[BREATHING]--;
aux2.cpp:        Player.status[DISPLACED]--;
aux2.cpp:            return((plevel-9) * 10000L);
aux2.cpp:            return((plevel-9) * 10000L +
aux2.cpp:                   (plevel-19)*(plevel-19)*500);
aux2.cpp:    if (item->known == 0) {
aux2.cpp:        if (item->objchar == THING) return(1);
aux2.cpp:    else if (item->known == 1) {
aux2.cpp:        if (item->objchar == THING) return(item->basevalue);
aux2.cpp:        else return(item->basevalue / 2);
aux2.cpp:/* figures value based on item base-value, charge, plus, and blessing */
aux2.cpp:    long value = item->basevalue;
aux2.cpp:    if (item->objchar == THING) return(item->basevalue);
aux2.cpp:        if (item->objchar == STICK) value += value*item->charge/20;
aux2.cpp:        if (item->plus > -1) value += value*item->plus/4;
aux2.cpp:        else value /= -item->plus;
aux2.cpp:        if (item->blessing > 0) value *= 2;
aux2.cpp:            switch (attempts--) {
aux2.cpp:                if (Level->site[Player.x][Player.y].p_locf == L_WATER && Level->site[Player.x][Player.y].things)
aux2.cpp:                    free_objlist(Level->site[Player.x][Player.y].things);
aux2.cpp:                    Level->site[Player.x][Player.y].things = NULL;
aux2.cpp:                        if (Level->site[Player.x][Player.y].p_locf != L_WATER)
aux2.cpp:                            p_drop_at(Player.x,Player.y,Player.pack[i]->number,Player.pack[i]);
aux2.cpp:                if (Level->site[Player.x][Player.y].p_locf == L_WATER)
aux2.cpp:    int aux = (weapon==NULL ? -2 : weapon->aux); /* bare hands */
aux2.cpp:    case -2:
aux2.cpp:        if (m->hp > 0) {
aux2.cpp:                if (m->player_hit(2*statmod(Player.dex),Player.combatManeuvers[i+1]))
aux2.cpp:                else if (Player.possessions[O_WEAPON_HAND]->type == CUTTING)
aux2.cpp:                else if (Player.possessions[O_WEAPON_HAND]->type == STRIKING)
aux2.cpp:                if (m->player_hit(0,Player.combatManeuvers[i+1]))
aux2.cpp:                if (m->player_hit(Player.level+Player.dex,Player.combatManeuvers[i+1]))
aux2.cpp:anomalous stats and item-usage if used indiscriminately */
aux2.cpp:                if ((used[i] = Player.possessions[i]->used) > 0) {
aux2.cpp:                    Player.possessions[i]->used = false;
aux2.cpp:                Player.possessions[i]->used = true;
aux2.cpp:    Player.sx = -1;
aux2.cpp:    Player.sy = -1; /* reset sanctuary if there was one */
aux2.cpp:            print1("have become a bit jealous of your success --");
aux2.cpp:        ScreenOffset = Player.y - (ScreenLength/2);
aux2.cpp:        ScreenXOffset =Player.x - (ScreenWidth/2);
aux2.cpp:        else if (TempLevel->environment != E_VILLAGE) village.load_village(Villagenum, true);
aux2.cpp:        ScreenOffset = Player.y - (ScreenLength/2);
aux2.cpp:        /*     ScreenXOffset = Player.x - (ScreenWidth/2); PGM*/
aux2.cpp:        setPlayerXY( Level->level_width/2, Level->level_length/2 );
aux2.cpp:        while (Level->site[Player.x][Player.y].locchar == WATER) {
aux2.cpp:            if (Player.y < Level->level_length/2 + 5)
aux2.cpp:            else if (Player.x > Level->level_width/2 - 10) {
aux2.cpp:                Player.x--;
aux2.cpp:                Player.y = Level->level_length/2 - 5;
aux2.cpp:                Level->site[Player.x][Player.y].locchar =
aux2.cpp:                    Level->site[Player.x][Player.y].showchar = FLOOR;
aux2.cpp:                Level->site[Player.x][Player.y].p_locf = L_NO_OP;
aux2.cpp:        print2("(But here you are in Never-Never Land)");
aux2.cpp:        ScreenOffset = Player.y - (ScreenLength/2);
aux2.cpp:        ScreenXOffset = Player.x - (ScreenWidth/2);
aux2.cpp:        showroom(Level->site[Player.x][Player.y].roomnumber);
aux3.cpp:    Player.food--;
aux3.cpp:        for (ml=Level->mlist; ml!=NULL; ml=ml->next)
aux3.cpp:            if (ml->monster->hp > 0) ml->monster->hp = Monsters[ml->monster->id].hp;
aux3.cpp:        ol->thing = create_object(difficulty()); /* FIXED!  12/30/98 */
aux3.cpp:        assert(ol->thing); /* WDT I want to make sure... */
aux3.cpp:        ol->next = Level->site[Player.x][Player.y].things;
aux3.cpp:        Level->site[Player.x][Player.y].things = ol;
aux3.cpp:        mprint("You find a fast-food establishment.");
aux3.cpp:            mprint("Your cell-structure was disrupted!");
aux3.cpp:                    Player.possessions[i]->plus++;
aux3.cpp:                    if (Player.possessions[i]->objchar == STICK)
aux3.cpp:                        Player.possessions[i]->charge+=10;
aux3.cpp:                    Player.possessions[i]->blessing+=10;
aux3.cpp:            Player.con -= 5;
aux3.cpp:            Player.maxcon -= 5;
aux3.cpp:            dispel(-1);
aux3.cpp:            dispel(-1);
aux3.cpp:            Player.pow-=10;
aux3.cpp:            make_artifact(ob,-1);
aux3.cpp:        for(i=Player.x-5; i<Player.x+6; i++)
aux3.cpp:            for(j=Player.y-5; j<Player.y+6; j++)
aux3.cpp:    return (c - 'a' + 'A');
aux3.cpp:            Player.mana -= hostile_magic * hostile_magic;
aux3.cpp:             Player.possessions[O_BOOTS]->usef == I_BOOTS_7LEAGUE) {
aux3.cpp:        locprint("A well-maintained road.");
aux3.cpp:            locprint("A rough-hewn granite temple.");
aux3.cpp:            locprint("A classical marble-columned temple.");
aux3.cpp:    for (x=Player.x-1; x<Player.x+2; x++)
aux3.cpp:        for (y=Player.y-1; y<Player.y+2; y++)
aux3.cpp:        if (CitySiteList[sitenums[i] - CITYSITEBASE][0]) {
aux3.cpp:    last = NUMCITYSITES - 1;
aux3.cpp:                prefix[--pos] = '\0';
aux3.cpp:                byte = prefix[pos - 1];
aux3.cpp:                    if (CitySiteList[sitenums[f] - CITYSITEBASE][0])
aux3.cpp:                    f--;
aux3.cpp:                    if (CitySiteList[sitenums[l] - CITYSITEBASE][0])
aux3.cpp:                last = NUMCITYSITES - 1;
aux3.cpp:                byte += 'a' - 'A';
aux3.cpp:                    (!CitySiteList[sitenums[f] - CITYSITEBASE][0] ||
aux3.cpp:            while (l >= 0 && (!CitySiteList[sitenums[l] - CITYSITEBASE][0] ||
aux3.cpp:                l--;
aux3.cpp:            nprint2(prefix + pos - 1);
aux3.cpp:        return sitenums[first] - CITYSITEBASE;
aux3.cpp:    for (i=Player.x-2; ((i<Player.x+3)&&(! hostile)); i++)
aux3.cpp:        for (j=Player.y-2; ((j<Player.y+3)&&(! hostile)); j++)
aux3.cpp:                if (Level->site[i][j].creature != NULL)
aux3.cpp:                    hostile = m_statusp(Level->site[i][j].creature,HOSTILE);
aux3.cpp:    else if (alignment == -1) {
aux3.cpp:        (*stone)--;
aux3.cpp:        dispel(-1);
aux3.cpp:        summon(-1,-1);
aux3.cpp:        Player.agi -= 3;
aux3.cpp:        Player.dex -= 5;
aux3.cpp:        strategic_teleport(-1);
aux3.cpp:        print1("The stone glows blue-violet");
aux3.cpp:        print1("The stone glows polka-dot (?!?!?!?)");
aux3.cpp:        strategic_teleport(-1);
aux3.cpp:    for(ml=Level->mlist; ml!=NULL; ml=ml->next)
aux3.cpp:        if (((ml->monster->id == GUARD) ||
aux3.cpp:                ((ml->monster->id == HISCORE_NPC) && (ml->monster->aux2 == 15))) && /*justiciar*/
aux3.cpp:                (ml->monster->hp > 0)) {
aux3.cpp:            m_status_set(ml->monster,AWAKE);
aux3.cpp:            m_status_set(ml->monster,HOSTILE);
aux3.cpp:            Level->site[40][60].p_locf = L_NO_OP; /* pacify_guards restores this */
aux3.cpp:        Player.alignment -= 250;
aux3.cpp:                    Level->site[i][j].locchar = FLOOR;
aux3.cpp:                    Level->site[i][j].p_locf = L_NO_OP;
aux3.cpp:                    Level->site[i][j].locchar = RUBBLE;
aux3.cpp:                    Level->site[i][j].p_locf = L_RUBBLE;
aux3.cpp:                if (Level->site[i][j].creature != NULL) {
aux3.cpp:                    Level->site[i][j].creature->hp = -1;
aux3.cpp:                    Level->site[i][j].creature = NULL;
aux3.cpp:                Level->site[i][j].creature->name = "ghost of a Paladin";
aux3.cpp:                m_status_set(Level->site[i][j].creature,HOSTILE);
bank.cpp:/* new bank -- moved out of site1.c */
bank.cpp:    /* no-password accounts aren't allowed */
bank.cpp:    new_account->player = player;
bank.cpp:    new_account->balance = balance;
bank.cpp:    new_account->next_account = 0;
bank.cpp:    new_account->number = account_number_next;
bank.cpp:    new_account->password = (char*) checkmalloc(1 + strlen(password));
bank.cpp:    strcpy(new_account->password, password);
bank.cpp:    new_account->next_account = bank;
bank.cpp:    card->aux = account_number;
bank.cpp:    for(account = bank; account; account = account->next_account)
bank.cpp:        if (!strcmp(password, account->password)) break;
bank.cpp:    for(account = bank; account; account = account->next_account)
bank.cpp:        if (number == account->number) break;
bank.cpp:/* returns the length of the typed-in string */
bank.cpp:                cp--;
bank.cpp:                pwlen--;
bank.cpp:/* returns the typed-in integer */
bank.cpp:                amountlen--;
bank.cpp:        else if (0 == amountlen && ('-' ==  key || '+' == key))
bank.cpp:            if ('-' == key) sign = -1;
bank.cpp:            amount = 10 * amount + (key - '0');
bank.cpp:    for (ml = Level->mlist; ml; ml = ml->next)
bank.cpp:        mon = ml->monster;
bank.cpp:        if (GUARD == mon->id)
bank.cpp:            mon->sense *= 2;
bank.cpp:    for (ml = Level->mlist; ml; ml = ml->next)
bank.cpp:        mon = ml->monster;
bank.cpp:        if (GUARD == mon->id && m_statusp(mon, HOSTILE))
bank.cpp:                        --(Player.alignment);
bank.cpp:                        Player.cash -= amount;
bank.cpp:                account->balance = amount;
bank.cpp:                return bank_create_card(account->number, OB_DEBIT_CARD);
bank.cpp:        next = account->next_account;
bank.cpp:        free(account->password);
bank.cpp:    if (card->blessing > 0)
bank.cpp:        --(card->blessing);
bank.cpp:    else if (card->blessing < 0)
bank.cpp:    mvwaddstr(w, 11, 2, "       --- Hit Space Bar to Continue ---       ");
bank.cpp:        Player.alignment -= 5;
bank.cpp:        for (account = bank; account; account = account->next_account)
bank.cpp:            if (account->player)
bank.cpp:                total_balance += account->balance;
bank.cpp:        if (card->id < OB_DEBIT_CARD || card->id > OB_SMART_CARD)
bank.cpp:            account = bank_index_number(card->aux);
bank.cpp:    if (card->blessing > 0)
bank.cpp:    else if (card->blessing < 0)
bank.cpp:    if (0 == strcmp(pw_buf, account->password))
bank.cpp:        if (card->blessing > 0)
bank.cpp:        else if (card->blessing < 0)
bank.cpp:        if (!account->player) Player.alignment -= 5;
bank.cpp:    if (card->blessing > 0)
bank.cpp:    else if (card->blessing < 0)
bank.cpp:        if (card->blessing > 0)
bank.cpp:            if (amount > account->balance) amount = account->balance;
bank.cpp:            account->balance -= amount;
bank.cpp:        else if (card->blessing < 0)
bank.cpp:            account->balance -= 1000;
bank.cpp:            account->balance -= 250;
bank.cpp:        if (card->blessing > 0)
bank.cpp:        else if (card->blessing < 0)
bank.cpp:        if (card->blessing > 0)
bank.cpp:        else if (card->blessing < 0)
bank.cpp:            mvwprintw(w, 14, 2, "Minus my fee, that makes %d AU for you...", amount - fee);
bank.cpp:        account->balance += (amount - fee);
bank.cpp:        Player.cash -= amount;
bank.cpp:    if (card->blessing > 0)
bank.cpp:    else if (card->blessing < 0)
bank.cpp:        Player.cash -= amount;
bank.cpp:        if (card->blessing > 0)
bank.cpp:        else if (card->blessing < 0)
bank.cpp:        if (card->blessing >= 0)
bank.cpp:            account->balance += amount;
bank.cpp:    else if (amount > account->balance)
bank.cpp:        if (card->blessing > 0)
bank.cpp:        else if (card->blessing < 0)
bank.cpp:            account->balance -= 1000;
bank.cpp:            account->balance -= 100;
bank.cpp:        if (card->blessing > 0)
bank.cpp:        else if (card->blessing < 0)
bank.cpp:            extra = -random_range(amount);
bank.cpp:            mvwprintw(w, 14, 2, "Ok, but I'm keeping %d AU for myself!", -extra);
bank.cpp:        account->balance -= amount;
bank.cpp:        if (card->blessing > 0)
bank.cpp:            if (account->balance > 0)
bank.cpp:                mvwprintw(w,  6, 2, "Say pal, you've got: %d AU!", account->balance);
bank.cpp:                mvwprintw(w,  6, 2, "Oh my, you've got: %d AU.", account->balance);
bank.cpp:        else if (card->blessing < 0)
bank.cpp:            if (account->balance > 0)
bank.cpp:                mvwprintw(w,  6, 2, "Muahaha! I've got %d AU!", account->balance);
bank.cpp:            else if (account->balance < 0)
bank.cpp:                mvwprintw(w,  6, 2, "Muahaha! You're owe me %d AU!", -account->balance);
bank.cpp:            mvwprintw(w,  6, 2, "Current balance: %d AU", account->balance);
bank.cpp:            if (card->blessing > 0)
bank.cpp:            else if (card->blessing < 0)
bank.cpp:/* the bank -- can be broken into (but you knew that, didn't you?) */
bank.cpp:    wborder(Bankw, '|', '|', '-', '-', '+', '+', '+', '+');
bank.cpp:                    if (card->blessing > 0)
bank.cpp:                    else if (card->blessing < 0)
bank.cpp:    for (account = bank; account; account = account->next_account)
bank.cpp:        if (false == account->player)
bank.cpp:    for (account = bank; account; account = account->next_account)
bank.cpp:        if (false == account->player)
bank.cpp:    return account->number;
char.cpp:        lname = dastuff->pw_name;
char.cpp:        Player.name[0] += 'A'-'a'; /* capitalise 1st letter */
char.cpp:    Behavior = -1;
char.cpp:                Player.name[0] += 'A'-'a'; /* capitalise 1st letter */
char.cpp:        ret_value = initstats() ; /* RM 04-19-2000:loading patch */ /* DAG */
char.cpp:    /* DAG - put the code back in the same place, rather than duplicating */
char.cpp:    ScreenOffset = -1000;	/* to force a redraw */
char.cpp:    return ret_value > 0; /* RM 04-19-2000: loading patch */ /* DAG */
char.cpp:    print2("play yourself [p]?"); /* RM 04-19-2000 loading patch */
char.cpp:        /* RM 04-19-2000: loading patch - a blatant hack */
char.cpp:        clearmsg(); /* RM 04-19-2000 loading patch - fix the display */
char.cpp:        print1("Do you want to save this set-up to .omegarc in your home directory? [yn] ");
char.cpp:        if (Player.alignment < -10) {
char.cpp:        menuprint("\n\n1: hand-to-hand combat");
char.cpp:        npcbehavior+=10*(response - '0');
char.cpp:        npcbehavior+=100*competence_check(response-'0');
char.cpp:        npcbehavior+=1000*(response - '0');
char.cpp:        ability += ((int) (Player.dmg / 10) - 1);
char.cpp:    num = (num - 120) / 30 + 9;
char.cpp:        num = 9 * (num - 49) / 50 + 9;
char.cpp:        num = 9 * (num - 49) / 50 + 9;
char.cpp:    return -4;
char.cpp:    return -4;
char.cpp:    return -4;
char.cpp:    return -3;
char.cpp:    return -3;
char.cpp:    return -4;
char.cpp:    if ('y' == cinema_ynq_line(0, "Had any serious accident or illness this year? [yn] ")) return -4;
char.cpp:    if ('y' == cinema_ynq_line(0, "Have a chronic disease? [yn] ")) return -4;
char.cpp:    if ('y' == cinema_ynq_line(0, "Overweight or underweight by more than 20 percent? [yn] ")) return -2;
char.cpp:    if ('y' == cinema_ynq_line(0, "High blood pressure? [yn] ")) return -2;
char.cpp:    return -3;
char.cpp:    if (num < 1) return -3;
char.cpp:    if ('y' != cinema_ynq_line(0, "Ever have an out-of-body experience? [yn] ")) return 0;
char.cpp:#if REROLLS == -1
char.cpp:        sprintf(Str1, "You have only %d chance%s to reroll... ", REROLLS - i,
char.cpp:                (i == (REROLLS-1) ) ? "":"s");
char.cpp:#if REROLLS == -1
char.cpp:        Player.name[0] += 'A'-'a'; /* capitalise 1st letter */
char.cpp:            (Player.preference != 'y') && (Player.preference != 'n')); /* :-) */
city.cpp:    Level->depth = 0;
city.cpp:    Level->environment = E_CITY;
city.cpp:    WIDTH = Level->level_width = map_getWidth(city);
city.cpp:    LENGTH = Level->level_length = map_getLength(city);
city.cpp:    for(j=0; j<Level->level_length; j++) {
city.cpp:        for(i=0; i<Level->level_width; i++) {
city.cpp:                Level->site[i][j].locchar = FLOOR;
city.cpp:                Level->site[i][j].locchar = FLOOR;
city.cpp:                Level->site[i][j].p_locf = L_GARDEN;
city.cpp:                Level->site[i][j].locchar = FLOOR;
city.cpp:                Level->site[i][j].p_locf = L_CEMETARY;
city.cpp:                Level->site[i][j].locchar = FLOOR;
city.cpp:                Level->site[i][j].p_locf = L_TEMPLE;
city.cpp:                CitySiteList[L_TEMPLE-CITYSITEBASE][0] = true;
city.cpp:                CitySiteList[L_TEMPLE-CITYSITEBASE][1] = i;
city.cpp:                CitySiteList[L_TEMPLE-CITYSITEBASE][2] = j;
city.cpp:                    Level->site[i][j].locchar = FLOOR;
city.cpp:                    Level->site[i][j].p_locf = L_PORTCULLIS_TRAP;
city.cpp:                    Level->site[i][j].aux = NOCITYMOVE;
city.cpp:                    Level->site[i][j].locchar = FLOOR;
city.cpp:                    Level->site[i][j].p_locf = L_RAISE_PORTCULLIS;
city.cpp:                    Level->site[i][j].aux = NOCITYMOVE;
city.cpp:                    Level->site[i][j].locchar = FLOOR;
city.cpp:                    Level->site[i][j].p_locf = L_PORTCULLIS;
city.cpp:                    Level->site[i][j].aux = NOCITYMOVE;
city.cpp:                    Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:                    Level->site[i][j].p_locf = L_COLLEGE;
city.cpp:                    CitySiteList[L_COLLEGE-CITYSITEBASE][0] = true;
city.cpp:                    CitySiteList[L_COLLEGE-CITYSITEBASE][1] = i;
city.cpp:                    CitySiteList[L_COLLEGE-CITYSITEBASE][2] = j;
city.cpp:                    Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:                    Level->site[i][j].p_locf = L_SORCERORS;
city.cpp:                    CitySiteList[L_SORCERORS-CITYSITEBASE][0] = true;
city.cpp:                    CitySiteList[L_SORCERORS-CITYSITEBASE][1] = i;
city.cpp:                    CitySiteList[L_SORCERORS-CITYSITEBASE][2] = j;
city.cpp:                    Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:                    Level->site[i][j].p_locf = L_MERC_GUILD;
city.cpp:                    CitySiteList[L_MERC_GUILD-CITYSITEBASE][0] = true;
city.cpp:                    CitySiteList[L_MERC_GUILD-CITYSITEBASE][1] = i;
city.cpp:                    CitySiteList[L_MERC_GUILD-CITYSITEBASE][2] = j;
city.cpp:                    Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:                    Level->site[i][j].p_locf = L_MONASTERY;
city.cpp:                    CitySiteList[L_MONASTERY-CITYSITEBASE][0] = true;
city.cpp:                    CitySiteList[L_MONASTERY-CITYSITEBASE][1] = i;
city.cpp:                    CitySiteList[L_MONASTERY-CITYSITEBASE][2] = j;
city.cpp:                    Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:                    Level->site[i][j].p_locf = L_CASTLE;
city.cpp:                    CitySiteList[L_CASTLE-CITYSITEBASE][0] = true;
city.cpp:                    CitySiteList[L_CASTLE-CITYSITEBASE][1] = i;
city.cpp:                    CitySiteList[L_CASTLE-CITYSITEBASE][2] = j;
city.cpp:                static int myI = -1, myJ;
city.cpp:                if ( myI == -1 )
city.cpp:    site = map_getSiteChar(maze, i - myI, j - myJ);
city.cpp:        Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:        Level->site[i][j].p_locf = L_ORDER;
city.cpp:        CitySiteList[L_ORDER-CITYSITEBASE][0] = true;
city.cpp:        CitySiteList[L_ORDER-CITYSITEBASE][1] = i;
city.cpp:        CitySiteList[L_ORDER-CITYSITEBASE][2] = j;
city.cpp:        Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:        Level->site[i][j].p_locf = L_CHARITY;
city.cpp:        CitySiteList[L_CHARITY-CITYSITEBASE][0] = true;
city.cpp:        CitySiteList[L_CHARITY-CITYSITEBASE][1] = i;
city.cpp:        CitySiteList[L_CHARITY-CITYSITEBASE][2] = j;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].locchar = CLOSED_DOOR;
city.cpp:        Level->site[i][j].p_locf = L_JAIL;
city.cpp:        Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:        Level->site[i][j].p_locf = L_ARENA;
city.cpp:        CitySiteList[L_ARENA-CITYSITEBASE][0] = true;
city.cpp:        CitySiteList[L_ARENA-CITYSITEBASE][1] = i;
city.cpp:        CitySiteList[L_ARENA-CITYSITEBASE][2] = j;
city.cpp:        Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:        Level->site[i][j].p_locf = L_BANK;
city.cpp:        CitySiteList[L_BANK-CITYSITEBASE][0] = true;
city.cpp:        CitySiteList[L_BANK-CITYSITEBASE][1] = i;
city.cpp:        CitySiteList[L_BANK-CITYSITEBASE][2] = j;
city.cpp:        lset(i-1,j,STOPS);
city.cpp:        lset(i,j-1,STOPS);
city.cpp:        Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:        Level->site[i][j].p_locf = L_TOURIST;
city.cpp:        CitySiteList[L_TOURIST-CITYSITEBASE][1] = i;
city.cpp:        CitySiteList[L_TOURIST-CITYSITEBASE][2] = j;
city.cpp:        lset(i-1,j,STOPS);
city.cpp:        lset(i,j-1,STOPS);
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].p_locf = L_COUNTRYSIDE;
city.cpp:        CitySiteList[L_COUNTRYSIDE-CITYSITEBASE][0] = true;
city.cpp:        CitySiteList[L_COUNTRYSIDE-CITYSITEBASE][1] = i;
city.cpp:        CitySiteList[L_COUNTRYSIDE-CITYSITEBASE][2] = j;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].p_locf = L_VAULT;
city.cpp:        Level->site[i][j].aux = NOCITYMOVE;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].aux = NOCITYMOVE;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:            Level->site[i][j].creature->aux1 = i;
city.cpp:            Level->site[i][j].creature->aux2 = j;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].showchar = WALL;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].p_locf = L_VAULT;
city.cpp:        Level->site[i][j].aux = NOCITYMOVE;
city.cpp:        Level->site[i][j].showchar = WALL;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].p_locf = L_TRAP_SIREN;
city.cpp:        Level->site[i][j].aux = NOCITYMOVE;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].locchar = ALTAR;
city.cpp:        Level->site[i][j].p_locf = L_ALTAR;
city.cpp:        Level->site[i][j].aux = ODIN;
city.cpp:        Level->site[i][j].locchar = ALTAR;
city.cpp:        Level->site[i][j].p_locf = L_ALTAR;
city.cpp:        Level->site[i][j].aux = SET;
city.cpp:        Level->site[i][j].locchar = ALTAR;
city.cpp:        Level->site[i][j].p_locf = L_ALTAR;
city.cpp:        Level->site[i][j].aux = ATHENA;
city.cpp:        Level->site[i][j].locchar = ALTAR;
city.cpp:        Level->site[i][j].p_locf = L_ALTAR;
city.cpp:        Level->site[i][j].aux = HECATE;
city.cpp:        Level->site[i][j].locchar = ALTAR;
city.cpp:        Level->site[i][j].p_locf = L_ALTAR;
city.cpp:        Level->site[i][j].aux = DESTINY;
city.cpp:        Level->site[i][j].showchar = WALL;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].p_locf = TRAP_BASE+random_range(NUMTRAPS);
city.cpp:        Level->site[i][j].locchar = HEDGE;
city.cpp:        Level->site[i][j].locchar = WATER;
city.cpp:        Level->site[i][j].p_locf = L_WATER;
city.cpp:        Level->site[i][j].locchar = WATER;
city.cpp:        Level->site[i][j].p_locf = L_MAGIC_POOL;
city.cpp:        Level->site[i][j].locchar = WALL;
city.cpp:        Level->site[i][j].aux = 10;
city.cpp:        Level->site[i][j].locchar = WALL;
city.cpp:        Level->site[i][j].aux = 500;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].showchar = WALL;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].aux = NOCITYMOVE;
city.cpp:    case '-':
city.cpp:    case 'D': /* WDT: should all Ds be changed to -, or should D be given
city.cpp:        Level->site[i][j].locchar = CLOSED_DOOR;
city.cpp:        Level->site[i][j].locchar = STATUE;
city.cpp:            Level->site[i][j].showchar = WALL;
city.cpp:        else Level->site[i][j].showchar = Level->site[i][j].locchar;
city.cpp:for(ml=Level->mlist; ml!=NULL; ml=ml->next) {
city.cpp:    m_status_reset(ml->monster,AWAKE);
city.cpp:    ml->monster->wakeup = 2;
city.cpp:    Level->site[x][y].aux = true;
city.cpp:    lset(x-1,y,STOPS);
city.cpp:    lset(x,y-1,STOPS);
city.cpp:        Level->site[x][y].locchar = CLOSED_DOOR;
city.cpp:        Level->site[x][y].p_locf = L_HOUSE;
city.cpp:        if(random_range(5)) Level->site[x][y].aux = LOCKED;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_ARMORER;
city.cpp:            CitySiteList[L_ARMORER-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_ARMORER-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_CLUB;
city.cpp:            CitySiteList[L_CLUB-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_CLUB-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_GYM;
city.cpp:            CitySiteList[L_GYM-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_GYM-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = CLOSED_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_THIEVES_GUILD;
city.cpp:            CitySiteList[L_THIEVES_GUILD-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_THIEVES_GUILD-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_HEALER;
city.cpp:            CitySiteList[L_HEALER-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_HEALER-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_CASINO;
city.cpp:            CitySiteList[L_CASINO-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_CASINO-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_DINER;
city.cpp:            CitySiteList[L_DINER-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_DINER-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_CRAP;
city.cpp:            CitySiteList[L_CRAP-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_CRAP-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_COMMANDANT;
city.cpp:            CitySiteList[L_COMMANDANT-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_COMMANDANT-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_TAVERN;
city.cpp:            CitySiteList[L_TAVERN-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_TAVERN-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_ALCHEMIST;
city.cpp:            CitySiteList[L_ALCHEMIST-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_ALCHEMIST-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_DPW;
city.cpp:            CitySiteList[L_DPW-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_DPW-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_LIBRARY;
city.cpp:            CitySiteList[L_LIBRARY-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_LIBRARY-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_PAWN_SHOP;
city.cpp:            CitySiteList[L_PAWN_SHOP-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_PAWN_SHOP-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_CONDO;
city.cpp:            CitySiteList[L_CONDO-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_CONDO-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = CLOSED_DOOR;
city.cpp:            Level->site[x][y].p_locf = L_BROTHEL;
city.cpp:            CitySiteList[L_BROTHEL-CITYSITEBASE][1] = x;
city.cpp:            CitySiteList[L_BROTHEL-CITYSITEBASE][2] = y;
city.cpp:            Level->site[x][y].locchar = CLOSED_DOOR;
city.cpp:                Level->site[x][y].p_locf = L_HOVEL;
city.cpp:                Level->site[x][y].p_locf = L_HOUSE;
city.cpp:                Level->site[x][y].p_locf = L_MANSION;
city.cpp:            if(random_range(5)) Level->site[x][y].aux = LOCKED;
city.cpp:    ml->monster = ((Monster*) checkmalloc(sizeof(Monster)));
city.cpp:    *(ml->monster) = Monsters[NPC];
city.cpp:    make_hiscore_npc(ml->monster,15);
city.cpp:    ml->monster->x = i;
city.cpp:    ml->monster->y = j;
city.cpp:    Level->site[i][j].creature = ml->monster;
city.cpp:    ml->monster->click = (Tick + 1) % 60;
city.cpp:    ml->next = Level->mlist;
city.cpp:    Level->mlist = ml;
city.cpp:    m_status_reset(ml->monster,AWAKE);
city.cpp:    for(j=0; j<Level->level_length; j++) {
city.cpp:        for(i=0; i<Level->level_width; i++) {
city.cpp:                Level->site[i][j].creature->name = "undead guardsman";
city.cpp:                Level->site[i][j].creature->meleef = M_MELEE_SPIRIT;
city.cpp:                Level->site[i][j].creature->movef = M_MOVE_SPIRIT;
city.cpp:                Level->site[i][j].creature->strikef = M_STRIKE_MISSILE;
city.cpp:                Level->site[i][j].creature->immunity = EVERYTHING-pow2(NORMAL_DAMAGE);
city.cpp:                Level->site[i][j].creature->hp *= 2;
city.cpp:                Level->site[i][j].creature->hit *= 2;
city.cpp:                Level->site[i][j].creature->dmg *= 2;
city.cpp:                Level->site[i][j].creature->ac *= 2;
city.cpp:                m_status_set(Level->site[i][j].creature,HOSTILE);
city.cpp:                m_status_set(Level->site[i][j].creature,AWAKE);
city.cpp:        Level->site[i][j].locchar = HEDGE;
city.cpp:            Level->site[i][j].p_locf = L_HEDGE;
city.cpp:            Level->site[i][j].p_locf = L_TRIFID;
city.cpp:    case '-':
city.cpp:        Level->site[i][j].locchar = CLOSED_DOOR;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].locchar = STAIRS_DOWN;
city.cpp:        Level->site[i][j].p_locf = L_SEWER;
city.cpp:        CitySiteList[L_SEWER-CITYSITEBASE][1] = i;
city.cpp:        CitySiteList[L_SEWER-CITYSITEBASE][2] = j;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].p_locf = L_MAZE;
city.cpp:        Level->site[i][j].locchar = OPEN_DOOR;
city.cpp:        Level->site[i][j].p_locf = L_ORACLE;
city.cpp:        CitySiteList[L_ORACLE-CITYSITEBASE][1] = i;
city.cpp:        CitySiteList[L_ORACLE-CITYSITEBASE][2] = j;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        /*    Level->site[i][j].p_locf = TRAP_BASE+random_range(NUMTRAPS); */
city.cpp:        Level->site[i][j].p_locf = TRAP_BASE+random_range(NUM_SAFE_TRAPS);
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:            make_site_monster(i,j,-1);
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:        Level->site[i][j].locchar = FLOOR;
city.cpp:    m_status_reset(Level->site[i][j].creature,AWAKE);
city.cpp:    m_status_reset(Level->site[i][j].creature,HOSTILE);
city.cpp:    m_status_reset(Level->site[i][j].creature,AWAKE);
city.cpp:    m_status_reset(Level->site[i][j].creature,HOSTILE);
city.cpp:                City->site[i+35][j+52].locchar = WALL;
city.cpp:                City->site[i+35][j+52].p_locf = L_NO_OP;
city.cpp:                City->site[i+35][j+52].aux = NOCITYMOVE;
city.cpp:                City->site[i+35][j+52].locchar = WALL;
city.cpp:                City->site[i+35][j+52].p_locf = L_NO_OP;
city.cpp:                City->site[i+35][j+52].aux = 10;
city.cpp:                City->site[i+35][j+52].locchar = FLOOR;
city.cpp:                City->site[i+35][j+52].p_locf = L_PORTCULLIS_TRAP;
city.cpp:                City->site[i+35][j+52].aux = NOCITYMOVE;
city.cpp:                City->site[i+35][j+52].locchar = FLOOR;
city.cpp:                City->site[i+35][j+52].p_locf = L_PORTCULLIS;
city.cpp:                City->site[i+35][j+52].aux = NOCITYMOVE;
city.cpp:                City->site[i+35][j+52].locchar = FLOOR;
city.cpp:                City->site[i+35][j+52].p_locf = L_RAISE_PORTCULLIS;
city.cpp:                City->site[i+35][j+52].aux = NOCITYMOVE;
colors.cpp:      fprintf(stderr,"Omega currently requires ncurses or op-curses color support.\n");
colors.cpp:    if (25 > COLOR_PAIRS - 1) {
command1.cpp:            searchval--;
command1.cpp:            p_movefunction(Level->site[Player.x][Player.y].p_locf);
command1.cpp:            break; /* RAC - char editor */
command1.cpp:            moveplayer(-1,0);
command1.cpp:            moveplayer(0,-1);
command1.cpp:            moveplayer(-1,1);
command1.cpp:            moveplayer(-1,-1);
command1.cpp:            moveplayer(1,-1);
command1.cpp:            moveplayer(-1,0);
command1.cpp:            moveplayer(0,-1);
command1.cpp:            moveplayer(-1,1);
command1.cpp:            moveplayer(-1,-1);
command1.cpp:            moveplayer(1,-1);
command1.cpp:            break; /* RAC - char editor */
command1.cpp:            movepincountry(-1,0);
command1.cpp:            movepincountry(0,-1);
command1.cpp:            movepincountry(-1,1);
command1.cpp:            movepincountry(-1,-1);
command1.cpp:            movepincountry(1,-1);
command2.cpp:            print3(" Time keeps on tickin' tickin' -- into the future.... ");
command2.cpp:        print3("You're blind -- you can't read!!!");
command2.cpp:        index = getitem_prompt("Read -- ", SCROLL);
command2.cpp:            if (obj->objchar != SCROLL) {
command2.cpp:    index = getitem_prompt("Quaff -- ", POTION);
command2.cpp:        if (obj->objchar != POTION) {
command2.cpp:    print1("Activate -- item [i] or artifact [a] or quit [ESCAPE]?");
command2.cpp:            index = getitem_prompt("Activate -- ", THING);
command2.cpp:            index = getitem_prompt("Activate -- ", ARTIFACT);
command2.cpp:    index = getitem_prompt("Eat -- ", FOOD);
command2.cpp:        if ((obj->objchar != FOOD) && (obj->objchar != CORPSE))
command2.cpp:            if (obj->usef == I_FOOD) Player.food = max(0, Player.food+obj->aux);
command2.cpp:        print3("You are too terror-stricken to stop to search for anything.");
command2.cpp:    if (Level->site[Player.x][Player.y].things == NULL)
command2.cpp:    index = getitem_prompt("Drop -- ", CASH);
command2.cpp:        else if ((! Player.possessions[index]->used) ||
command2.cpp:                 (! Player.possessions[index]->isCursed())) {
command2.cpp:            if (Player.possessions[index]->number == 1) {
command2.cpp:                n = getnumber(Player.possessions[index]->number);
command2.cpp:/* talk to the animals -- learn their languages.... */
command2.cpp:    print1("Talk --");
command2.cpp:                (Level->site[Player.x+dx][Player.y+dy].creature == NULL)) {
command2.cpp:            m = Level->site[Player.x+dx][Player.y+dy].creature;
command2.cpp:            strcat(Str1,m->name);
command2.cpp:                m->monster_talk();
command2.cpp:                m->threaten();
command2.cpp:                m->surrender();
command2.cpp:    print1("Disarm -- ");
command2.cpp:        else if (Level->site[x][y].locchar != TRAP)
command2.cpp:                    switch(Level->site[x][y].p_locf) {
command2.cpp:                        Objects[o->id].known = 1;
command2.cpp:                        o->known = 1;
command2.cpp:                Level->site[x][y].p_locf = L_NO_OP;
command2.cpp:                Level->site[x][y].locchar = FLOOR;
command2.cpp:                p_movefunction(Level->site[x][y].p_locf);
command2.cpp:    print1("Give to monster --");
command2.cpp:        else if (Level->site[Player.x+dx][Player.y+dy].creature == NULL) {
command2.cpp:            m = Level->site[Player.x+dx][Player.y+dy].creature;
command2.cpp:            else if (! Player.possessions[index]->isCursed()) {
command2.cpp:                obj->used = false;
command2.cpp:                obj->number = 1;
command2.cpp:        print3("You are so terror-stricken you can't hold a wand straight!");
command2.cpp:        index = getitem_prompt("Zap -- ", STICK);
command2.cpp:            if (obj->objchar != STICK) {
command2.cpp:            else if (obj->charge < 1)
command2.cpp:                obj->charge--;
command2.cpp:            else if (Lunarity == -1) drain = drain *2;
command2.cpp:                if (Lunarity == -1 && Player.mana >= drain/2)
command2.cpp:                Player.mana -= drain;
command2.cpp:    if (Level->site[Player.x][Player.y].locchar != STAIRS_UP)
command2.cpp:    else if (Level->site[Player.x][Player.y].p_locf == L_ESCALATOR)
command2.cpp:        p_movefunction(Level->site[Player.x][Player.y].p_locf);
command2.cpp:        if (Level->depth <= 1) {
command2.cpp:            if (Level->environment == E_SEWERS)
command2.cpp:        else change_level(Level->depth,Level->depth-1,false);
command2.cpp:    if (Level->site[Player.x][Player.y].locchar != STAIRS_DOWN)
command2.cpp:    else if (Level->site[Player.x][Player.y].p_locf == L_ENTER_CIRCLE ||
command2.cpp:             Level->site[Player.x][Player.y].p_locf == L_ENTER_COURT)
command2.cpp:        p_movefunction(Level->site[Player.x][Player.y].p_locf);
command2.cpp:            change_level(Level->depth,Level->depth+1,false);
command2.cpp:            to = slot - 1;
command2.cpp:                optionset(pow2(slot-1));
command2.cpp:                optionreset(pow2(slot-1));
command2.cpp:                Searchnum = response - '0';
command2.cpp:    index = getitem_prompt("Call -- ", NULL_ITEM);
command2.cpp:        if (obj->known)
command2.cpp:            obj->objstr = salloc(msgscanstring());
command2.cpp:                Objects[obj->id].objstr = obj->objstr;
command2.cpp:    print1("Open --");
command2.cpp:        if (Level->site[ox][oy].locchar == OPEN_DOOR) {
command2.cpp:        else if (Level->site[ox][oy].locchar == PORTCULLIS) {
command2.cpp:                Level->site[ox][oy].locchar = FLOOR;
command2.cpp:        else if ((Level->site[ox][oy].locchar != CLOSED_DOOR) ||
command2.cpp:        else if (Level->site[ox][oy].aux == LOCKED)
command2.cpp:            Level->site[ox][oy].locchar = OPEN_DOOR;
command2.cpp:    print1("Bashing --");
command2.cpp:            if (Level->site[ox][oy].locchar == WALL) {
command2.cpp:            else if (Level->site[ox][oy].locchar == OPEN_DOOR) {
command2.cpp:                p_movefunction(Level->site[Player.x][Player.y].p_locf);
command2.cpp:            else if (Level->site[ox][oy].locchar == CLOSED_DOOR) {
command2.cpp:                if (Level->site[ox][oy].aux == LOCKED) {
command2.cpp:                        Level->site[ox][oy].locchar = FLOOR;
command2.cpp:                        p_movefunction(Level->site[Player.x][Player.y].p_locf);
command2.cpp:                    Level->site[ox][oy].locchar = OPEN_DOOR;
command2.cpp:                    p_movefunction(Level->site[Player.x][Player.y].p_locf);
command2.cpp:            else if (Level->site[ox][oy].locchar == STATUE) {
command2.cpp:            else if (Level->site[ox][oy].locchar == PORTCULLIS) {
command2.cpp:                    Level->site[ox][oy].locchar = FLOOR;
command2.cpp:                    Level->site[ox][oy].p_locf = L_NO_OP;
command2.cpp:            else if (Level->site[ox][oy].locchar == ALTAR) {
command2.cpp:                if ((Player.patron > 0)&&(Level->site[ox][oy].aux == Player.patron)) {
command2.cpp:                    p_damage(Player.hp-1,UNSTOPPABLE,"an annoyed angel");
command2.cpp:                else if (Level->site[ox][oy].aux == 0) {
command2.cpp:                    Level->site[ox][oy].locchar = RUBBLE;
command2.cpp:                    Level->site[ox][oy].p_locf = L_RUBBLE;
command2.cpp:                    p_damage(max(0,random_range(100)-Player.rank[PRIESTHOOD]*20),
command2.cpp:                        Level->site[ox][oy].locchar = RUBBLE;
command2.cpp:                        Level->site[ox][oy].p_locf = L_RUBBLE;
command2.cpp:    item = getitem_prompt("Destroy an item -- ", NULL_ITEM);
command2.cpp:        if (Player.str+random_range(20) > obj->fragility+random_range(20)) {
command2.cpp:            olevel = obj->level;
command2.cpp:            oid = obj->id;
command2.cpp:                    Player.alignment -= random_range(10);
command2.cpp:                    Player.alignment -= random_range(10);
command2.cpp:            if (obj->objchar == WEAPON) {
command2.cpp:                print2("The weapon turned in your hand -- you hit yourself!");
command2.cpp:                p_damage(random_range(obj->dmg+abs(obj->plus)),
command2.cpp:            else if (obj->objchar == ARTIFACT) {
command2.cpp:                print2("Uh Oh -- Now you've gotten it angry....");
command2.cpp:                p_damage(obj->level*10,
command2.cpp:/* if force is true, exiting due to some problem - don't bomb out */
command2.cpp:            sprintf(Str1, "Illegal character '%c' in filename - Save aborted.", fname[pos]);
command2.cpp:            sprintf(Str1, "Save name longer than %d characters - Save aborted.",
command2.cpp:                print1("Internal error -- unable to save.");
command2.cpp:        print1("The game is quitting - you will lose your character.");
command2.cpp:    print1("Close --");
command2.cpp:        if (Level->site[ox][oy].locchar == CLOSED_DOOR) {
command2.cpp:        else if (Level->site[ox][oy].locchar != OPEN_DOOR) {
command2.cpp:        else Level->site[ox][oy].locchar = CLOSED_DOOR;
command2.cpp:                summon(-1,HORSE);
command2.cpp:            p_movefunction(Level->site[Player.x][Player.y].p_locf);
command2.cpp:                    if ((Level->site[Player.x][Player.y].things != NULL) ||
command2.cpp:                if ((Level->site[Player.x][Player.y].things != NULL) &&
command2.cpp:            dx = random_range(3)-1;
command2.cpp:            dy = random_range(3)-1;
command2.cpp:                    if (Player.possessions[O_BOOTS]->usef == I_BOOTS_7LEAGUE) {
command2.cpp:                        if (Player.possessions[O_BOOTS]->blessing < 0) {
command2.cpp:                            print1("Whooah! -- Your boots launch you into the sky....");
command2.cpp:                        else if (Player.possessions[O_BOOTS]->known != 2) {
command2.cpp:                            Player.possessions[O_BOOTS]->known = 2;
command2.cpp:                if (Precipitation > 0) Precipitation--;
command3.cpp:        mprint("You're blind - you can't examine things.");
command3.cpp:    mprint("Examine --");
command3.cpp:            if (Level->site[x][y].creature != NULL)
command3.cpp:                mprint(Level->site[x][y].creature->mstatus_string());
command3.cpp:                print2("An age-worn stone wall.");
command3.cpp:                switch (Level->site[x][y].locchar) {
command3.cpp:                    if (Level->site[x][y].aux == 0)
command3.cpp:                    else if (Level->site[x][y].aux < 10)
command3.cpp:                    else if (Level->site[x][y].aux < 30)
command3.cpp:                        print2("An age-worn sandstone wall.");
command3.cpp:                    else if (Level->site[x][y].aux < 50)
command3.cpp:                    else if (Level->site[x][y].aux < 70)
command3.cpp:                    else if (Level->site[x][y].aux < 90)
command3.cpp:                    else if (Level->site[x][y].aux < 210) {
command3.cpp:                    print2("A dangerous-looking pile of rubble.");
command3.cpp:                    print2("A strange-looking statue.");
command3.cpp:                    print2(trapid(Level->site[x][y].p_locf));
command3.cpp:                    if (Level->site[x][y].p_locf == L_EARTH_STATION)
command3.cpp:                    if (Level->site[x][y].p_locf == L_WATER)
command3.cpp:                    else if (Level->site[x][y].p_locf == L_CHAOS)
command3.cpp:                    else if (Level->site[x][y].p_locf == L_WATER_STATION)
command3.cpp:            if ((ol = Level->site[x][y].things) != NULL && !loc_statusp(x,y,SECRET)) {
command3.cpp:                if (ol->next == NULL)
command3.cpp:                    print3(itemid(ol->thing));
command3.cpp:                        menuprint(itemid(ol->thing));
command3.cpp:                        ol = ol->next;
command3.cpp:        sprintf(filestr, "%shelp%d.txt", Omegalib, c+1-'a');
command3.cpp:    print1("Fire/Throw --");
command3.cpp:    else if (Player.possessions[index]->isCursed() &&
command3.cpp:             Player.possessions[index]->isUsed())
command3.cpp:             (Player.possessions[O_WEAPON_HAND]->id == OB_CROSSBOW) &&
command3.cpp:             (Player.possessions[O_WEAPON_HAND]->aux != LOADED) &&
command3.cpp:             (Player.possessions[index]->id == OB_BOLT)) {
command3.cpp:        Player.possessions[O_WEAPON_HAND]->aux = LOADED;
command3.cpp:        if (Player.possessions[index]->isUsed()) {
command3.cpp:            Player.possessions[index]->used = false;
command3.cpp:            do_object_los(obj->objchar,&x1,&y1,x2,y2);
command3.cpp:            if ((m=Level->site[x1][y1].creature) != NULL) {
command3.cpp:                if (obj->dmg == 0) {
command3.cpp:                    if (m->treasure > 0) { /* the monster can have treasure/objects */
command3.cpp:                else if (obj->aux == I_SCYTHE) {
command3.cpp:                else if (hitp(Player.hit,m->ac)) {/* ok already, hit the damn thing */
command3.cpp:                    if ((obj->id == OB_ARROW || obj->id == OB_BOLT) &&
command3.cpp:        if (naptime-- < 1) {
command3.cpp:            mprint("A monster or NPC -- examine (x) to find out exactly.");
command3.cpp:                mprint(" : A dangerous-looking pile of rubble");
command3.cpp:                Str1[0] += 'A'-'a'; /* capitalise 1st letter */
command3.cpp:            mprint("'Do not meddle in the affairs of Wizards --");
command3.cpp:        if (Player.possessions[O_BOOTS]->usef == I_BOOTS_JUMPING)
command3.cpp:        else if (Level->site[x][y].creature != NULL)
command3.cpp:                mprint("Oops -- took a tumble.");
command3.cpp:            p_movefunction(Level->site[Player.x][Player.y].p_locf);
command3.cpp:                if ((Level->site[Player.x][Player.y].things != NULL) &&
command3.cpp:                else if (Player.possessions[O_WEAPON_HAND]->type == THRUSTING) {
command3.cpp:                else if (Player.possessions[O_WEAPON_HAND]->type == STRIKING) {
command3.cpp:                actionsleft--;
command3.cpp:                else if (Player.possessions[O_WEAPON_HAND]->type == THRUSTING)
command3.cpp:                actionsleft--;
command3.cpp:                    if (Player.possessions[O_WEAPON_HAND]->type != MISSILE) {
command3.cpp:                        actionsleft -= 2;
command3.cpp:                    if (Player.possessions[O_WEAPON_HAND]->type == THRUSTING) {
command3.cpp:                        actionsleft -= 2;
command3.cpp:            else if (Player.possessions[O_WEAPON_HAND]->type == THRUSTING) {
command3.cpp:            else if (Player.possessions[O_WEAPON_HAND]->type == STRIKING) {
command3.cpp:            else if (Player.possessions[O_WEAPON_HAND]->type == THRUSTING)
command3.cpp:    mprint("Pickpocketing --");
command3.cpp:                (Level->site[Player.x+dx][Player.y+dy].creature == NULL)) {
command3.cpp:            m = Level->site[Player.x+dx][Player.y+dy].creature;
command3.cpp:            if (m->id == GUARD) {
command3.cpp:                        m->m_pickup(o);
command3.cpp:            else if (m->possessions == NULL) {
command3.cpp:                /* DAG -- code and idea contributed by Ross Presser <ross_presser@imtek.com> */
command3.cpp:                j = random_range(100)+m->level*20;
command3.cpp:                    mprint(itemid(m->possessions->thing));
command3.cpp:                    Player.alignment--;
command3.cpp:                    gain_experience(m->level*m->level);
command3.cpp:                    gain_item(m->possessions->thing);
command3.cpp:                    m->possessions = m->possessions->next;
command3.cpp:            Str1[0] += 'A' - 'a';
command3.cpp:        Player.immunity[NORMAL_DAMAGE]--;
command3.cpp:        Player.immunity[ACID]--;
command3.cpp:        Player.immunity[THEFT]--;
command3.cpp:        Player.immunity[INFECTION]--;
command3.cpp:    mprint("Tunnel -- ");
command3.cpp:        else if (Level->site[ox][oy].locchar != WALL) {
command3.cpp:            aux = Level->site[ox][oy].aux;
command3.cpp:                else if ((Player.possessions[O_WEAPON_HAND]->type == THRUSTING) ||
command3.cpp:                         ((Player.possessions[O_WEAPON_HAND]->type != STRIKING) &&
command3.cpp:                          (Player.possessions[O_WEAPON_HAND]->fragility <
command3.cpp:                    Level->site[ox][oy].locchar = RUBBLE;
command3.cpp:                    Level->site[ox][oy].p_locf = L_RUBBLE;
command3.cpp:            else if (Player.possessions[O_WEAPON_HAND]->type == THRUSTING) {
command3.cpp:                        (Player.possessions[O_WEAPON_HAND]->dmg*2+random_range(100) >
command3.cpp:                    Level->site[ox][oy].locchar = RUBBLE;
command3.cpp:                    Level->site[ox][oy].p_locf = L_RUBBLE;
command3.cpp:                     (Player.possessions[O_WEAPON_HAND]->dmg+random_range(100)
command3.cpp:                Level->site[ox][oy].locchar = RUBBLE;
command3.cpp:                Level->site[ox][oy].p_locf = L_RUBBLE;
command3.cpp:        ml->monster = ((Monster*) checkmalloc(sizeof(Monster)));
command3.cpp:        *(ml->monster) = Monsters[HORSE];
command3.cpp:        ml->monster->x = Player.x;
command3.cpp:        ml->monster->y = Player.y;
command3.cpp:        ml->monster->status = MOBILE+SWIMMING;
command3.cpp:        ml->next = Level->mlist;
command3.cpp:        Level->site[Player.x][Player.y].creature = ml->monster;
command3.cpp:        Level->mlist = ml;
command3.cpp:    else if (Level->site[Player.x][Player.y].aux == NOCITYMOVE)
command3.cpp:                x += sign(CitySiteList[site][1] - x);
command3.cpp:                y += sign(CitySiteList[site][2] - y);
command3.cpp:            p_movefunction(Level->site[x][y].p_locf);
command3.cpp:        if (num > -1) {
country.cpp:                Country[i][j].aux = 1+site-'a';
country.cpp:                Country[i][j].aux = site-'0';
country.cpp:    Level->environment = E_DLAIR;
country.cpp:    Level->level_width = map_getWidth(lair);
country.cpp:    Level->level_length = map_getLength(lair);
country.cpp:    for (j = 0; j < Level->level_length; ++j)
country.cpp:        for (i = 0; i < Level->level_width; ++i)
country.cpp:            Level->site[i][j].lstatus = 0;
country.cpp:                Level->site[i][j].roomnumber = RS_CAVERN;
country.cpp:                Level->site[i][j].roomnumber = RS_DRAGONLORD;
country.cpp:            Level->site[i][j].p_locf = L_NO_OP;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    Level->site[i][j].creature->specialf = M_SP_LAIR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    Level->site[i][j].creature->specialf = M_SP_LAIR;
country.cpp:                    Level->site[i][j].creature->hit *= 2;
country.cpp:                    Level->site[i][j].creature->dmg *= 2;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].showchar = WALL;
country.cpp:                Level->site[i][j].roomnumber = RS_SECRETPASSAGE;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_TRAP_SIREN;
country.cpp:                    Level->site[i][j].locchar = PORTCULLIS;
country.cpp:                    Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_PORTCULLIS;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_RAISE_PORTCULLIS;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_PORTCULLIS;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                if (!empty) Level->site[i][j].p_locf = L_PORTCULLIS_TRAP;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_TACTICAL_EXIT;
country.cpp:                Level->site[i][j].locchar = WALL;
country.cpp:                Level->site[i][j].aux = 150;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:    Level->environment = E_STARPEAK;
country.cpp:    Level->level_length = map_getLength(peak);
country.cpp:    Level->level_width = map_getWidth(peak);
country.cpp:    for(j=0; j<Level->level_length; j++) {
country.cpp:        for(i=0; i<Level->level_width; i++) {
country.cpp:            Level->site[i][j].lstatus = 0;
country.cpp:            Level->site[i][j].roomnumber = RS_STARPEAK;
country.cpp:            Level->site[i][j].p_locf = L_NO_OP;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].showchar = WALL;
country.cpp:                Level->site[i][j].roomnumber = RS_SECRETPASSAGE;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    if (safe) m_status_reset(Level->site[i][j].creature,HOSTILE);
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    if (safe) m_status_reset(Level->site[i][j].creature,HOSTILE);
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    make_site_monster(i,j,-1);
country.cpp:                    if (safe) m_status_reset(Level->site[i][j].creature,HOSTILE);
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    Level->site[i][j].locchar = PORTCULLIS;
country.cpp:                else Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_PORTCULLIS;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_RAISE_PORTCULLIS;
country.cpp:            case '-':
country.cpp:                Level->site[i][j].locchar = CLOSED_DOOR;
country.cpp:                Level->site[i][j].locchar = OPEN_DOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_PORTCULLIS;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    Level->site[i][j].p_locf = L_PORTCULLIS_TRAP;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_TACTICAL_EXIT;
country.cpp:                Level->site[i][j].locchar = WALL;
country.cpp:                Level->site[i][j].aux = 150;
country.cpp:                Level->site[i][j].locchar = RUBBLE;
country.cpp:                Level->site[i][j].p_locf = L_RUBBLE;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:    Level->environment = E_MAGIC_ISLE;
country.cpp:    Level->level_length = map_getLength(isle);
country.cpp:    Level->level_width = map_getWidth(isle);
country.cpp:    for(j=0; j<Level->level_length; j++) {
country.cpp:        for(i=0; i<Level->level_width; i++) {
country.cpp:            Level->site[i][j].lstatus = 0;
country.cpp:            Level->site[i][j].roomnumber = RS_MAGIC_ISLE;
country.cpp:            Level->site[i][j].p_locf = L_NO_OP;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_TACTICAL_EXIT;
country.cpp:                Level->site[i][j].locchar = WALL;
country.cpp:                Level->site[i][j].aux = 150;
country.cpp:                Level->site[i][j].locchar = RUBBLE;
country.cpp:                Level->site[i][j].p_locf = L_RUBBLE;
country.cpp:                Level->site[i][j].locchar = WATER;
country.cpp:                Level->site[i][j].p_locf = L_CHAOS;
country.cpp:                Level->site[i][j].locchar = WATER;
country.cpp:                Level->site[i][j].p_locf = L_MAGIC_POOL;
country.cpp:            case '-':
country.cpp:                Level->site[i][j].locchar = CLOSED_DOOR;
country.cpp:                Level->site[i][j].locchar = OPEN_DOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:    Level->environment = E_TEMPLE;
country.cpp:    Level->level_length = map_getLength(holy);
country.cpp:    Level->level_width = map_getWidth(holy);
country.cpp:    for(j=0; j<Level->level_length; j++) {
country.cpp:        for(i=0; i<Level->level_width; i++) {
country.cpp:                Level->site[i][j].roomnumber = RS_ODIN;
country.cpp:                Level->site[i][j].roomnumber = RS_SET;
country.cpp:                Level->site[i][j].roomnumber = RS_HECATE;
country.cpp:                Level->site[i][j].roomnumber = RS_ATHENA;
country.cpp:                Level->site[i][j].roomnumber = RS_DRUID;
country.cpp:                Level->site[i][j].roomnumber = RS_DESTINY;
country.cpp:                Level->site[i][j].locchar = ALTAR;
country.cpp:                Level->site[i][j].p_locf = L_ALTAR;
country.cpp:                Level->site[i][j].aux = deity;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    Level->site[i][j].p_locf = L_TEMPLE_WARNING;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].p_locf = L_TACTICAL_EXIT;
country.cpp:                    Level->site[i][j].locchar = WALL;
country.cpp:                    Level->site[i][j].aux = 150;
country.cpp:                    Level->site[i][j].locchar = HEDGE;
country.cpp:                    Level->site[i][j].p_locf = L_HEDGE;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                Level->site[i][j].locchar = FLOOR;
country.cpp:                    Level->site[i][j].locchar = FLOOR;
country.cpp:                    Level->site[i][j].locchar = ABYSS;
country.cpp:                    Level->site[i][j].p_locf = L_ADEPT;
country.cpp:            case '-':
country.cpp:                Level->site[i][j].locchar = CLOSED_DOOR;
country.cpp:                Level->site[i][j].locchar = OPEN_DOOR;
country.cpp:        for(ml=Level->mlist; ml!=NULL; ml=ml->next)
country.cpp:            m_status_reset(ml->monster,HOSTILE);
country.cpp:    /*  initrand(-2, 0); */ /* FIXED! 12/30/98 */
country.cpp:        Level->site[i][j].locchar = WATER;
country.cpp:        Level->site[i][j].p_locf = L_MAGIC_POOL;
country.cpp:    m->x = i;
country.cpp:    m->y = j;
country.cpp:    Level->site[i][j].creature = m;
country.cpp:    ml->monster = m;
country.cpp:    ml->next = Level->mlist;
country.cpp:    Level->mlist = ml;
defs.h:/*--------------------------USER DEFINITIONS--------------------------*/
defs.h:#define CENTER_ON_PLAYER // TODO Make this a user-specifiable option
defs.h:/*---------------------------SYSTEM DEFINITIONS---------------------------*/
defs.h:#define ABORT -1
defs.h:#define CASHVALUE -2
defs.h:#define PAWNITEMS 20 /* DG -- the more the merrier.  WDT -- I agree. */
defs.h:#define REROLLS -1
defs.h:/* non-existant environments for the random number seeding routine */
defs.h:#define E_RESTORE -2
defs.h:#define E_RANDOM -1
defs.h:/* PROTECTION is deviant -- indicates protective value, not duration */
defs.h:/* RETURNING is somewhat deviant--how many turns 'til RETURN spell goes off */
defs.h:#define EVERYTHING -1
defs.h:#ifdef OMEGA_CLRGEN // Only defined when using the color-gen utility
defs.h:#define CLOSED_DOOR ('-' | CLR(BROWN))
defs.h:#define PLAINS ('-' | CLR(LIGHT_GREEN))
defs.h:#define NUMTHINGS 31 /* DAG for mirror of self-knowledge */ /* WSS cards */
defs.h:#define NUMRINGS 9  /* DAG loss of ring of self-knowledge */
defs.h:#define CARDID (THINGID+NUMTHINGS-NUMCARDS)
defs.h:#define M_NO_OP -1
defs.h:/* MLx -> index to Monsters starting for level x */
defs.h:/* MLx -> number of monsters of level x or less */
defs.h:/* NML_x -> number of monsters of level x */
defs.h:/* NML-X must be changed whenever a monster is added */
defs.h:#define RANDOM -1
defs.h:/* unused site functions, these were defined, so I left them defined -- DAG */
defs.h:/* the first NUM_SAFE_TRAPS are non-insta-lethal */
defs.h:/* unused site functions, these were defined, so I left them defined -- DAG */
defs.h:#define sign(n) (((n) < 0) ? -1 : (((n) > 0) ? 1 : 0))
defs.h:#define abs(n) (((n) < 0) ? (-(n)) : (n))
defs.h:#define loc_statusp(x,y,stat) ((Level->site[x][y].lstatus&(stat))?1:0)
defs.h:#define lset(x,y,stat) (Level->site[x][y].lstatus |= (stat))
defs.h:#define lreset(x,y,stat) (Level->site[x][y].lstatus &= ~(stat))
defs.h:#define m_statusp(m,s) (((m)->status&(s))?1:0)
defs.h:#define m_status_set(m,s) ((m)->status |= (s))
defs.h:#define m_status_reset(m,s) ((m)->status &= ~(s))
defs.h:#define m_immunityp(m,s) (((m)->immunity&pow2(s))?1:0)
effect1.cpp:        if (i == ABORT || Player.possessions[i]->usef == I_NOTHING ||
effect1.cpp:                Player.possessions[i]->usef == I_NO_OP ||
effect1.cpp:                Player.possessions[i]->usef == I_NORMAL_ARMOR ||
effect1.cpp:                Player.possessions[i]->usef == I_NORMAL_WEAPON ||
effect1.cpp:                Player.possessions[i]->usef == I_NORMAL_SHIELD ||
effect1.cpp:                Player.possessions[i]->objchar == FOOD ||
effect1.cpp:                Player.possessions[i]->objchar == MISSILEWEAPON) {
effect1.cpp:        else if (Player.possessions[i]->blessing < 0 ||
effect1.cpp:                 (Player.possessions[i]->objchar == ARTIFACT && random_range(3))) {
effect1.cpp:            if (Player.possessions[i]->uniqueness == COMMON)
effect1.cpp:            used = (Player.possessions[i]->used);
effect1.cpp:                Player.possessions[i]->used = false;
effect1.cpp:            if (Player.possessions[i]->uniqueness == COMMON)
effect1.cpp:            Player.possessions[i]->plus = 0;
effect1.cpp:            Player.possessions[i]->charge = -1;
effect1.cpp:            Player.possessions[i]->usef = I_NOTHING;
effect1.cpp:                Player.possessions[i]->used = true;
effect1.cpp:            change_cash = Player.cash*(random_range(7) - 3)/6;
effect1.cpp:        else if (Player.possessions[i]->objchar == ARTIFACT) {
effect1.cpp:            if (Player.possessions[i]->usef !=
effect1.cpp:                    Objects[Player.possessions[i]->id].usef) {
effect1.cpp:                print1("It re-acquires its magical aura!");
effect1.cpp:                Player.possessions[i]->usef = Objects[Player.possessions[i]->id].usef;
effect1.cpp:                manastorm(Player.x,Player.y,Player.possessions[i]->level*5);
effect1.cpp:            if (Player.possessions[i]->plus > random_range(20)+1) {
effect1.cpp:                print1("Uh-oh, the force of the enchantment was too much!");
effect1.cpp:                manastorm(Player.x,Player.y,Player.possessions[i]->plus*5);
effect1.cpp:                used = (Player.possessions[i]->used);
effect1.cpp:                    Player.possessions[i]->used = false;
effect1.cpp:                Player.possessions[i]->plus += delta+1;
effect1.cpp:                if (Player.possessions[i]->charge > -1)
effect1.cpp:                    Player.possessions[i]->charge +=
effect1.cpp:                    Player.possessions[i]->used = true;
effect1.cpp:            if (Player.possessions[index]->uniqueness == COMMON)
effect1.cpp:            used = (Player.possessions[index]->used);
effect1.cpp:                Player.possessions[index]->used = false;
effect1.cpp:            Player.possessions[index]->blessing -= 2;
effect1.cpp:            if (Player.possessions[index]->blessing < 0)
effect1.cpp:                Player.possessions[index]->plus =
effect1.cpp:                    abs(Player.possessions[index]->plus) - 1;
effect1.cpp:                Player.possessions[index]->used = true;
effect1.cpp:            used = Player.possessions[index]->isUsed();
effect1.cpp:                Player.possessions[index]->used = false;
effect1.cpp:            if (Player.possessions[index]->blessing < 0-(blessing+1)) {
effect1.cpp:            else if (Player.possessions[index]->blessing < -1) {
effect1.cpp:                Player.itemweight -=  Player.possessions[index]->weight;
effect1.cpp:            else if (Player.possessions[index]->blessing < blessing+1) {
effect1.cpp:                Player.possessions[index]->blessing++;
effect1.cpp:                Player.possessions[index]->plus =
effect1.cpp:                    abs(Player.possessions[index]->plus)+1;
effect1.cpp:                Player.possessions[index]->used = true;
effect1.cpp:    if (amount > -1) {
effect1.cpp:        Player.hp -= random_range(10*abs(amount)+1);
effect1.cpp:    else if (NULL != (target = Level->site[xx][yy].creature)) {
effect1.cpp:        if (hitp(hit,target->ac)) {
effect1.cpp:            if (target->uniqueness == COMMON) {
effect1.cpp:                strcat(Str1,target->name);
effect1.cpp:            else strcpy(Str1,target->name);
effect1.cpp:            target->m_damage(random_range(dmg),dtype);
effect1.cpp:            if (target->uniqueness == COMMON) {
effect1.cpp:                strcat(Str1,target->name);
effect1.cpp:            else strcpy(Str1,target->name);
effect1.cpp:    else if (Level->site[xx][yy].locchar == HEDGE)
effect1.cpp:        if (Level->site[xx][yy].p_locf != L_TRIFID) {
effect1.cpp:                Level->site[xx][yy].p_locf = L_NO_OP;
effect1.cpp:                Level->site[xx][yy].locchar = FLOOR;
effect1.cpp:    else if (Level->site[xx][yy].locchar == WATER)
effect1.cpp:            Level->site[xx][yy].p_locf = L_NO_OP;
effect1.cpp:            Level->site[xx][yy].locchar = FLOOR;
effect1.cpp:        if (NULL != (target = Level->site[ex][ey].creature)) {
effect1.cpp:            if (los_p(Player.x,Player.y,target->x,target->y)) {
effect1.cpp:                if (target->uniqueness == COMMON) {
effect1.cpp:                    strcat(Str1,target->name);
effect1.cpp:                else strcpy(Str1,target->name);
effect1.cpp:            target->m_damage(random_range(dmg),dtype);
effect1.cpp:        if (Level->site[ex][ey].locchar == HEDGE)
effect1.cpp:            if (Level->site[ex][ey].p_locf != L_TRIFID) {
effect1.cpp:                    Level->site[ex][ey].p_locf = L_NO_OP;
effect1.cpp:                    Level->site[ex][ey].locchar = FLOOR;
effect1.cpp:        else if (Level->site[ex][ey].locchar == WATER)
effect1.cpp:                Level->site[ex][ey].p_locf = L_NO_OP;
effect1.cpp:                Level->site[ex][ey].locchar = FLOOR;
effect1.cpp:    for (ml=Level->mlist; ml!=NULL; ml=ml->next)
effect1.cpp:        if (ml->monster->hp > 0) /* FIXED 12/30/98 DG */
effect1.cpp:            if (blessing > -1)
effect1.cpp:                plotmon(ml->monster);
effect1.cpp:                putspot(random_range(Level->level_width), random_range(Level->level_length),
effect1.cpp:    for (i=0; i<Level->level_width; i++)
effect1.cpp:        for (j=0; j<Level->level_length; j++)
effect1.cpp:            if (Level->site[i][j].things != NULL) {
effect1.cpp:                    putspot(random_range(Level->level_width),
effect1.cpp:                            random_range(Level->level_length),
effect1.cpp:                            Level->site[i][j].things->thing->objchar);
effect1.cpp:                else putspot(i,j,Level->site[i][j].things->thing->objchar);
effect1.cpp:            if (Player.possessions[index]->objchar == FOOD)
effect1.cpp:                Player.possessions[index]->known = 1;
effect1.cpp:                Player.possessions[index]->known = 2;
effect1.cpp:                Objects[Player.possessions[index]->id].known = 1;
effect1.cpp:                Player.possessions[index]->known = 0;
effect1.cpp:                Objects[Player.possessions[index]->id].known = 0;
effect1.cpp:                if (Player.possessions[index]->objchar == FOOD)
effect1.cpp:                    Player.possessions[index]->known = 1;
effect1.cpp:                    Player.possessions[index]->known = 2;
effect1.cpp:                    Objects[Player.possessions[index]->id].known = 1;
effect1.cpp:                if (Player.pack[index]->objchar == FOOD)
effect1.cpp:                    Player.pack[index]->known = 1;
effect1.cpp:                    Player.pack[index]->known = 2;
effect1.cpp:                    Objects[Player.pack[index]->id].known = 1;
effect1.cpp:        if (Player.possessions[idx]->id < OB_DEBIT_CARD) continue;
effect1.cpp:        if (Player.possessions[idx]->id > OB_SMART_CARD) continue;
effect1.cpp:        Player.alignment -= 25;
effect1.cpp:        summon(gamestatusp(CHEATED),-1);
effect1.cpp:        newthing->id = -1;
effect1.cpp:                id = -1;
effect1.cpp:                newthing->known = 2;
effect1.cpp:            newthing->used = false;
effect2.cpp:            menuprint("Neutral-");
effect2.cpp:        case -1:
effect2.cpp:            menuprint("Ex-gladiator\n");
effect2.cpp:            menunumprint(Player.rank[NOBILITY] - 1);
effect2.cpp:            menuprint(ordinal(Player.rank[NOBILITY] - 1));
effect2.cpp:        case -1:
effect2.cpp:        case -1:
effect2.cpp:        dispel(-1);
effect2.cpp:        Level->generated = false;
effect2.cpp:        change_level(Level->depth-1,Level->depth,true);
effect2.cpp:    if (blessing > -1) {
effect2.cpp:        Player.status[VULNERABLE] += random_range(6) - blessing;
effect2.cpp:    if (blessing > -1) {
effect2.cpp:            newlevel=random_range(MaxDungeonLevels - 1) + 1;
effect2.cpp:        change_level(Level->depth,newlevel,false);
effect2.cpp:    if (blessing > -1) {
effect2.cpp:        mprint("You feel on-the-ball.");
effect2.cpp:    if (blessing > -1) {
effect2.cpp:        /* DAG -- this seems too long */
effect2.cpp:        /* WDT -- I agree.  Next version we'll fiddle it a bit.  I suspect
effect2.cpp:            Player.str = min(Player.str-1,Player.maxstr-1);
effect2.cpp:            Player.con = min(Player.con-1,Player.maxcon-1);
effect2.cpp:            Player.dex = min(Player.dex-1,Player.maxdex-1);
effect2.cpp:            Player.agi = min(Player.agi-1,Player.maxagi-1);
effect2.cpp:            Player.iq = min(Player.iq-1,Player.maxiq-1);
effect2.cpp:            Player.pow = min(Player.pow-1,Player.maxpow-1);
effect2.cpp:            Player.str = min(Player.str-1,Player.maxstr-1);
effect2.cpp:            Player.con = min(Player.con-1,Player.maxcon-1);
effect2.cpp:            Player.dex = min(Player.dex-1,Player.maxdex-1);
effect2.cpp:            Player.agi = min(Player.agi-1,Player.maxagi-1);
effect2.cpp:            Player.iq = min(Player.iq-1,Player.maxiq-1);
effect2.cpp:            Player.pow = min(Player.pow-1,Player.maxpow-1);
effect2.cpp:    if (blessing > -1) {
effect2.cpp:        Player.alignment -= random_range(20);
effect2.cpp:    Player.alignment -= random_range(20);
effect2.cpp:    if (blessing > -1) {
effect2.cpp:        if (Level->environment == E_TEMPLE)
effect2.cpp:        else if (Level->site[Player.x][Player.y].locchar == ALTAR)
effect2.cpp:            Level->site[Player.x][Player.y].locchar = LAVA;
effect2.cpp:            Level->site[Player.x][Player.y].p_locf = L_LAVA;
effect2.cpp:            Level->site[Player.x][Player.y].locchar = ALTAR;
effect2.cpp:            Level->site[Player.x][Player.y].aux = Player.patron;
effect2.cpp:            Level->site[Player.x][Player.y].p_locf = L_ALTAR;
effect2.cpp:        if (Level->site[Player.x][Player.y].locchar == ALTAR) {
effect2.cpp:            Level->site[Player.x][Player.y].locchar = FLOOR;
effect2.cpp:            Level->site[Player.x][Player.y].p_locf = L_NO_OP;
effect2.cpp:            if (Level->site[Player.x][Player.y].aux == Player.patron) {
effect2.cpp:                p_damage(Player.hp-1,UNSTOPPABLE,"Divine Wrath");
effect2.cpp:                if ((Level->site[Player.x][Player.y].aux == SET) ||
effect2.cpp:                        (Level->site[Player.x][Player.y].aux == HECATE)) {
effect2.cpp:                if ((Level->site[Player.x][Player.y].aux == ODIN) ||
effect2.cpp:                        (Level->site[Player.x][Player.y].aux == ATHENA)) {
effect2.cpp:    if (blessing > -1) {
effect3.cpp:        /* for (id ==0) case, see below -- get a "fair" monster */
effect3.cpp:        if (Level->site[x][y].locchar != FLOOR) continue;
effect3.cpp:        if (Level->site[x][y].creature) continue;
effect3.cpp:            Level->site[x][y].creature = m_create(x,y,WANDERING,difficulty());
effect3.cpp:            Level->site[x][y].creature = make_creature(id);
effect3.cpp:        Level->site[x][y].creature->x = x;
effect3.cpp:        Level->site[x][y].creature->y = y;
effect3.cpp:        tml->monster = Level->site[x][y].creature;
effect3.cpp:            m_status_reset(tml->monster,HOSTILE);
effect3.cpp:            m_status_set(tml->monster,HOSTILE);
effect3.cpp:        tml->next = Level->mlist;
effect3.cpp:        Level->mlist = tml;
effect3.cpp:    itemno = (int) parsenum("Item ID? ")-1;
effect3.cpp:            itemno = (int) parsenum("Summon monster: ")-1;
effect3.cpp:            if ((itemno < 0) || (itemno > NUMMONSTERS-1)) {
effect3.cpp:        } while ((itemno < 0) || (itemno > NUMMONSTERS-1));
effect3.cpp:            itemno = (int) parsenum("Summon monster: ")-1;
effect3.cpp:        } while ((itemno < 0) || (itemno > NUMMONSTERS-1));
effect3.cpp:    if (blessing > -1) {
effect3.cpp:                    if ((Player.possessions[i]->used) &&
effect3.cpp:                            (Player.possessions[i]->blessing < 0)) {
effect3.cpp:                        Player.possessions[i]->used = false;
effect3.cpp:                        Player.possessions[i]->blessing = 0;
effect3.cpp:                        Player.possessions[i]->used = true;
effect3.cpp:            if (Level->site[Player.x+Dirs[0][i]][Player.y+Dirs[1][i]].creature !=
effect3.cpp:                Level->site[Player.x+Dirs[0][i]][Player.y+Dirs[1][i]].creature->m_death();
effect3.cpp:            Player.alignment -= 3;
effect3.cpp:            for(ml=Level->mlist; ml!=NULL; ml=ml->next)
effect3.cpp:                if (ml->monster != NULL && ml->monster->hp > 0)
effect3.cpp:                    ml->monster->m_death();
effect3.cpp:        p_death("self-annihilation");
effect3.cpp:      for (ml=Level->mlist;ml!=NULL;ml=ml->next) {
effect3.cpp:        m_status_reset(ml->monster,AWAKE);
effect3.cpp:        ml->monster->wakeup = 0;
effect3.cpp:        target = Level->site[x][y].creature;
effect3.cpp:            if (target->uniqueness == COMMON) {
effect3.cpp:                strcat(Str1,target->name);
effect3.cpp:            else strcpy(Str1,target->name);
effect3.cpp:                target->wakeup = 0;
effect3.cpp:    for(i=x-vision; i<x+vision+1; i++)
effect3.cpp:        for(j=y-vision; j<y+vision+1; j++) {
effect3.cpp:                Level->site[i][j].showchar = SPACE;
effect3.cpp:    for (tm=Level->mlist; tm!=NULL; tm=tm->next) {
effect3.cpp:        m_status_set(tm->monster,AWAKE);
effect3.cpp:        m_status_set(tm->monster,HOSTILE);
effect3.cpp:        for(i=NUMSPELLS; ((i>-1) && (! done)); i--)
effect3.cpp:            nprint1(" -- Research successful: ");
effect3.cpp:        else nprint1(" -- Research unsuccessful.");
effect3.cpp:    for (j=0; j<Level->level_length; j++)
effect3.cpp:        for (i=0; i<Level->level_width; i++)
effect3.cpp:    /* current level and for the target level -DAG */
effect3.cpp:    exp_loss = expval(Player.level) - expval( Player.level-levels );
effect3.cpp:    Player.level -= levels;
effect3.cpp:    Player.xp -= exp_loss;
effect3.cpp:    Player.maxhp -= (levels * decrement);
effect3.cpp:    /* should pro-rate hp loss? - DAG */
effect3.cpp:    Player.hp -= (levels * decrement);
effect3.cpp:        target = Level->site[x][y].creature;
effect3.cpp:            if (target->uniqueness == COMMON) {
effect3.cpp:                strcat(Str1,target->name);
effect3.cpp:            else strcpy(Str1,target->name);
effect3.cpp:                target->m_damage(amount,NORMAL_DAMAGE);
effect3.cpp:                target->wakeup = 0;
effect3.cpp:        if ((target = Level->site[x][y].creature) != NULL) {
effect3.cpp:            if (target->uniqueness == COMMON) {
effect3.cpp:                strcat(Str1,target->name);
effect3.cpp:            else strcpy(Str1,target->name);
effect3.cpp:            target->m_damage(100,UNSTOPPABLE);
effect3.cpp:            if (target->hp > 0) mprint("It was partially protected by its armor.");
effect3.cpp:        else if (Level->site[x][y].locchar == ALTAR) {
effect3.cpp:        else if (Level->site[x][y].p_locf == L_TRAP_PIT) {
effect3.cpp:                Level->site[x][y].locchar = TRAP;
effect3.cpp:                Level->site[x][y].p_locf = L_TRAP_DOOR;
effect3.cpp:                Level->site[x][y].aux = S_DISINTEGRATE;
effect3.cpp:        else if (Level->site[x][y].locchar == FLOOR) {
effect3.cpp:            Level->site[x][y].locchar = TRAP;
effect3.cpp:            Level->site[x][y].p_locf = L_TRAP_PIT;
effect3.cpp:        else if ((Level->site[x][y].locchar == WALL) ||
effect3.cpp:                 (Level->site[x][y].locchar == OPEN_DOOR) ||
effect3.cpp:                 (Level->site[x][y].locchar == CLOSED_DOOR) ||
effect3.cpp:                 (Level->site[x][y].locchar == PORTCULLIS) ||
effect3.cpp:                 (Level->site[x][y].locchar == STATUE)) {
effect3.cpp:            if (Level->site[x][y].locchar == WALL)
effect3.cpp:            Level->site[x][y].p_locf = L_RUBBLE;
effect3.cpp:            Level->site[x][y].locchar = RUBBLE;
effect3.cpp:        else if ((Level->site[x][y].locchar == RUBBLE) ||
effect3.cpp:                 (Level->site[x][y].locchar == TRAP)) {
effect3.cpp:            Level->site[x][y].p_locf = L_NO_OP;
effect3.cpp:            Level->site[x][y].locchar = FLOOR;
effect3.cpp:        else if (Level->site[x][y].locchar == HEDGE) {
effect3.cpp:            if (Level->site[x][y].p_locf == L_TRIFID) {
effect3.cpp:                Level->site[x][y].p_locf = L_NO_OP;
effect3.cpp:                Level->site[x][y].locchar = FLOOR;
effect3.cpp:                Level->site[x][y].p_locf = L_NO_OP;
effect3.cpp:                Level->site[x][y].locchar = FLOOR;
effect3.cpp:        x = random_range(Level->level_width);
effect3.cpp:        y = random_range(Level->level_length);
effect3.cpp:        if ((Level->site[x][y].locchar != FLOOR) &&
effect3.cpp:                (Level->site[x][y].locchar != OPEN_DOOR)) {
effect3.cpp:        findspace(&(Player.x),&(Player.y),-1);
effect3.cpp:        if ((Level->site[Player.x][Player.y].locchar != FLOOR) ||
effect3.cpp:                (Level->site[Player.x][Player.y].creature != NULL)) {
effect3.cpp:    if (blessing > -1) {
effect3.cpp:        if (Level->site[x][y].things != NULL) {
effect3.cpp:                dispose_lost_objects(Player.possessions[index]->number,
effect3.cpp:            setPlayerXY( random_range(Level->level_width), random_range(Level->level_length) );
effect3.cpp:    if (blessing > -1) {
effect3.cpp:    if (blessing > -1) {
effect3.cpp:        if (Level->depth > 1)
effect3.cpp:            change_level(Level->depth,1,false);
effect3.cpp:        else change_level(Level->depth,deepest[Current_Environment],false);
effect3.cpp:    if (blessing > -1) {
effect3.cpp:            Player.status[POISONED] -= 5+blessing*10;
effect3.cpp:    if (blessing > -1) {
effect3.cpp:    if (blessing > -1) {
effect3.cpp:                    if ((o->used) && (o->blessing < 0)) {
effect3.cpp:                        if (blessing+1 + o->blessing >=0) {
effect3.cpp:                            o->used = false;
effect3.cpp:                            o->blessing = 0;
effect3.cpp:                            o->used = true;
effect3.cpp:        else if (Level->site[x][y].creature != NULL) {
effect3.cpp:            if (Level->site[x][y].creature->level < blessing * 3) {
effect3.cpp:                Level->site[x][y].creature->specialf = M_NO_OP;
effect3.cpp:                if (Level->site[x][y].creature->meleef != M_NO_OP)
effect3.cpp:                    Level->site[x][y].creature->meleef = M_MELEE_NORMAL;
effect3.cpp:                Level->site[x][y].creature->strikef = M_NO_OP;
effect3.cpp:                Level->site[x][y].creature->immunity=0;
effect3.cpp:                m_status_reset(Level->site[x][y].creature,M_INVISIBLE);
effect3.cpp:                m_status_reset(Level->site[x][y].creature,INTANGIBLE);
effect3.cpp:        else if ((Level->site[x][y].p_locf == L_TRAP_FIRE) ||
effect3.cpp:                 (Level->site[x][y].p_locf == L_STATUE_WAKE) ||
effect3.cpp:                 (Level->site[x][y].p_locf == L_TRAP_TELEPORT) ||
effect3.cpp:                 (Level->site[x][y].p_locf == L_TRAP_DISINTEGRATE)) {
effect3.cpp:            Level->site[x][y].p_locf = L_NO_OP;
effect3.cpp:            if (Level->site[x][y].locchar == TRAP)
effect3.cpp:                Level->site[x][y].locchar = FLOOR;
effect3.cpp:        else if (Level->site[x][y].p_locf == L_MAGIC_POOL)
effect3.cpp:            Level->site[x][y].p_locf = L_WATER;
effect3.cpp:    else if ((m=Level->site[x][y].creature) == NULL)
effect3.cpp:        if (m_immunityp(m,OTHER_MAGIC) || (m->level > random_range(12))) {
effect3.cpp:            strcat(Str1,m->name);
effect3.cpp:                        (Monsters[newmonster].level <= m->level) ||
effect3.cpp:            ohp = m->hp;
effect3.cpp:            olvl = m->level;
effect3.cpp:            oimmunity = m->immunity;
effect3.cpp:            oxpv = m->xpv;
effect3.cpp:            m->hp = max(m->hp, ohp);
effect3.cpp:            m->level = max(m->level, olvl);
effect3.cpp:            m->immunity |= oimmunity;
effect3.cpp:            m->xpv = max(m->xpv, oxpv);
effect3.cpp:    else if ((m=Level->site[x][y].creature) == NULL) {
effect3.cpp:            m->hp += 1000;
effect3.cpp:            m->hit +=20;
effect3.cpp:            m->dmg += 100;
effect3.cpp:            if (m->uniqueness == COMMON) {
effect3.cpp:                m->corpseString = "a greasy spot";
effect3.cpp:                m->id = 0;
effect3.cpp:                free_objlist(m->possessions);
effect3.cpp:                m->possessions = NULL;
effect3.cpp:            m->m_death();
effect3.cpp:        level_drain(Player.level,"self-vampirism");
effect3.cpp:    else if ((m=Level->site[x][y].creature) != NULL) {
effect3.cpp:        if ((blessing > -1) && (! m_immunityp(m,NEGENERGY))) {
effect3.cpp:            m->m_damage(m->level*m->level,NEGENERGY);
effect3.cpp:            m->hit = max(m->hit - m->level, 1);
effect3.cpp:            m->dmg = max(m->dmg - m->level*m->level, 1);
effect3.cpp:            m->ac = max(m->ac - m->level, 1);
effect3.cpp:            m->level = max(1,m->level-1);
effect3.cpp:            gain_experience(m->level*5);
effect3.cpp:            Player.hp+=(m->level*m->level / 2);
effect3.cpp:            m->hp+=Player.level*Player.level;
effect3.cpp:            m->hit += Player.level;
effect3.cpp:            m->dmg += Player.level*Player.level;
effect3.cpp:            m->ac += Player.level;
effect3.cpp:            m->level++;
effect3.cpp:            level_drain(m->level,"negative energy conflict");
effect3.cpp:    else if (Level->site[x][y].locchar == ALTAR) {
effect3.cpp:        Level->site[x][y].locchar = ABYSS;
effect3.cpp:        Level->site[x][y].p_locf = L_ABYSS;
effect3.cpp:        if (Level->site[x][y].aux == Player.patron) {
effect3.cpp:            p_damage(Player.hp-1,UNSTOPPABLE,"godsfire");
effect3.cpp:            Player.patron = -1;
effect3.cpp:    if (Level->environment == E_TEMPLE)
effect3.cpp:    int r=Level->site[Player.x][Player.y].roomnumber;
effect3.cpp:    if (blessing > -1) {
effect3.cpp:                                Level->site[Player.x][Player.y].roomnumber);
effect3.cpp:                               Level->site[Player.x][Player.y].roomnumber);
effect3.cpp:            Player.str-=amount;
effect3.cpp:            Player.con-=amount;
effect3.cpp:    else if ((m = Level->site[x][y].creature) != NULL) {
effect3.cpp:        if (m->uniqueness == COMMON) {
effect3.cpp:            strcat(Str2,m->name);
effect3.cpp:        else strcpy(Str2,m->name);
effect3.cpp:        m->speed = max(2,m->speed-1);
effect3.cpp:            m->m_dropstuff();
effect3.cpp:                m->movef = M_MOVE_SCAREDY;
effect3.cpp:    if (blessing > -1) {
effect3.cpp:        Player.status[VULNERABLE] += random_range(6) - blessing;
env.cpp:    Level->environment = E_ARENA;
env.cpp:    Level->level_width = map_getWidth(glad);
env.cpp:    Level->level_length = map_getLength(glad);
env.cpp:    for(j=0; j<Level->level_length; j++) {
env.cpp:        for(i=0; i<Level->level_width; i++) {
env.cpp:            Level->site[i][j].lstatus = SEEN+LIT;
env.cpp:            Level->site[i][j].roomnumber = RS_ARENA;
env.cpp:            Level->site[i][j].p_locf = L_NO_OP;
env.cpp:                Level->site[i][j].locchar = PORTCULLIS;
env.cpp:                Level->site[i][j].p_locf = L_PORTCULLIS;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                Level->site[i][j].p_locf = L_ARENA_EXIT;
env.cpp:                Level->site[i][j].locchar = WALL;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:            Level->site[i][j].showchar = Level->site[i][j].locchar;
env.cpp:    Level->site[60][7].creature = Arena_Monster;
env.cpp:    Arena_Monster->x = 60;
env.cpp:    Arena_Monster->y = 7;
env.cpp:    Arena_Monster->sense = 50;
env.cpp:    Arena_Monster->m_pickup(box);
env.cpp:    Level->mlist = (MonsterList*) checkmalloc(sizeof(MonsterList));
env.cpp:    Level->mlist->monster = Arena_Monster;
env.cpp:    Level->mlist->next = NULL;
env.cpp:    map *nook; /* I'll never run out of 4-letter names! */
env.cpp:    Level->environment = E_CIRCLE;
env.cpp:    Level->level_width = map_getWidth(nook);
env.cpp:    Level->level_length = map_getLength(nook);
env.cpp:    for(j=0; j<Level->level_length; j++) {
env.cpp:        for(i=0; i<Level->level_width; i++) {
env.cpp:            Level->site[i][j].lstatus = 0;
env.cpp:            Level->site[i][j].roomnumber = RS_CIRCLE;
env.cpp:            Level->site[i][j].p_locf = L_NO_OP;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_PRIME;
env.cpp:                    if (! safe) m_status_set(Level->site[i][j].creature,HOSTILE);
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    if (safe) m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_COURT;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_COURT;
env.cpp:                    if (safe) m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_COURT;
env.cpp:                    if (safe) m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_COURT;
env.cpp:                    if (safe) m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_COURT;
env.cpp:                    if (safe) m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                Level->site[i][j].locchar = WALL;
env.cpp:                Level->site[i][j].aux = 1000;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                Level->site[i][j].p_locf = L_CIRCLE_LIBRARY;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                Level->site[i][j].p_locf = L_TOME1;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                Level->site[i][j].p_locf = L_TOME2;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:            case '-':
env.cpp:                Level->site[i][j].locchar = CLOSED_DOOR;
env.cpp:    m->x = i;
env.cpp:    m->y = j;
env.cpp:    Level->site[i][j].creature = m;
env.cpp:    ml->monster = m;
env.cpp:    ml->next = Level->mlist;
env.cpp:    Level->mlist = ml;
env.cpp:        ol->thing = o;
env.cpp:        ol->next = NULL;
env.cpp:        m->possessions = ol;
env.cpp:    Level->environment = E_COURT;
env.cpp:    Level->level_width = map_getWidth(mage);
env.cpp:    Level->level_length = map_getLength(mage);
env.cpp:    for(j=0; j<Level->level_length; j++) {
env.cpp:        for(i=0; i<Level->level_width; i++) {
env.cpp:            Level->site[i][j].lstatus = 0;
env.cpp:            Level->site[i][j].roomnumber = RS_COURT;
env.cpp:            Level->site[i][j].p_locf = L_NO_OP;
env.cpp:                Level->site[i][j].locchar = CHAIR;
env.cpp:                Level->site[i][j].p_locf = L_THRONE;
env.cpp:                    m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                    m_status_reset(Level->site[i][j].creature,MOBILE);
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_COURT;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_COURT;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                    Level->site[i][j].creature->specialf = M_SP_COURT;
env.cpp:                Level->site[i][j].locchar = WALL;
env.cpp:                Level->site[i][j].aux = 1000;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:                    m_status_reset(Level->site[i][j].creature,HOSTILE);
env.cpp:                Level->site[i][j].locchar = STAIRS_UP;
env.cpp:                Level->site[i][j].p_locf = L_ESCALATOR;
env.cpp:                Level->site[i][j].locchar = FLOOR;
env.cpp:    m->x = i;
env.cpp:    m->y = j;
env.cpp:    Level->site[i][j].creature = m;
env.cpp:    ml->monster = m;
env.cpp:    ml->next = Level->mlist;
env.cpp:    Level->mlist = ml;
env.cpp:    m->specialf = M_SP_COURT;
etc.cpp:        mprint("If you dig too much, you might cause a cave-in!");
etc.cpp:        mprint("`No jail is escapeproof' -- John Dillinger.");
etc.cpp:        mprint("A new moon omens evil for the Law-abiding.");
etc.cpp:        mprint("Druids revere the half-moon.");
etc.cpp:        mprint("They say there's a red-light district in town.");
etc.cpp:        mprint("Follow the Oracle's advice; she is all-wise.");
etc.cpp:        mprint("Star Peak is to the far North-East.");
etc.cpp:        mprint("The Archmage lives in the far North-West beyond a pass.");
etc.cpp:        mprint("The Temple of Athena is to the North-East.");
etc.cpp:    return "Error - you should never see this...";
extern.h:/* extern.h -- function declarations */
file.cpp:                /* so we unlink it ourselves - ugly...	*/
file.cpp:            /* oops - something very wrong */
file.cpp:/* Writes a new high-score file, with the nominated npc as whatever it is */
file.cpp:    unlink(Str2);	/* renames, but sys-V doesn't have rename()... */
file.cpp:    int i= -1;
file.cpp:/* Returns 1 if OK, 0 if impossible to run, -1 if possible but not OK */
file.cpp:        if (getchar()=='y') return(-1);
file.cpp:            printw("\n-More-");
file.cpp:        printw("\n-Done-");
file.cpp:            printw("\n-More-");
file.cpp:        printw("\n-Done-");
file.cpp:        sprintf(buffer, "Unable to write to file %s - Aborting.", deststr);
Food.h:/* food - basic food objects and super class for special foods */
gen1.cpp:        Dungeon = Dungeon->next;
gen1.cpp:        dungeon_level->generated = false;
gen1.cpp:        dungeon_level->numrooms = 0;
gen1.cpp:        dungeon_level->level_length = 0;
gen1.cpp:        dungeon_level->level_width = 0;
gen1.cpp:        dungeon_level->tunnelled = 0;
gen1.cpp:        dungeon_level->depth = 0;
gen1.cpp:        dungeon_level->mlist = NULL;
gen1.cpp:        dungeon_level->next = NULL;
gen1.cpp:        dungeon_level->last_visited = (int)time(NULL);
gen1.cpp:                dungeon_level->site[i][j].locchar = WALL;
gen1.cpp:                dungeon_level->site[i][j].showchar = SPACE;
gen1.cpp:                dungeon_level->site[i][j].creature = NULL;
gen1.cpp:                dungeon_level->site[i][j].things = NULL;
gen1.cpp:                dungeon_level->site[i][j].aux = difficulty()*20;
gen1.cpp:                dungeon_level->site[i][j].buildaux = 0;
gen1.cpp:                dungeon_level->site[i][j].p_locf = L_NO_OP;
gen1.cpp:                dungeon_level->site[i][j].lstatus = 0;
gen1.cpp:                dungeon_level->site[i][j].roomnumber = RS_WALLSPACE;
gen1.cpp:    Player.sx = -1;
gen1.cpp:    Player.sy = -1; /* sanctuary effect dispelled */
gen1.cpp:        Level->next = Dungeon;
gen1.cpp:    if ((!Level->generated) || rewrite_level)
gen1.cpp:        Level->environment = Current_Environment;
gen1.cpp:        Level->depth = tolevel;
gen1.cpp:        Level->generated = true;
gen1.cpp:            Level->level_width = CAVES_WIDTH;
gen1.cpp:            Level->level_length = CAVES_LENGTH;
gen1.cpp:            Level->level_width = SEWERS_WIDTH;
gen1.cpp:            Level->level_length = SEWERS_LENGTH;
gen1.cpp:            Level->level_width = CASTLE_WIDTH;
gen1.cpp:            Level->level_length = CASTLE_LENGTH;
gen1.cpp:            Level->level_width = PALACE_WIDTH;
gen1.cpp:            Level->level_length = PALACE_LENGTH;
gen1.cpp:            Level->level_width = ASTRAL_WIDTH;
gen1.cpp:            Level->level_length = ASTRAL_LENGTH;
gen1.cpp:            Level->level_width = VOLCANO_WIDTH;
gen1.cpp:            Level->level_length = VOLCANO_LENGTH;
gen1.cpp:    ScreenOffset = Player.y - (ScreenLength/2);
gen1.cpp:        while((dungeon->next != NULL) && (dungeon->depth != levelnum))
gen1.cpp:            dungeon = dungeon->next;
gen1.cpp:        if (dungeon->depth == levelnum) {
gen1.cpp:            dungeon->last_visited = (int)time(NULL);
gen1.cpp:        dx = tx - fx;
gen1.cpp:        dy = ty - fy;
gen1.cpp:    if (random_range(20) <= Level->depth/10) {
gen1.cpp:        Level->site[x][y].locchar = FLOOR;
gen1.cpp:    else if (random_range(20)<=Level->depth/2) {
gen1.cpp:        Level->site[x][y].locchar = CLOSED_DOOR;
gen1.cpp:        if (random_range(20) <= Level->depth/10)
gen1.cpp:        if (random_range(40) <= Level->depth)
gen1.cpp:            Level->site[x][y].aux = LOCKED;
gen1.cpp:        else Level->site[x][y].aux = UNLOCKED;
gen1.cpp:        Level->site[x][y].locchar = OPEN_DOOR;
gen1.cpp:        Level->site[x][y].aux = UNLOCKED;
gen1.cpp:        lset(x-1,y,STOPS);
gen1.cpp:        lset(x,y-1,STOPS);
gen1.cpp:    Level->site[x][y].p_locf = L_NO_OP;
gen1.cpp:        if ((*fx < Level->level_width) &&
gen1.cpp:                (*fx > -1) &&
gen1.cpp:                (*fy > -1) &&
gen1.cpp:                (*fy < Level->level_length)) {
gen1.cpp:            Level->site[*fx][*fy].locchar = loc;
gen1.cpp:            if (Level->site[*fx][*fy].roomnumber == RS_WALLSPACE)
gen1.cpp:                Level->site[*fx][*fy].roomnumber = rsi;
gen1.cpp:                Level->site[*fx][*fy].p_locf = L_WATER;
gen1.cpp:                Level->site[*fx][*fy].p_locf = L_NO_OP;
gen1.cpp:                Level->site[*fx][*fy].p_locf = L_RUBBLE;
gen1.cpp:        strcpy(Str4,"A water-filled sewer node");
gen1.cpp:        strcpy(Str4,"A ransacked treasure-chamber.");
gen1.cpp:        strcpy(Str4,"A smoke-filled room.");
gen1.cpp:        strcpy(Str4,"A well-appointed apartment.");
gen1.cpp:        strcpy(Str4,"A multi-purpose room.");
gen1.cpp:    for(i=0; i<Level->level_width; i++)
gen1.cpp:        for(j=0; j<Level->level_length; j++)
gen1.cpp:            if ((Level->site[i][j].locchar == sitechar) && (! found)) {
gen1.cpp:        findspace(&Player.x,&Player.y,-1);
gen1.cpp:        if (Level->environment != E_ASTRAL) {
gen1.cpp:            Level->site[Player.x][Player.y].locchar = sitechar;
gen1.cpp:    for(i=0; i<Level->level_width; i++)
gen1.cpp:        for(j=0; j<Level->level_length; j++)
gen1.cpp:            if ((Level->site[i][j].locchar == FLOOR) &&
gen1.cpp:                    (Level->site[i][j].p_locf == L_NO_OP) &&
gen1.cpp:                    random_range(500) <= ((int)(Level->depth/6)))
gen1.cpp:                Level->site[i][j].p_locf = TRAP_BASE+random_range(NUMTRAPS);
gen1.cpp:            Level->site[i][j].roomnumber = rsi;
gen1.cpp:            Level->site[i][j].buildaux = baux;
gen1.cpp:            Level->site[i][j].locchar = FLOOR;
gen1.cpp:            Level->site[i][j].p_locf = L_NO_OP;
gen1.cpp:    Level->numrooms = 1;
gen1.cpp:    if ((Current_Dungeon == E_CAVES) && (Level->depth == CAVELEVELS))
gen1.cpp:    t = random_range((Level->level_length)/2);
gen1.cpp:    l = random_range((Level->level_width)/2);
gen1.cpp:    e = random_range((Level->level_width)/8)+(Level->level_width)/8;
gen1.cpp:        findspace(&tx,&ty,-1);
gen1.cpp:        fx = random_range((Level->level_width)-2)+1;
gen1.cpp:        fy = random_range((Level->level_length)-2)+1;
gen1.cpp:        findspace(&tx,&ty,-1);
gen1.cpp:        fx = random_range((Level->level_width)-2)+1;
gen1.cpp:        fy = random_range((Level->level_length)-2)+1;
gen1.cpp:        if ((Level->depth == CAVELEVELS) && (! gamestatusp(COMPLETED_CAVES))) {
gen1.cpp:            findspace(&tx,&ty,-1);
gen1.cpp:            Level->mlist = ((MonsterList*) checkmalloc(sizeof(MonsterList)));
gen1.cpp:            Level->mlist->next = NULL;
gen1.cpp:            Level->mlist->monster =
gen1.cpp:                Level->site[tx][ty].creature =
gen1.cpp:            Level->mlist->monster->x = tx;
gen1.cpp:            Level->mlist->monster->y = ty;
gen1.cpp:        if (Level->depth == VOLCANOLEVELS) {
gen1.cpp:            findspace(&tx,&ty,-1);
gen1.cpp:            Level->mlist = ((MonsterList*) checkmalloc(sizeof(MonsterList)));
gen1.cpp:            Level->mlist->next = NULL;
gen1.cpp:            Level->mlist->monster =
gen1.cpp:                Level->site[tx][ty].creature =
gen1.cpp:            Level->mlist->monster->x = tx;
gen1.cpp:            Level->mlist->monster->y = ty;
gen1.cpp:    Level->numrooms = random_range(3)+3;
gen1.cpp:    for (i=0; i<Level->numrooms; i++) {
gen1.cpp:            t = random_range((Level->level_length)-10)+1;
gen1.cpp:            l = random_range((Level->level_width)-10)+1;
gen1.cpp:        } while ((Level->site[l][t].roomnumber == rsi) ||
gen1.cpp:                 (Level->site[l+e][t].roomnumber == rsi) ||
gen1.cpp:                 (Level->site[l][t+e].roomnumber == rsi) ||
gen1.cpp:                 (Level->site[l+e][t+e].roomnumber == rsi));
gen1.cpp:        sewer_corridor(l,t,-1,-1,lchar);
gen1.cpp:        sewer_corridor(l+e,t,1,-1,lchar);
gen1.cpp:        sewer_corridor(l,t+e,-1,1,lchar);
gen1.cpp:        if ((Level->depth == SEWERLEVELS) && (! gamestatusp(COMPLETED_SEWERS))) {
gen1.cpp:            findspace(&tx,&ty,-1);
gen1.cpp:            Level->mlist = ((MonsterList*) checkmalloc(sizeof(MonsterList)));
gen1.cpp:            Level->mlist->next = NULL;
gen1.cpp:            Level->mlist->monster =
gen1.cpp:                Level->site[tx][ty].creature =
gen1.cpp:            Level->mlist->monster->x = tx;
gen1.cpp:            Level->mlist->monster->y = ty;
gen1.cpp:        Level->site[x][y].locchar = locchar;
gen1.cpp:            Level->site[x][y].p_locf = L_WATER;
gen1.cpp:        else Level->site[x][y].p_locf = L_NO_OP;
gen1.cpp:        Level->site[x][y].roomnumber = RS_SEWER_DUCT;
gen1.cpp:                          ((Level->site[x][y].locchar == WALL) ||
gen1.cpp:                           (Level->site[x][y].locchar == WATER)));
gen1.cpp:                          ((Level->site[x][y].roomnumber == RS_WALLSPACE) ||
gen1.cpp:                           (Level->site[x][y].roomnumber == RS_SEWER_DUCT)));
gen1.cpp:    for(x=0; x<Level->level_width; x++)
gen1.cpp:        for(y=0; y<Level->level_length; y++)
gen1.cpp:            if ((Level->site[x][y].locchar == FLOOR) &&
gen1.cpp:                    (Level->site[x][y].p_locf == L_NO_OP) &&
gen1.cpp:                    Level->site[x][y].locchar = ALTAR;
gen1.cpp:                    Level->site[x][y].p_locf = L_ALTAR;
gen1.cpp:                    Level->site[x][y].aux = random_range(10);
gen1.cpp:                    Level->site[x][y].locchar = WATER;
gen1.cpp:                    Level->site[x][y].p_locf = L_MAGIC_POOL;
gen1.cpp:                    Level->site[x][y].locchar = RUBBLE;
gen1.cpp:                    Level->site[x][y].p_locf = L_RUBBLE;
gen1.cpp:                    Level->site[x][y].locchar = LAVA;
gen1.cpp:                    Level->site[x][y].p_locf = L_LAVA;
gen1.cpp:                    Level->site[x][y].locchar = FIRE;
gen1.cpp:                    Level->site[x][y].p_locf = L_FIRE;
gen1.cpp:                    Level->site[x][y].locchar = LIFT;
gen1.cpp:                    Level->site[x][y].p_locf = L_LIFT;
gen1.cpp:                    Level->site[x][y].locchar = HEDGE;
gen1.cpp:                    Level->site[x][y].p_locf = L_HEDGE;
gen1.cpp:                    Level->site[x][y].locchar = HEDGE;
gen1.cpp:                    Level->site[x][y].p_locf = L_TRIFID;
gen1.cpp:                    Level->site[x][y].locchar = STATUE;
gen1.cpp:                            if (Level->site[x+Dirs[0][j]][y+Dirs[1][j]].p_locf != L_NO_OP)
gen1.cpp:                                Level->site[x+Dirs[0][j]][y+Dirs[1][j]].locchar = FLOOR;
gen1.cpp:                            Level->site[x+Dirs[0][j]][y+Dirs[1][j]].p_locf =
gen1.cpp:                        Level->site[x][y].locchar = LAVA;
gen1.cpp:                        Level->site[x][y].p_locf = L_LAVA;
gen1.cpp:                        if (Level->depth == 1) {
gen1.cpp:                            Level->site[x][y].locchar = RUBBLE;
gen1.cpp:                            Level->site[x][y].p_locf = L_RUBBLE;
gen1.cpp:                        else if (Level->depth == 2) {
gen1.cpp:                            Level->site[x][y].locchar = FIRE;
gen1.cpp:                            Level->site[x][y].p_locf = L_FIRE;
gen1.cpp:                        else if (Level->depth == 3) {
gen1.cpp:                            Level->site[x][y].locchar = WATER;
gen1.cpp:                            Level->site[x][y].p_locf = L_WATER;
gen1.cpp:                        else if (Level->depth == 4) {
gen1.cpp:                            Level->site[x][y].locchar = ABYSS;
gen1.cpp:                            Level->site[x][y].p_locf = L_ABYSS;
gen1.cpp:                        Level->site[x][y].locchar = WATER;
gen1.cpp:                        Level->site[x][y].p_locf = L_WATER;
gen2.cpp:        findspace(&i,&j,-1);
gen2.cpp:        Level->site[i][j].locchar = STAIRS_UP;
gen2.cpp:        Level->site[i][j].aux = Level->depth-1;
gen2.cpp:        if (fromlevel >= 0 && fromlevel < Level->depth) {
gen2.cpp:    if (Level->depth < MaxDungeonLevels) {
gen2.cpp:        findspace(&i,&j,-1);
gen2.cpp:        Level->site[i][j].locchar = STAIRS_DOWN;
gen2.cpp:        Level->site[i][j].aux = Level->depth+1;
gen2.cpp:        if (fromlevel > Level->depth) {
gen2.cpp:    Level->environment = E_TACTICAL_MAP;
gen2.cpp:    Level->generated = true;
gen2.cpp:    Level->level_length = TACTICAL_LENGTH;
gen2.cpp:    Level->level_width = TACTICAL_WIDTH;
gen2.cpp:        for(i=0; i<Level->level_width; i++)
gen2.cpp:            for(j=0; j<Level->level_length; j++) {
gen2.cpp:                Level->site[i][j].showchar = SPACE;
gen2.cpp:                Level->site[i][j].lstatus = 0;
gen2.cpp:    for (i=0; i<Level->level_width; i++)
gen2.cpp:        for (j=0; j<Level->level_length; j++) {
gen2.cpp:                curr = Level->site[i - 1][j].locchar&0xff;
gen2.cpp:                curr = Level->site[i][j - 1].locchar&0xff;
gen2.cpp:                Level->site[i][j].locchar = Level->site[i][j].showchar = FLOOR;
gen2.cpp:                Level->site[i][j].p_locf = L_NO_OP;
gen2.cpp:                Level->site[i][j].locchar = Level->site[i][j].showchar = HEDGE;
gen2.cpp:                Level->site[i][j].p_locf = L_HEDGE;
gen2.cpp:                Level->site[i][j].locchar = Level->site[i][j].showchar = WATER;
gen2.cpp:                Level->site[i][j].p_locf = L_WATER;
gen2.cpp:                Level->site[i][j].locchar = Level->site[i][j].showchar = RUBBLE;
gen2.cpp:                Level->site[i][j].p_locf = L_RUBBLE;
gen2.cpp:            Level->site[i][j].lstatus = SEEN+LIT;
gen2.cpp:            Level->site[i][j].roomnumber = RS_COUNTRYSIDE;
gen2.cpp:            if ((i == 0) || (j == 0) || (i == (Level->level_width)-1) || (j == (Level->level_length)-1))
gen2.cpp:                Level->site[i][j].p_locf = L_TACTICAL_EXIT;
gen2.cpp:    for (x = (Level->level_width)/2 - 3; x <= (Level->level_width)/2 + 3; x++)
gen2.cpp:        for (y = 0; y < Level->level_length; y++) {
gen2.cpp:            Level->site[x][y].locchar = Level->site[x][y].showchar = FLOOR;
gen2.cpp:            if (y != 0 && y != ((Level->level_length) - 1))
gen2.cpp:                Level->site[x][y].p_locf = L_NO_OP;
gen2.cpp:    straggle_corridor(0,random_range(Level->level_length),Level->level_width,random_range(Level->level_length),
gen2.cpp:    y = random_range(Level->level_length);
gen2.cpp:    y1 = random_range(Level->level_length);
gen2.cpp:    straggle_corridor(0,y,Level->level_width,y1,WATER,RS_COUNTRYSIDE);
gen2.cpp:        if (y > (Level->level_length)/2) y--;
gen2.cpp:        if (y1 > (Level->level_length)/2) y1--;
gen2.cpp:        straggle_corridor(0,y,Level->level_width,y1,WATER,RS_COUNTRYSIDE);
gen2.cpp:    y = random_range(Level->level_length);
gen2.cpp:    x1 = Level->level_width;
gen2.cpp:    y1 = random_range(Level->level_length);
gen2.cpp:        x = random_range(Level->level_width);
gen2.cpp:        x1 = random_range(Level->level_width);
gen2.cpp:        y1 = Level->level_length;
gen2.cpp:    Level->numrooms = random_range(8)+9;
gen2.cpp:        t = random_range((Level->level_length)-10)+1;
gen2.cpp:        l = random_range((Level->level_width)-10)+1;
gen2.cpp:    } while ((Level->site[l][t].roomnumber != RS_WALLSPACE) ||
gen2.cpp:             (Level->site[l+e][t].roomnumber != RS_WALLSPACE) ||
gen2.cpp:             (Level->site[l][t+e].roomnumber != RS_WALLSPACE) ||
gen2.cpp:             (Level->site[l+e][t+e].roomnumber != RS_WALLSPACE));
gen2.cpp:    for (i=2; i<=Level->numrooms; i++) {
gen2.cpp:            t = random_range((Level->level_length)-10)+1;
gen2.cpp:            l = random_range((Level->level_width)-10)+1;
gen2.cpp:        } while ((Level->site[l][t].roomnumber != RS_WALLSPACE) ||
gen2.cpp:                 (Level->site[l+e][t].roomnumber != RS_WALLSPACE) ||
gen2.cpp:                 (Level->site[l][t+e].roomnumber != RS_WALLSPACE) ||
gen2.cpp:                 (Level->site[l+e][t+e].roomnumber != RS_WALLSPACE));
gen2.cpp:            fx = l+1+random_range(e-1);
gen2.cpp:            fy = t+1+random_range(e-1);
gen2.cpp:            fx = l+1+random_range(e-1);
gen2.cpp:            fy = t+1+random_range(e-1);
gen2.cpp:                fx = l+1+random_range(e-1);
gen2.cpp:                fy = t+1+random_range(e-1);
gen2.cpp:                fx = l+1+random_range(e-1);
gen2.cpp:                fy = t+1+random_range(e-1);
gen2.cpp:        if (Level->depth == SEWERLEVELS) {
gen2.cpp:            findspace(&tx,&ty,-1);
gen2.cpp:            Level->mlist = ((MonsterList*) checkmalloc(sizeof(MonsterList)));
gen2.cpp:            Level->mlist->next = NULL;
gen2.cpp:            Level->mlist->monster =
gen2.cpp:                Level->site[tx][ty].creature =
gen2.cpp:            Level->mlist->monster->x = tx;
gen2.cpp:            Level->mlist->monster->y = ty;
gen2.cpp:        if (Level->depth == PALACELEVELS) {
gen2.cpp:            findspace(&tx,&ty,-1);
gen2.cpp:            Level->mlist = ((MonsterList*) checkmalloc(sizeof(MonsterList)));
gen2.cpp:            Level->mlist->next = NULL;
gen2.cpp:            Level->mlist->monster =
gen2.cpp:                Level->site[tx][ty].creature =
gen2.cpp:            Level->mlist->monster->x = tx;
gen2.cpp:            Level->mlist->monster->y = ty;
gen2.cpp:        if (Level->depth == CASTLELEVELS) {
gen2.cpp:            findspace(&tx,&ty,-1);
gen2.cpp:            Level->site[tx][ty].locchar = STAIRS_DOWN;
gen2.cpp:            Level->site[tx][ty].p_locf = L_ENTER_COURT;
gen2.cpp:        if (Level->depth == VOLCANOLEVELS && !gamestatusp(COMPLETED_VOLCANO)) {
gen2.cpp:            findspace(&tx,&ty,-1);
gen2.cpp:            Level->mlist = ((MonsterList*) checkmalloc(sizeof(MonsterList)));
gen2.cpp:            Level->mlist->next = NULL;
gen2.cpp:            Level->mlist->monster =
gen2.cpp:                Level->site[tx][ty].creature =
gen2.cpp:            Level->mlist->monster->x = tx;
gen2.cpp:            Level->mlist->monster->y = ty;
gen2.cpp:    dx = sign(tx-fx);
gen2.cpp:    dy = sign(ty-fy);
gen2.cpp:        Level->site[fx][fy].locchar = FLOOR;
gen2.cpp:        Level->site[fx][fy].roomnumber = RS_CORRIDOR;
gen2.cpp:        Level->site[fx][fy].buildaux = baux;
gen2.cpp:        dx = sign(tx-fx);
gen2.cpp:        dy = sign(ty-fy);
gen2.cpp:                      ((Level->site[fx][fy].buildaux == 0) ||
gen2.cpp:                       (Level->site[fx][fy].buildaux == baux)));
gen2.cpp:        switch (Level->depth)
gen2.cpp:        maze_corridor(1 + random_range(Level->level_width - 1),
gen2.cpp:                      1 + random_range(Level->level_length - 1),
gen2.cpp:                      1 + random_range(Level->level_width - 1),
gen2.cpp:                      1 + random_range(Level->level_length - 1),
gen2.cpp:            for (x_idx = 0; x_idx < Level->level_width; ++x_idx)
gen2.cpp:                for (y_idx = 0; y_idx < Level->level_length; ++y_idx)
gen2.cpp:                    if (WALL == Level->site[x_idx][y_idx].locchar)
gen2.cpp:                        switch (Level->depth)
gen2.cpp:                            Level->site[x_idx][y_idx].aux = 500;
gen2.cpp:                            Level->site[x_idx][y_idx].locchar = WHIRLWIND;
gen2.cpp:                            Level->site[x_idx][y_idx].p_locf = L_WHIRLWIND;
gen2.cpp:                            Level->site[x_idx][y_idx].locchar = WATER;
gen2.cpp:                            Level->site[x_idx][y_idx].p_locf = L_WATER;
gen2.cpp:                            Level->site[x_idx][y_idx].locchar = FIRE;
gen2.cpp:                            Level->site[x_idx][y_idx].p_locf = L_FIRE;
gen2.cpp:                            Level->site[x_idx][y_idx].locchar = ABYSS;
gen2.cpp:                            Level->site[x_idx][y_idx].p_locf = L_ABYSS;
gen2.cpp:                switch (Level->depth)
gen2.cpp:                if (5 == Level->depth)
gen2.cpp:                    findspace(&tx, &ty, -1);
gen2.cpp:                    Level->site[tx][ty].p_locf = L_ENTER_CIRCLE;
gen2.cpp:                    Level->site[tx][ty].locchar = STAIRS_DOWN;
gen2.cpp:                    findspace(&tx, &ty, -1);
gen2.cpp:                    Level->mlist = (MonsterList*) checkmalloc(sizeof(MonsterList));
gen2.cpp:                    Level->mlist->next = NULL;
gen2.cpp:                    Level->mlist->monster = make_creature(mid);
gen2.cpp:                    Level->mlist->monster->x = tx;
gen2.cpp:                    Level->mlist->monster->y = ty;
gen2.cpp:                    Level->site[tx][ty].creature = Level->mlist->monster;
gen2.cpp:        if (VOLCANOLEVELS == Level->depth && !gamestatusp(COMPLETED_VOLCANO))
gen2.cpp:            findspace(&tx, &ty, -1);
gen2.cpp:            Level->mlist = (MonsterList*) checkmalloc(sizeof(MonsterList));
gen2.cpp:            Level->mlist->next = NULL;
gen2.cpp:            Level->mlist->monster = make_creature(DEMON_EMP);
gen2.cpp:            Level->mlist->monster->x = tx;
gen2.cpp:            Level->mlist->monster->y = ty;
gen2.cpp:            Level->site[tx][ty].creature = Level->mlist->monster;
gen2.cpp:                      random_range((Level->level_width)-1)+1,
gen2.cpp:                      random_range((Level->level_length)-1)+1,
glob.h:/* locations of city sites [0] - found, [1] - x, [2] - y */
Grot.cpp:            return "broken yo-yo";
Grot.cpp:            return "three-dollar bill";
Grot.h:/* grot - misc world flavor objects */
guild1.cpp:    0, 400, 1500, 4000, -1
guild1.cpp:                account->balance = 500;
guild1.cpp:                newitem = bank_create_card(account->number, OB_DEBIT_CARD);
guild1.cpp:                SalaryAccount = account->number;
guild1.cpp:            print2("You are now a Legion Force-Leader!");
guild1.cpp:            nprint2("-- Duke of Rampart! <fanfare>");
guild1.cpp:            if (find_and_remove_item(OB_DEFENDER,-1)) {
guild1.cpp:            if (find_and_remove_item(OB_DRAGONSCALE,-1)) {
guild1.cpp:            if (find_item(&o,OB_ORB_MASTERY,-1)) {
guild1.cpp:                        if (Level->site[x][y].p_locf == L_TRAP_SIREN) {
guild1.cpp:                            Level->site[x][y].p_locf = L_NO_OP;
guild1.cpp:                            Level->site[x][y].locchar = FLOOR;
guild1.cpp:                Arena_Monster->name = salloc(Str1);
guild1.cpp:                Arena_Monster->corpseString = salloc(Str2);
guild1.cpp:                Arena_Monster->level = 20;
guild1.cpp:                Arena_Monster->hp = Championlevel*Championlevel*5;
guild1.cpp:                Arena_Monster->hit = Championlevel*4;
guild1.cpp:                Arena_Monster->ac = Championlevel*3;
guild1.cpp:                Arena_Monster->dmg = 100+Championlevel*2;
guild1.cpp:                Arena_Monster->xpv = Championlevel*Championlevel*5;
guild1.cpp:                Arena_Monster->speed = 3;
guild1.cpp:                melee = Arena_Monster->combatManeuvers = (char *) checkmalloc(30*sizeof(char));
guild1.cpp:                strcpy(Arena_Monster->combatManeuvers,"");
guild1.cpp:                    strcat(Arena_Monster->combatManeuvers,"L?R?");
guild1.cpp:                    i = random_range(ML9 - ML0) + ML0;
guild1.cpp:        monsterlevel = Arena_Monster->level;
guild1.cpp:        if (Arena_Monster->level != 20) {
guild1.cpp:            strcat(Str1,Arena_Monster->name);
guild1.cpp:            Arena_Monster->name = salloc(Str1);
guild1.cpp:            Arena_Monster->corpseString = salloc(Str2);
guild1.cpp:        Arena_Monster->uniqueness = UNIQUE_MADE;
guild1.cpp:        print2(Arena_Monster->name);
guild1.cpp:        Arena_Monster->wasAttackedByPlayer = true;
guild1.cpp:        Arena_Monster->hp += Arena_Monster->level*10;
guild1.cpp:        Arena_Monster->hit += Arena_Monster->hit;
guild1.cpp:        Arena_Monster->dmg += Arena_Monster->dmg/2;
guild1.cpp:                Player.rank[ARENA] = -1;
guild2.cpp:                find_and_remove_item(OB_JUSTICIAR_BADGE,-1)) {
guild2.cpp:                    dues += dues*(12-Player.dex)/9;
guild2.cpp:                            Player.cash -= dues;
guild2.cpp:                        Player.cash -= fee;
guild2.cpp:                            if (Player.possessions[i]->known < 2)
guild2.cpp:                            if (Player.pack[i]->known < 2)
guild2.cpp:                            Player.cash -= max(count*fee,fee);
guild2.cpp:                            print2("Huh, Is this some kind of set-up?");
guild2.cpp:                        } else if (Player.possessions[i]->blessing < 0)
guild2.cpp:                                number = getnumber(Player.possessions[i]->number);
guild2.cpp:                                if ((number >= Player.possessions[i]->number) &&
guild2.cpp:                                        Player.possessions[i]->used) {
guild2.cpp:                                    Player.possessions[i]->used = false;
guild2.cpp:                                if (Objects[Player.possessions[i]->id].uniqueness >
guild2.cpp:                                    Objects[Player.possessions[i]->id].uniqueness = UNIQUE_UNMADE;
guild2.cpp:                            if (Player.pack[i]->blessing > -1) {
guild2.cpp:                                    number = getnumber(Player.pack[i]->number);
guild2.cpp:                                    Player.pack[i]->number -= number;
guild2.cpp:                                    if (Player.pack[i]->number < 1) {
guild2.cpp:                                        if (Objects[Player.pack[i]->id].uniqueness > UNIQUE_UNMADE)
guild2.cpp:                                            Objects[Player.pack[i]->id].uniqueness = UNIQUE_UNMADE;
guild2.cpp:                                Player.cash -= 1000;
guild2.cpp:                            Player.cash -= 2000;
guild2.cpp:                    Spellsleft--;
guild2.cpp:            nprint2(" -- 1 free yoga session");
guild2.cpp:            menuprint("ESCAPE: Re-enter the World.\n");
guild2.cpp:                    Studiesleft--;
guild2.cpp:                                YogaSessions--;
guild2.cpp:                                Player.cash -= 2000;
guild2.cpp:                            else if ( Player.maxpow < 22 && random_range( 10 ) < (10 - (Player.maxpow - 12)))
guild2.cpp:    if (Player.rank[CIRCLE] == -1) {
guild2.cpp:                    print2("You may not join -- you reek of Law!");
guild2.cpp:                    fee += fee*(12 - Player.pow)/9;
guild2.cpp:                            Player.cash -= fee;
guild2.cpp:                else if (Player.alignment > -1) {
guild2.cpp:                    Player.rank[CIRCLE] = -1;
guild2.cpp:                    acquire(-1);
guild2.cpp:                    enchant(-1);
guild2.cpp:                    bless(-1);
guild2.cpp:                        Player.cash -= fee;
guild2.cpp:        for (ml = Level->mlist; ml && (ml->monster->id != HISCORE_NPC ||
guild2.cpp:                                       ml->monster->aux2 != 15); ml = ml->next)
guild2.cpp:            ml->monster->m_remove(); /* signals "death" -- no credit to player, though */
guild2.cpp:        newitem->blessing = 9;
guild2.cpp:            Player.rank[ORDER]= -1;
guild2.cpp:    else if (Player.rank[ORDER] == -1)
guild2.cpp:                newitem->blessing = 9;
guild2.cpp:                newitem->plus = 1;
guild2.cpp:                newitem->known = 2;
guild2.cpp:                newitem->blessing = 9;
guild2.cpp:                newitem->known = 2;
guild2.cpp:                newitem->known = 2;
guild2.cpp:                newitem->known = 2;
house.cpp:    Level->level_width=map_getWidth(home);
house.cpp:    Level->level_length=map_getLength(home);
house.cpp:    for(j=0; j<Level->level_length; j++) {
house.cpp:        for(i=0; i<Level->level_width; i++) {
house.cpp:            if (kind == E_HOVEL) Level->site[i][j].lstatus = SEEN;
house.cpp:            else Level->site[i][j].lstatus = 0;
house.cpp:            Level->site[i][j].roomnumber = RS_CORRIDOR;
house.cpp:            Level->site[i][j].p_locf = L_NO_OP;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_BEDROOM;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_BEDROOM;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_DININGROOM;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_CLOSET;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_BATHROOM;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_BEDROOM;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_KITCHEN;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].showchar = WALL;
house.cpp:                Level->site[i][j].roomnumber = RS_SECRETPASSAGE;
house.cpp:                Level->site[i][j].locchar = SAFE;
house.cpp:                Level->site[i][j].showchar = WALL;
house.cpp:                Level->site[i][j].p_locf = L_SAFE;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].p_locf = TRAP_BASE+random_range(NUMTRAPS);
house.cpp:                Level->site[i][j].locchar = PORTCULLIS;
house.cpp:                Level->site[i][j].p_locf = L_PORTCULLIS;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].p_locf = L_RAISE_PORTCULLIS;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].p_locf = L_PORTCULLIS;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].p_locf = L_PORTCULLIS_TRAP;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].p_locf = L_HOUSE_EXIT;
house.cpp:                Level->site[i][j].locchar = WALL;
house.cpp:                    Level->site[i][j].aux = 10;
house.cpp:                    Level->site[i][j].aux = 50;
house.cpp:                    Level->site[i][j].aux = 150;
house.cpp:                Level->site[i][j].locchar = OPEN_DOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_CORRIDOR;
house.cpp:                Level->site[i][j].locchar = CLOSED_DOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_CORRIDOR;
house.cpp:                Level->site[i][j].aux = LOCKED;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_CORRIDOR;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_CORRIDOR;
house.cpp:                Level->site[i][j].p_locf = L_TRAP_SIREN;
house.cpp:                Level->site[i][j].locchar = FLOOR;
house.cpp:                Level->site[i][j].roomnumber = RS_CORRIDOR;
house.cpp:            Level->site[i][j].showchar = ' ';
house.cpp:    ml->monster = ((Monster*) checkmalloc(sizeof(Monster)));
house.cpp:    *(ml->monster) = Monsters[NPC];
house.cpp:    make_log_npc(ml->monster);
house.cpp:    if (ml->monster->id == NPC) mprint("You detect signs of life in this house.");
house.cpp:    ml->monster->x = i;
house.cpp:    ml->monster->y = j;
house.cpp:    Level->site[i][j].creature = ml->monster;
house.cpp:    ml->monster->click = (Tick + 1) % 50;
house.cpp:    ml->next = Level->mlist;
house.cpp:    Level->mlist = ml;
house.cpp:    m_status_set(ml->monster,HOSTILE);
house.cpp:        m_status_reset(ml->monster,AWAKE);
house.cpp:    else m_status_set(ml->monster,AWAKE);
house.cpp:    if (ml->monster->startThing > -1) {
house.cpp:        *ob = Objects[ml->monster->startThing];
house.cpp:        ml->monster->m_pickup(ob);
house.cpp:    ml->monster = ((Monster*) checkmalloc(sizeof(Monster)));
house.cpp:    *(ml->monster) = Monsters[NPC];
house.cpp:    make_hiscore_npc(ml->monster,random_range(14) + 1);
house.cpp:    ml->monster->x = i;
house.cpp:    ml->monster->y = j;
house.cpp:    Level->site[i][j].creature = ml->monster;
house.cpp:    ml->monster->click = (Tick + 1) % 50;
house.cpp:    ml->next = Level->mlist;
house.cpp:    Level->mlist = ml;
house.cpp:    m_status_set(ml->monster,HOSTILE);
house.cpp:        m_status_reset(ml->monster,AWAKE);
house.cpp:    else m_status_set(ml->monster,AWAKE);
inv.cpp:        Player.cash -= c;
inv.cpp:        cash->basevalue = c;
inv.cpp:    ol = Level->site[x][y].things;
inv.cpp:    Level->site[x][y].things = 0;
inv.cpp:        response = cinema_ynq(strjoin("Pick up? [ynq]: ", itemid(ol->thing)));
inv.cpp:            gain_item(ol->thing);
inv.cpp:            drop_at(x,y,ol->thing);
inv.cpp:        ol = ol->next;
inv.cpp:        temp->next = 0;
inv.cpp:        temp->thing = 0;
inv.cpp:        ol = ol->next;
inv.cpp:        temp->next = 0;
inv.cpp:        temp->thing = 0;
inv.cpp:/* WDT -- convert from a char (keypress) to an item index in
inv.cpp:signed char inventory_keymap[] = "-abcfghimnoqruvwyz";
inv.cpp:    else return '-';
inv.cpp:/* WDT -- why on earth does the 'slottable' function print stuff???? */
inv.cpp:        if (o->objchar != ARMOR) {
inv.cpp:        if (o->objchar != SHIELD) {
inv.cpp:        if (o->objchar != BOOTS) {
inv.cpp:        if (o->objchar != CLOAK) {
inv.cpp:        if (o->objchar != RING) {
inv.cpp:/* put all of o on objlist at x,y on Level->depth */
inv.cpp:        if ((Level->site[x][y].locchar != VOID_CHAR) &&
inv.cpp:                (Level->site[x][y].locchar != ABYSS)) {
inv.cpp:            cpy->used = false;
inv.cpp:            tmp->thing = cpy;
inv.cpp:            tmp->next = Level->site[x][y].things;
inv.cpp:            Level->site[x][y].things = tmp;
inv.cpp:        else if (Level->site[x][y].p_locf == L_VOID_STATION)
inv.cpp:/* put n of o on objlist at x,y on Level->depth */
inv.cpp:        if ((Level->site[x][y].locchar != VOID_CHAR) &&
inv.cpp:                (Level->site[x][y].locchar != ABYSS)) {
inv.cpp:            tmp->thing = copy_obj( o );
inv.cpp:            tmp->thing->used = false;
inv.cpp:            tmp->thing->number = n;
inv.cpp:            nprint2(itemid(tmp->thing));
inv.cpp:            tmp->next = Level->site[x][y].things;
inv.cpp:            Level->site[x][y].things = tmp;
inv.cpp:        else if (Level->site[x][y].p_locf == L_VOID_STATION)
inv.cpp:    if (obj->objchar==CASH) {
inv.cpp:        strcpy(Str4,obj->truename);
inv.cpp:        if (Objects[obj->id].known > obj->known)
inv.cpp:            obj->known = Objects[obj->id].known;
inv.cpp:        if (obj->known == 0)
inv.cpp:            strcat(Str4,obj->objstr);
inv.cpp:        else if (obj->known == 1) {
inv.cpp:            if (obj->id == OB_YENDOR || obj->id == OB_KARNAK ||
inv.cpp:                    obj->id == OB_STARGEM )
inv.cpp:            strcat(Str4,obj->truename);
inv.cpp:            if (obj->id == OB_YENDOR || obj->id == OB_KARNAK ||
inv.cpp:                    obj->id == OB_STARGEM )
inv.cpp:            if (obj->usef == I_NOTHING && Objects[obj->id].usef != I_NOTHING)
inv.cpp:            if (obj->isCursed()) {
inv.cpp:                strcat(Str4, obj->cursestr);
inv.cpp:            else if (obj->blessing > 0) {
inv.cpp:                strcat(Str4, obj->truename);
inv.cpp:            else strcat(Str4,obj->truename);
inv.cpp:            if (obj->number > 1) strcat(Str4,"s");
inv.cpp:            switch (obj->objchar) {
inv.cpp:    pstr[1] = (obj->plus < 0 ? '-' : '+' );
inv.cpp:    if (abs(obj->plus) < 10) {
inv.cpp:        pstr[2] = '0' + abs(obj->plus);
inv.cpp:        pstr[2] = '0' + abs(obj->plus / 10);
inv.cpp:        pstr[3] = '0' + abs(obj->plus % 10);
inv.cpp:    if (obj->number < 2)
inv.cpp:    else if (obj->number < 10) {
inv.cpp:        nstr[0] = '0' + obj->number;
inv.cpp:    else if (obj->number < 41) {
inv.cpp:        nstr[0] = '0' + ((int)(obj->number / 10));
inv.cpp:        nstr[1] = '0' + (obj->number % 10);
inv.cpp:    if (obj->charge < 0) {
inv.cpp:    else if (obj->charge < 10) {
inv.cpp:        cstr[2] = '0' + obj->charge;
inv.cpp:        cstr[2] = '0' + ((int)(obj->charge / 10));
inv.cpp:        cstr[3] = '0' + (obj->charge % 10);
inv.cpp:    if (Player.rank[ORDER] == -1) {
inv.cpp:    /* special case -- give gem to LawBringer */
inv.cpp:    if ((m->id == LAWBRINGER) && (o->id == OB_STARGEM))
inv.cpp:        if (m->uniqueness == COMMON) {
inv.cpp:            strcat(Str3,m->name);
inv.cpp:        else strcpy(Str3,m->name);
inv.cpp:            m->m_pickup(o);
inv.cpp:            if (m_statusp(m,GREEDY) && (true_item_value(o) < (long) m->level*100))
inv.cpp:                     (true_item_value(o) < (long) Level->depth*Level->depth))
inv.cpp:            if (((m->id == HORSE) && (o->id == OB_GRAIN)) || /* grain */
inv.cpp:                    ((m->id != HORSE) &&
inv.cpp:                     ((o->usef == I_FOOD) || (o->usef == I_POISON_FOOD)))) {
inv.cpp:                if  (o->usef == I_POISON_FOOD) {
inv.cpp:                    Player.alignment -= 2;
inv.cpp:                    m->m_damage(100,POISON);
inv.cpp:                drop_at(m->x,m->y,o);
inv.cpp:            drop_at(m->x,m->y,o);
inv.cpp:    if (obj != NULL) conform_lost_objects(obj->number,obj);
inv.cpp:                obj->number -= n;
inv.cpp:            if (obj->number < 1) {
inv.cpp:    if (obj->number < 1)
inv.cpp:                    obj->number -= n;
inv.cpp:                if (obj->number < 1) {
inv.cpp:    if (obj->used) {
inv.cpp:        obj->used = false;
inv.cpp:    if (item->objchar == itype) return true;
inv.cpp:    if (FOOD == itype && CORPSE == item->objchar) return true;
inv.cpp:    selectstr[k-1] = ')';
inv.cpp:    if (-1 == key) return ABORT; /* cinema_interact() returns -1 for ESC */
inv.cpp:    int slot = slotchar + 1 - 'a';
inv.cpp:    if (o->uniqueness == UNIQUE_MADE)
inv.cpp:        Objects[o->id].uniqueness = UNIQUE_TAKEN;
inv.cpp:    if (o->objchar == CASH) {
inv.cpp:        Player.cash += o->basevalue;
inv.cpp:    for (i = Player.packptr; i > 0; i--)
inv.cpp:        Player.pack[i] = Player.pack[i-1];
inv.cpp:/* WDT -- 'response' must be an index into the pack. */
inv.cpp:    for(i=response; i<Player.packptr-1; i++)
inv.cpp:    Player.pack[--Player.packptr] = NULL;
inv.cpp:            twohandedp(item->id))
inv.cpp:        item->used = true;
inv.cpp:        if (item->number > 1) pack_extra_items(item);
inv.cpp:        for(i=start_item; i<Player.packptr && items<ScreenLength-5; i++) {
inv.cpp: * or to 'up-in-air', one of which at least must be empty */
inv.cpp:                print1("Enter pack slot letter, - to go back, or ESCAPE to quit.");
inv.cpp:                print1("Enter pack slot letter, + or - to see more, or ESCAPE to quit.");
inv.cpp:                /* WDT HACK -- display some help instead. */
inv.cpp:            else if (response == '-') {
inv.cpp:                if (ok) ok = slottable(Player.pack[response-'a'],slot);
inv.cpp:            use_pack_item(response - 'a',slot);
inv.cpp:or to 'up-in-air', one of which at least must be empty */
inv.cpp:                if (ok) ok = slottable(Player.pack[response-'a'],slot);
inv.cpp:        if (! quit) use_pack_item(response - 'a',slot);
inv.cpp:                            Player.possessions[slot]->objstr))
inv.cpp:                    if (Player.possessions[slot]->uniqueness == COMMON)
inv.cpp:                    if (Player.possessions[slot]->objchar == BOOTS)
inv.cpp:                        letter = Player.possessions[slot]->objstr[0];
inv.cpp:                    strcat(Str1, Player.possessions[slot]->objstr);
inv.cpp:            slot = move_slot(slot,slot-1,MAXITEMS);
inv.cpp:        case '-':
inv.cpp:            slot = move_slot(slot,MAXITEMS-1,MAXITEMS);
inv.cpp:            menuprint("d:\tDrop up-in-air or current item\n");
inv.cpp:            menuprint("e:\tExchange current slot with up-in-air slot\n");
inv.cpp:            menuprint("p:\tPut up-in-air or current item in pack\n");
inv.cpp:            menuprint("t:\tTake something from pack into the\n\tcurrent or up-in-air slot\n");
inv.cpp:            menuprint("x:\tAs 'e', but exit if up-in-air slot finishes empty\n");
inv.cpp:                            Player.possessions[slot]->objstr))
inv.cpp:                    if (Player.possessions[slot]->uniqueness == COMMON)
inv.cpp:                    if (Player.possessions[slot]->objchar == BOOTS)
inv.cpp:                        letter = Player.possessions[slot]->objstr[0];
inv.cpp:                    strcat(Str1, Player.possessions[slot]->objstr);
inv.cpp:            menuprint("e:\tExchange a slot with up-in-air slot\n");
inv.cpp:            menuprint("x:\tAs 'e', above, exit if up-in-air slot finishes empty\n");
inv.cpp:            menuprint("~:\tEnter full-screen inventory mode\n");
inv.cpp:        print1("Which inventory slot ['-'='up-in-air' slot]?");
inv.cpp:        if ( response == ESCAPE || response == '-' )
inv.cpp:/* returns some number between 0 and o->number */
inv.cpp:    if (o->number == 1)
inv.cpp:        print1("How many? -- max ");
inv.cpp:        mnumprint(o->number);
inv.cpp:        if (n>o->number) print3("Too many!");
inv.cpp:    } while (n > o->number);
inv.cpp:        if(Player.possessions[slot]->isCursed() && Player.possessions[slot]->isUsed())
inv.cpp:                waitflag = (Player.possessions[slot]->used &&
inv.cpp:                            (Player.possessions[slot]->number == n));
inv.cpp:    else if (oslot != NULL && oslot->isCursed() && oslot->isUsed())
inv.cpp:            waitflag = (oslot->isUsed() && (oslot->number == num));
inv.cpp:        if (num <= item->number)
inv.cpp:            newitem->number = num;
inv.cpp:        /* else num > item->number, so return newitem with number = item->number */
inv.cpp:        newitem->used = false;	/* whether the original item was used or not */
inv.cpp:    else if (oslot != NULL && oslot->isCursed() && oslot->isUsed()) /* Check both via object methods */
inv.cpp:        print3("The object in that slot is cursed -- you can't get rid of it!");
inv.cpp:            a2h = (twohandedp(oair->id) &&
inv.cpp:            /* deal with a 2-handed weapon */
inv.cpp:                oair->used = true;
inv.cpp:                if (oair->number > 1) pack_extra_items(oair);
inv.cpp:            num = oslot->number;
inv.cpp:            conform_lost_objects(oslot->number,oslot);
inv.cpp:            oslot->number = num;
inv.cpp:                oair->used = true;
inv.cpp:                if (oair->number > 1) pack_extra_items(oair);
inv.cpp:/* merges the up-in-air items into the selected items */
inv.cpp:    Player.possessions[slot]->number +=
inv.cpp:        Player.possessions[O_UP_IN_AIR]->number;
inv.cpp:                       (o->id == p->id) &&
inv.cpp:                       (o->id != CORPSEID) &&
inv.cpp:                       (o->plus == p->plus) &&
inv.cpp:                       (o->charge == 0) &&
inv.cpp:                       (p->charge == 0) &&
inv.cpp:                       (o->dmg == p->dmg) &&
inv.cpp:                       (o->hit == p->hit) &&
inv.cpp:                       (o->aux == p->aux) &&
inv.cpp:                       (o->known == p->known) &&
inv.cpp:                       (o->blessing == p->blessing) &&
inv.cpp:                       (o->usef == p->usef) &&
inv.cpp:                       (o->objstr == p->objstr )
inv.cpp:        if (o->objchar != ARMOR) {
inv.cpp:        if (o->objchar != SHIELD) {
inv.cpp:        if (o->objchar != BOOTS) {
inv.cpp:        if (o->objchar != CLOAK) {
inv.cpp:        if (o->objchar != RING) {
inv.cpp:    /* weapon is useable if it is put in weapon hand or if it is two-handed
inv.cpp:    else if ((o->objchar == WEAPON) ||
inv.cpp:             (o->objchar == MISSILEWEAPON)) {
inv.cpp:        if (twohandedp(o->id) &&
inv.cpp:                print1("This weapon is two-handed, so at the moment, ");
inv.cpp:           ((obj->blessing < 0) ?
inv.cpp:            (obj->used == true) + true :
inv.cpp:            if ((Player.possessions[i]->id == id) &&
inv.cpp:                    ((chargeval == -1) ||
inv.cpp:                     (Player.possessions[i]->charge == chargeval))) {
inv.cpp:                if ((Player.pack[i]->id == id) &&
inv.cpp:                        ((chargeval == -1) ||
inv.cpp:                         (Player.pack[i]->charge == chargeval))) {
inv.cpp:            if ((Player.possessions[i]->id == id) &&
inv.cpp:                    ((chargeval == -1) ||
inv.cpp:                     (Player.possessions[i]->charge == chargeval))) {
inv.cpp:                if ((Player.pack[i]->id == id) &&
inv.cpp:                        ((chargeval == -1) ||
inv.cpp:                         (Player.pack[i]->charge == chargeval))) {
inv.cpp:                    Player.pack[i]->number--;
inv.cpp:                    if (Player.pack[i]->number == 0) {
inv.cpp:            dispose_lost_objects(Player.possessions[i]->number,
inv.cpp:    extra->number = item->number-1;
inv.cpp:    extra->used = false;
inv.cpp:    item->number = 1;
inv.cpp:        print3("No room for extra copies of item -- dropping them.");
inv.cpp:/* show slots, with appropriate additional displays if two-handed weapons */
inv.cpp:                 twohandedp(Player.possessions[O_UP_IN_AIR]->id))
item.cpp:        if (r < 20) make_thing(newObject,-1);
item.cpp:        else if (r < 40) make_food(newObject,-1);
item.cpp:        else if (r < 50) make_scroll(newObject,-1);
item.cpp:        else if (r < 60) make_potion(newObject,-1);
item.cpp:        else if (r < 70) make_weapon(newObject,-1);
item.cpp:        else if (r < 80) make_armor(newObject,-1);
item.cpp:        else if (r < 90) make_shield(newObject,-1);
item.cpp:        else if (r < 100) make_stick(newObject,-1);
item.cpp:        else if (r < 110) make_boots(newObject,-1);
item.cpp:        else if (r < 120) make_cloak(newObject,-1);
item.cpp:        else if (r < 130) make_ring(newObject,-1);
item.cpp:        else make_artifact(newObject,-1);
item.cpp:        ok = ((newObject->uniqueness < UNIQUE_MADE) &&
item.cpp:              ((newObject->level < itemlevel+random_range(3))
item.cpp:    if (newObject->uniqueness == UNIQUE_UNMADE)
item.cpp:        Objects[newObject->id].uniqueness=UNIQUE_MADE;
item.cpp:    newObject->basevalue = random_range(level*level+10)+1; /* aux is AU value */
item.cpp:    newObject->objstr = cashstr();
item.cpp:    newObject->cursestr = newObject->truename = newObject->objstr;
item.cpp:    if (id == -1) id = random_range(NUMFOODS);
item.cpp:    newObject->charge = m->id;
item.cpp:    newObject->weight = m->corpseWeight;
item.cpp:    newObject->basevalue = m->corpseValue;
item.cpp:    newObject->known = 2;
item.cpp:    newObject->objstr = m->corpseString;
item.cpp:    newObject->truename = newObject->cursestr = newObject->objstr;
item.cpp:        free ( m->name );
item.cpp:        m->name = Monsters[m->id].name;
item.cpp:        m->corpseString = Monsters[m->id].corpseString;
item.cpp:        newObject->level |= ALLOC;
item.cpp:    /* WDT HACK, of course -- we need to implement I_CANNIBAL. */
item.cpp:    if ((m->symbol&0xff) == '@')
item.cpp:        newObject->usef = I_CANNIBAL;
item.cpp:            newObject->usef = I_FOOD;
item.cpp:            newObject->aux = 6;
item.cpp:            newObject->usef = I_POISON_FOOD;
item.cpp:    /* Special corpse-eating effects */
item.cpp:        else switch(m->id) {
item.cpp:                newObject->usef = I_SLEEP_SELF;
item.cpp:                newObject->usef = I_INVISIBLE;
item.cpp:                newObject->usef = I_TELEPORT;
item.cpp:            case EYE: /* floating eye -- it's traditional.... */
item.cpp:                newObject->usef = I_CLAIRVOYANCE;
item.cpp:                newObject->usef = I_DISPLACE;
item.cpp:                newObject->usef = I_CHAOS;
item.cpp:                newObject->usef = I_LAW;
item.cpp:                newObject->usef = I_ENCHANT;
item.cpp:                newObject->usef = I_SPELLS;
item.cpp:                newObject->usef = I_TRUESIGHT;
item.cpp:                newObject->usef = I_HEAL;
item.cpp:                newObject->usef = I_NEUTRALIZE_POISON;
item.cpp:                newObject->usef = I_ALERT;
item.cpp:                newObject->usef = I_INEDIBLE;
item.cpp:    if (id == -1) id = random_range(NUMRINGS);
item.cpp:    if (newObject->blessing == 0) newObject->blessing = itemblessing();
item.cpp:    if (newObject->plus == 0) newObject->plus = itemplus()+1;
item.cpp:    if (newObject->blessing < 0) newObject->plus = -1 - abs(newObject->plus);
item.cpp:    if (id == -1) id = random_range(NUMTHINGS);
item.cpp:    if (0 == strcmp(newObject->objstr, "grot"))
item.cpp:        newObject->objstr = grotname();
item.cpp:        newObject->truename = newObject->cursestr = newObject->objstr;
item.cpp:    else if (newObject->id >= CARDID && newObject->id < (CARDID + NUMCARDS))
item.cpp:        switch (newObject->id)
item.cpp:            newObject->aux = bank_random_account_number();
item.cpp:            newObject->charge = random_range(250) + random_range(250) + random_range(250);
item.cpp:            newObject->charge = random_range(50) + random_range(50) + random_range(50);
item.cpp:            newObject->aux = bank_random_account_number();
item.cpp:            newObject->charge = random_range(500) + random_range(500) + random_range(500);
item.cpp:    if (id == -1) id = random_range(NUMSCROLLS);
item.cpp:    if (newObject->id == OB_SPELLS_SCROLL) {
item.cpp:        newObject->aux = random_range(NUMSPELLS);
item.cpp:    if (id == -1) id = random_range(NUMPOTIONS);
item.cpp:    if (newObject->plus == 0) newObject->plus = itemplus();
item.cpp:    if (id == -1) id = random_range(NUMWEAPONS);
item.cpp:        newObject->number = random_range(20)+1;
item.cpp:    if (newObject->blessing == 0) newObject->blessing = itemblessing();
item.cpp:    if (newObject->plus == 0) {
item.cpp:        newObject->plus = itemplus();
item.cpp:        if (newObject->blessing < 0)
item.cpp:            newObject->plus = -1 - abs(newObject->plus);
item.cpp:        else if (newObject->blessing > 0)
item.cpp:            newObject->plus = 1 + abs(newObject->plus);
item.cpp:    if (id == -1) id = random_range(NUMSHIELDS);
item.cpp:    if (newObject->plus == 0)
item.cpp:        newObject->plus = itemplus();
item.cpp:    if (newObject->blessing == 0) newObject->blessing = itemblessing();
item.cpp:    if (newObject->blessing < 0)
item.cpp:        newObject->plus = -1 - abs(newObject->plus);
item.cpp:    else if (newObject->blessing > 0)
item.cpp:        newObject->plus = 1 + abs(newObject->plus);
item.cpp:    if (id == -1) id = random_range(NUMARMOR);
item.cpp:    if (newObject->plus == 0) newObject->plus = itemplus();
item.cpp:    if (newObject->blessing == 0) newObject->blessing = itemblessing();
item.cpp:    if (newObject->blessing < 0)
item.cpp:        newObject->plus = -1 - abs(newObject->plus);
item.cpp:    else if (newObject->blessing > 0)
item.cpp:        newObject->plus = 1 + abs(newObject->plus);
item.cpp:    if (id == -1) id = random_range(NUMCLOAKS);
item.cpp:    if (newObject->blessing == 0) newObject->blessing = itemblessing();
item.cpp:    if (id == -1) id = random_range(NUMBOOTS);
item.cpp:    if (newObject->blessing == 0) newObject->blessing = itemblessing();
item.cpp:    if (id == -1) id = random_range(NUMSTICKS);
item.cpp:    newObject->charge = itemcharge();
item.cpp:    if (newObject->blessing == 0) newObject->blessing = itemblessing();
item.cpp:    if (id == -1)
item.cpp:    if ( newObject->id == OB_HOLDING )
item.cpp:        newObject->blessing = itemblessing();
item.cpp:    for (top = number - 1; top >= 0; top--) {
item.cpp:        return "scroll-GRISTOGRUE";
item.cpp:        return "scroll-Kho Reck Tighp";
item.cpp:        return "scroll-E Z";
item.cpp:        return "scroll-Kevitz";
item.cpp:        return "scroll-Arcanum Prime";
item.cpp:        return "scroll-NYARLATHOTEP";
item.cpp:        return "scroll-Gilthoniel";
item.cpp:        return "scroll-Zarathustra";
item.cpp:        return "scroll-Ancient Lore";
item.cpp:        return "scroll-Eyes Only";
item.cpp:        return "scroll-Ambogar Empheltz";
item.cpp:        return "scroll-Isengard";
item.cpp:        return "scroll-Deosil Widdershins";
item.cpp:        return "scroll-Magister Paracelsus";
item.cpp:        return "scroll-Qlipphotic Summons";
item.cpp:        return "scroll-Aratron Samael";
item.cpp:        return "scroll-De Wormiis Mysterius";
item.cpp:        return "scroll-Necronomicon";
item.cpp:        return "scroll-Pnakotic Manuscript";
item.cpp:        return "scroll-Codex of Xalimar";
item.cpp:        return "scroll-The Mabinogion";
item.cpp:        return "scroll-Ginseng Shiatsu";
item.cpp:        return "scroll-Tome of Tromax";
item.cpp:        return "scroll-Book of the Dead ";
item.cpp:        return "scroll-The Flame Tongue";
item.cpp:        return "scroll-Karst Khogar";
item.cpp:        return "scroll-The Yellow Sign";
item.cpp:        return "scroll-The Kevillist Manifesto";
item.cpp:        return "scroll-Goshtar Script";
item.cpp:        return "scroll-Pendragon Encryption";
item.cpp:        return "broken yo-yo";
item.cpp:        return "three-dollar bill";
item.cpp:        return "rune-inscribed bone wand";
item.cpp:        return "gem-studded ebony staff";
item.cpp:        return "leather-handled stone rod";
item.cpp:        return "red half-cloak";
item.cpp:        return "mouse-hide cloak";
item.cpp:        return "cloth-of-gold cloak";
item.cpp:        return "grey-green rag";
item.cpp:        return "calf-length moccasins";
item.cpp:        return "dark-colored tabi";
item.cpp:        return "patent-leather shoes";
item.cpp:        return "beaten-up gumshoes";
item.cpp:        return "alligator-hide boots";
item.cpp:        return "mirror-plated wingtips";
item.cpp:        return "polyurethane-soled sneakers";
item.cpp:        return "hob-nailed boots";
item.cpp:        return(-1-random_range(10));
item.cpp:    switch(o->usef) {
item.cpp:    case -1:
item.cpp:        fprintf(DG_debug_log, "tried to use a %s with o->usef %d\n",
item.cpp:                itemid(o), o->usef);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    knowledge(o->blessing);
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    flux(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    enchant(o->blessing < 0 ? -1-o->plus : o->plus+1);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    if (o->blessing < 0)
itemf1.cpp:    else clairvoyance(5+o->blessing*5);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    blessing = o->blessing;
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    p_teleport(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    learnspell(o->blessing);
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    bless(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    wish(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    displace(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    deflection(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    identify(o->blessing);
itemf1.cpp:    if (o->blessing > -1) {
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:        heal(1+o->plus);
itemf1.cpp:    else heal(-1-abs(o->plus));
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    mondet(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    objdet(o->blessing);
itemf1.cpp:    if (o->blessing > -1) {
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    haste(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    recover_stat(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    augment(o->blessing);
itemf1.cpp:    if (o->plus < 0) {
itemf1.cpp:    else if (o->plus == 0) {
itemf1.cpp:    else if (o->blessing < 1) {
itemf1.cpp:    regenerate(o->blessing);
itemf1.cpp:    if (o->blessing > -1) {
itemf1.cpp:        if (o->used) {
itemf1.cpp:            o->known = 2;
itemf1.cpp:            Objects[o->id].known = 1;
itemf1.cpp:            Player.status[HASTED] -= 1500;
itemf1.cpp:        if (o->used) {
itemf1.cpp:            Player.status[SLOWED] -= 1500;
itemf1.cpp:    if (o->blessing > -1) {
itemf1.cpp:        if (o->used) {
itemf1.cpp:            Player.status[DISPLACED] -= 1500;
itemf1.cpp:        if (o->used) {
itemf1.cpp:            Player.status[VULNERABLE] -= 1500;
itemf1.cpp:    if (o->blessing > -1) {
itemf1.cpp:        if (o->used) {
itemf1.cpp:        else Player.immunity[NEGENERGY]--;
itemf1.cpp:    else if (o->used)
itemf1.cpp:        level_drain(abs(o->blessing),"cursed cloak of level drain");
itemf1.cpp:    Player.con -=1;
itemf1.cpp:    cure(o->blessing);
itemf1.cpp:    if (o->blessing > 0) {
itemf1.cpp:        cure(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    breathe(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    invisible(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    if (o->used) {
itemf1.cpp:        if (o->blessing > -1) {
itemf1.cpp:        if (o->blessing > -1) {
itemf1.cpp:            Player.status[INVISIBLE]-=1500;
itemf1.cpp:            Player.status[VULNERABLE] -= 1500;
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    warp(o->blessing);
itemf1.cpp:    if (o->blessing > -1) {
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:        alert(o->blessing);
itemf1.cpp:    if (o->blessing > -1)
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:        if (o->blessing < 0) {
itemf1.cpp:            Player.possessions[i]->charge = 0;
itemf1.cpp:            Player.possessions[i]->charge += (random_range(10)+1)*(o->blessing+1);
itemf1.cpp:            if (Player.possessions[i]->charge > 99)
itemf1.cpp:                Player.possessions[i]->charge = 99;
itemf1.cpp:    if (o->blessing > -1) {
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:    o->used = false;
itemf1.cpp:    if ((! o->known) && (! Player.rank[THIEVES]))
itemf1.cpp:        if (o->known < 1) o->known = 1;
itemf1.cpp:        Objects[o->id].known = 1;
itemf1.cpp:            if ((Level->site[ox][oy].locchar != CLOSED_DOOR) ||
itemf1.cpp:            else if (Level->site[ox][oy].aux == LOCKED) {
itemf1.cpp:                if (Level->depth == MaxDungeonLevels-1)
itemf1.cpp:                else if (Level->depth*2 + random_range(50) <
itemf1.cpp:                    Level->site[ox][oy].aux = UNLOCKED;
itemf1.cpp:                    gain_experience(max(3,Level->depth));
itemf1.cpp:    o->used = false;
itemf1.cpp:        if ((Level->site[ox][oy].locchar != CLOSED_DOOR) ||
itemf1.cpp:        else if (Level->site[ox][oy].aux == LOCKED) {
itemf1.cpp:            Level->site[ox][oy].aux = UNLOCKED;
itemf1.cpp:            o->blessing--;
itemf1.cpp:            if ((o->blessing<0)||(Level->depth == MaxDungeonLevels-1)) {
itemf1.cpp:     * kill the program -- well, okay, not the standard assert, but I seldom
itemf1.cpp:    switch (o->charge) {
itemf1.cpp:        Player.alignment -=10;
itemf1.cpp:        mprint("Those dragon-steaks were fantastic!");
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    accuracy(o->blessing);
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if ((o->used) && (o->blessing > -1)) {
itemf1.cpp:        Player.status[ACCURATE] -= 1500;
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    hero(o->blessing);
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if (o->used) {
itemf1.cpp:        if (o->blessing > -1) {
itemf1.cpp:        if (o->blessing > -1) {
itemf1.cpp:            Player.status[HERO] -= 1500;
itemf1.cpp:            Player.status[AFRAID] -= 1500;
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    levitate(o->blessing);
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if (o->blessing > -1) {
itemf1.cpp:        if (o->used) {
itemf1.cpp:            Player.status[LEVITATING] -= 1500;
itemf1.cpp:    if (o->used) {
itemf1.cpp:        if (o->blessing > -1)
itemf1.cpp:            Player.status[PROTECTION] += abs(o->plus)+1;
itemf1.cpp:            Player.status[PROTECTION] -= abs(o->plus)+1;
itemf1.cpp:        if (o->blessing > -1)
itemf1.cpp:            Player.status[PROTECTION] -= abs(o->plus)+1;
itemf1.cpp:            Player.status[PROTECTION] += abs(o->plus)+1;
itemf1.cpp:    if (o->known < 1) o->known = 2;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if (o->used) {
itemf1.cpp:        if (o->blessing > -1)
itemf1.cpp:            Player.agi += abs(o->plus)+1;
itemf1.cpp:            Player.agi -= abs(o->plus)+1;
itemf1.cpp:        if (o->blessing > -1)
itemf1.cpp:            Player.agi -= abs(o->plus)+1;
itemf1.cpp:            Player.agi += abs(o->plus)+1;
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    truesight(o->blessing);
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if (o->used) {
itemf1.cpp:        if (o->blessing > -1) {
itemf1.cpp:        if (o->blessing > -1) {
itemf1.cpp:            Player.status[TRUESIGHT] -= 1500;
itemf1.cpp:            Player.status[BLINDED] -= 1500;
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    illuminate(o->blessing);
itemf1.cpp:    if (o->known < 1) o->known = 1;
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if (o->used)
itemf1.cpp:        Player.status[ILLUMINATION]=max(0,Player.status[ILLUMINATION]-1500);
itemf1.cpp:    Objects[o->id].known = 1;
itemf1.cpp:    if ((Level->site[Player.x][Player.y].locchar != FLOOR) ||
itemf1.cpp:            (Level->site[Player.x][Player.y].p_locf != L_NO_OP))
itemf1.cpp:    else  if (! o->known) {
itemf1.cpp:        p_movefunction(o->aux);
itemf1.cpp:        Level->site[Player.x][Player.y].p_locf = o->aux;
itemf2.cpp:    if (o->known < 1)
itemf2.cpp:        o->known = 1;
itemf2.cpp:    if (o->blessing > -1)
itemf2.cpp:        Objects[o->id].known = 1;
itemf2.cpp:    /* DAG hack for mirror of self-knowledge
itemf2.cpp:      if (o->used)
itemf2.cpp:        knowledge(o->blessing);
itemf2.cpp:    knowledge(o->blessing);
itemf2.cpp:    if (o->known < 1) o->known = 1;
itemf2.cpp:    Objects[o->id].known = 1;
itemf2.cpp:    if (o->used) {
itemf2.cpp:        if (o->blessing > -1)
itemf2.cpp:            Player.str += abs(o->plus)+1;
itemf2.cpp:            Player.str -= abs(o->plus)+1;
itemf2.cpp:        if (o->blessing > -1)
itemf2.cpp:            Player.str -= abs(o->plus)+1;
itemf2.cpp:            Player.str += abs(o->plus)+1;
itemf2.cpp:    if (o->used) {
itemf2.cpp:        o->weight = 1000;
itemf2.cpp:        o->weight = 1;
itemf2.cpp:                (Player.possessions[i]->weight*Player.possessions[i]->number);
itemf2.cpp:    if (o->used) Player.immunity[GAZE]++;
itemf2.cpp:    else Player.immunity[GAZE]--;
itemf2.cpp:    if (o->used) Player.immunity[FLAME]++;
itemf2.cpp:    else Player.immunity[FLAME]--;
itemf2.cpp:    if (o->used) {
itemf2.cpp:        if (o->blessing < 0) {
itemf2.cpp:        Player.immunity[POISON]--;
itemf2.cpp:    if (o->known < 1)  o->known = 1;
itemf2.cpp:    if (o->blessing > -1)
itemf2.cpp:        Objects[o->id].known = 1;
itemf2.cpp:    if (o->used) {
itemf2.cpp:        Player.status[REGENERATING] -= 1500;
itemf2.cpp:    if (o->used) mprint("You put on your suit of armor.");
itemf2.cpp:    if (o->used) {
itemf2.cpp:        Player.immunity[FLAME]--;
itemf2.cpp:        Player.immunity[COLD]--;
itemf2.cpp:        Player.immunity[ELECTRICITY]--;
itemf2.cpp:    if (o->used) {
itemf2.cpp:        if (o->blessing < 0) {
itemf2.cpp:            mprint("You feel blood-simple!");
itemf2.cpp:        Player.immunity[FEAR]--;
itemf2.cpp:        if (o->blessing < 0) {
itemf2.cpp:            Player.status[BERSERK] -= 1500;
itemf2.cpp:    if (o->known < 1)  o->known = 1;
itemf2.cpp:    if (o->blessing > -1)
itemf2.cpp:        Objects[o->id].known = 1;
itemf2.cpp:    if (o->blessing > -1) {
itemf2.cpp:        if (o->used) {
itemf2.cpp:            Player.status[BREATHING] -= 1500;
itemf2.cpp:    else if (o->used) {
itemf2.cpp:    m->m_death();
itemf2.cpp:    if (o->blessing > -1) {
itemf2.cpp:    else if (m->specialf == M_SP_DEMON) {
itemf2.cpp:        m->m_vanish();
itemf2.cpp:    else if (m->meleef != M_MELEE_SPIRIT) {
itemf2.cpp:        if (m->level > random_range(10)) {
itemf2.cpp:                Player.hp = min(Player.maxhp,Player.hp+m->hp);
itemf2.cpp:                Player.pow = min(Player.maxpow,Player.pow+m->level);
itemf2.cpp:            m->m_death();
itemf2.cpp:            Player.str -= 3;
itemf2.cpp:            Player.con -= 3;
itemf2.cpp:    if (! o->known) {
itemf2.cpp:        o->known = 1;
itemf2.cpp:            m->m_damage(20,NORMAL_DAMAGE);
itemf2.cpp:        if ((m->hp>0) && (! m_immunityp(m,FLAME))) {
itemf2.cpp:            m->m_damage(20,FLAME);
itemf2.cpp:            (Player.possessions[O_WEAPON_HAND]->id == OB_LONGBOW)) /* ie, using a bow */
itemf2.cpp:        p_hit(m,Player.dmg+o->plus+o->dmg+dmgmod,NORMAL_DAMAGE);
itemf2.cpp:    else p_hit(m,o->plus+o->dmg+dmgmod,NORMAL_DAMAGE);
itemf2.cpp:            (Player.possessions[O_WEAPON_HAND]->id == OB_CROSSBOW) && /*ie using a crossbow */
itemf2.cpp:            (Player.possessions[O_WEAPON_HAND]->aux==LOADED)) {
itemf2.cpp:        p_hit(m,Player.dmg+o->plus+o->dmg+dmgmod,NORMAL_DAMAGE);
itemf2.cpp:        Player.possessions[O_WEAPON_HAND]->aux = UNLOADED;
itemf2.cpp:    else p_hit(m,o->plus+o->dmg,NORMAL_DAMAGE);
itemf2.cpp:    if (m->meleef == M_MELEE_SPIRIT) {
itemf2.cpp:        m->m_death();
itemf2.cpp:    if (o->used) {
itemf2.cpp:        o->known = 2;
itemf2.cpp:    if (o->used) mprint("You ready your weapon for battle.");
itemf2.cpp:    if (o->used) mprint("You feel one with the Force.");
itemf2.cpp:        o->known = 2;
itemf2.cpp:        else mprint("Your vorpal blade goes snicker-snack!");
itemf2.cpp:        m->m_death();
itemf2.cpp:    o->known = 2;
itemf2.cpp:        Player.alignment--;
itemf2.cpp:        Player.alignment-=10;
itemf2.cpp:        o->known = 2;
itemf2.cpp:    if (m->hp > 0) weapon_normal_hit(dmgmod,o,m);
itemf2.cpp:    if ((Player.alignment < 0) && (o->blessing > 0)) {
itemf2.cpp:        p_damage(50,UNSTOPPABLE,"a pissed-off Holy Defender");
itemf2.cpp:        o->truename = o->cursestr;
itemf2.cpp:        Player.status[PROTECTION] -= (o->hit);
itemf2.cpp:        o->plus = 0-abs(o->plus);
itemf2.cpp:        o->blessing = -1;
itemf2.cpp:    if ((o->blessing > 0) &&
itemf2.cpp:            ((m->specialf == M_SP_DEMON) ||
itemf2.cpp:             (m->meleef == M_MELEE_SPIRIT))) {
itemf2.cpp:        m->hit = 0;
itemf2.cpp:        m->speed *=2;
itemf2.cpp:    if (m->meleef == M_MELEE_SPIRIT) {
itemf2.cpp:        m->m_death();
itemf2.cpp:    o->known = 2;
itemf2.cpp:    if (o->used) {
itemf2.cpp:        Player.status[PROTECTION] += o->hit;
itemf2.cpp:    else Player.status[PROTECTION] -= o->hit;
itemf2.cpp:    o->known = 2;
itemf2.cpp:    o->blessing = abs(o->blessing);
itemf2.cpp:    if (o->used) {
itemf2.cpp:        Player.immunity[POISON]--;
itemf2.cpp:        Player.immunity[FEAR]--;
itemf2.cpp:        Player.immunity[INFECTION]--;
itemf2.cpp:    if (o->known < 1)  o->known = 2;
itemf2.cpp:    if (o->blessing > 0) {
itemf2.cpp:    else if (Level->site[Player.x][Player.y].locchar == ALTAR)
itemf2.cpp:        sanctify(-1);
itemf2.cpp:    if (o->used) mprint("You sling your shield across a forearm.");
itemf2.cpp:    if (o->known < 1)  o->known = 2;
itemf2.cpp:    if (o->blessing > -1) {
itemf2.cpp:        if (o->used) {
itemf2.cpp:            Player.status[DEFLECTION] -= 1500;
itemf2.cpp:        if (o->used) {
itemf2.cpp:            Player.status[VULNERABLE] -= 1500;
itemf3.cpp:        Player.mana = max(0,Player.mana-100);
itemf3.cpp:        Player.mana = max(0,Player.mana-10);
itemf3.cpp:        Player.maxhp -= 1;
itemf3.cpp:        Objects[o->id].uniqueness = UNIQUE_UNMADE;
itemf3.cpp:        if (o->blessing < 1) {
itemf3.cpp:            o->blessing = 10;
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    if (! o->known) {
itemf3.cpp:                if (Level->site[x][y].locchar == WALL)
itemf3.cpp:                if (Level->site[x][y].locchar != WATER &&
itemf3.cpp:                        Level->site[x][y].locchar != VOID_CHAR &&
itemf3.cpp:                        Level->site[x][y].locchar != ABYSS &&
itemf3.cpp:                        Level->site[x][y].locchar != SPACE &&
itemf3.cpp:                        Level->site[x][y].locchar != LAVA)
itemf3.cpp:                    Level->site[x][y].locchar = FLOOR;
itemf3.cpp:                    Level->site[x][y].p_locf = L_NO_OP;
itemf3.cpp:                if (Level->site[x][y].creature != NULL) {
itemf3.cpp:                    Level->site[x][y].creature->m_death();
itemf3.cpp:            Level->tunnelled += tunneled - 1;
itemf3.cpp:    if (! o->known)
itemf3.cpp:    /* if o->charge != 17, then symbol was stolen from own high priest! */
itemf3.cpp:    else if ((o->aux != Player.patron) || (o->charge != 17)) {
itemf3.cpp:        for(; Player.hp>1; Player.hp--)
itemf3.cpp:                dispose_lost_objects(Player.possessions[i]->number,
itemf3.cpp:    if (!o->known) print1("You can't figure out how to activate this orb.");
itemf3.cpp:        else if ((o->blessing<0) || (Player.iq+Player.level < random_range(30))) {
itemf3.cpp:    if (!o->known) {
itemf3.cpp:        print1("Ka-Boom!");
itemf3.cpp:        p_death("the Holy Hand-Grenade of Antioch");
itemf3.cpp:        print1("Bring out the Holy Hand-Grenade of Antioch!");
itemf3.cpp:        if ((count < 3)&&(Level->site[x][y].creature!=NULL)) {
itemf3.cpp:            print1("Ka-Boom!");
itemf3.cpp:            p_death("the Holy Hand-Grenade of Antioch");
itemf3.cpp:            print1("Ka-Boom!");
itemf3.cpp:            p_death("the Holy Hand-Grenade of Antioch");
itemf3.cpp:            print1("Ka-Boom!");
itemf3.cpp:            Level->site[x][y].locchar = TRAP;
itemf3.cpp:            Level->site[x][y].p_locf = L_TRAP_DOOR;
itemf3.cpp:            if (Level->site[x][y].creature != NULL) {
itemf3.cpp:                Level->site[x][y].creature->m_death();
itemf3.cpp:            Level->site[x][y].things = NULL;
itemf3.cpp:    if (! o->known) {
itemf3.cpp:    else if (! o->known) {
itemf3.cpp:        dispel(-1);
itemf3.cpp:        if (response == 'w') enchant(o->blessing*2+1);
itemf3.cpp:        else dispel(o->blessing);
itemf3.cpp:    else if (! o->known) {
itemf3.cpp:        p_teleport(-1);
itemf3.cpp:        p_teleport(o->blessing);
itemf3.cpp:        o->known = 1;
itemf3.cpp:        o->plus = 100;
itemf3.cpp:        o->blessing = 100;
itemf3.cpp:        heal(-250);
itemf3.cpp:        o->known = 1;
itemf3.cpp:        o->plus = 100;
itemf3.cpp:        o->blessing = 100;
itemf3.cpp:        Player.con -= 10;
itemf3.cpp:                    dispose_lost_objects(Player.possessions[i]->number,
itemf3.cpp:            o->known = 1;
itemf3.cpp:        o->plus = 100;
itemf3.cpp:        o->blessing = 100;
itemf3.cpp:        o->known = 1;
itemf3.cpp:        o->plus = 100;
itemf3.cpp:        o->blessing = 100;
itemf3.cpp:        o->known = 1;
itemf3.cpp:    else if ((find_and_remove_item(OB_ORB_FIRE,-1)) &&
itemf3.cpp:             (find_and_remove_item(OB_ORB_WATER,-1)) &&
itemf3.cpp:             (find_and_remove_item(OB_ORB_EARTH,-1)) &&
itemf3.cpp:             (find_and_remove_item(OB_ORB_AIR,-1))) {
itemf3.cpp:    print1("The burnt-out orb drains all your energy!");
itemf3.cpp:            Player.possessions[i]->plus = 0;
itemf3.cpp:            if (Player.possessions[i]->usef > 100)
itemf3.cpp:                Player.possessions[i]->usef = I_NOTHING;
itemf3.cpp:    level_drain(Player.level-1,"a Burnt-out Orb");
itemf3.cpp:    Player.pow -= 10;
itemf3.cpp:    dispel((o->blessing > -1) ? o->blessing+random_range(3): o->blessing);
itemf3.cpp:    if (! o->known )
itemf3.cpp:        o->known = 1;
itemf3.cpp:        Objects[o->id].known = 1;
itemf3.cpp:    if ( ! o->aux )
itemf3.cpp:        sprintf(Str1, "You bag of holding currently holds %d items.\n", o->aux );
itemf3.cpp:        if (!o->aux)
itemf3.cpp:                menuprint(itemid(ol->thing));
itemf3.cpp:                ol = ol->next;
itemf3.cpp:        if (o->aux >= 5)
itemf3.cpp:                if ( ob->used && (ob->blessing < 0) )
itemf3.cpp:                    mprint("You hear a high-pitched screaming sound.");
itemf3.cpp:                    mprint("Suddenly the space-time continuum rips...");
itemf3.cpp:                    /* Bag is not destroyed, could re-appear anywhere */
itemf3.cpp:                    Objects[o->id].uniqueness = UNIQUE_UNMADE;
itemf3.cpp:                    strategic_teleport(-1);
itemf3.cpp:                    ol->thing = ob;
itemf3.cpp:                    ol->next = Bagitems;
itemf3.cpp:                    o->aux++;
itemf3.cpp:        if (!o->aux)
itemf3.cpp:            if (o->blessing < 0)
itemf3.cpp:                o->known = 2;
itemf3.cpp:                o->aux = 0;
itemf3.cpp:                    sprintf(Str1, "%c: %s\n", c1, itemid(ol->thing) );
itemf3.cpp:                    ol = ol->next;
itemf3.cpp:                        ol = ol->next;
itemf3.cpp:                    gain_item( ol->thing );
itemf3.cpp:                    o->aux--;
itemf3.cpp:                        ol=ol->next;
itemf3.cpp:                        ol = ol->next;
itemf3.cpp:                        free( prev->next );
itemf3.cpp:                        prev->next = ol;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    apport(o->blessing);
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    if (o->blessing < 0) {
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    sleep_monster(o->blessing);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    summon(-1,-1);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    Objects[o->id].known = 1;
itemf3.cpp:    o->known = max(1,o->known);
itemf3.cpp:    polymorph(o->blessing);
lev.cpp:        tml->monster = ((Monster*) checkmalloc(sizeof(Monster)));
lev.cpp:        if (monsters == NULL) tml->monster =
lev.cpp:                m_create(random_range(Level->level_width),random_range(Level->level_length),true,difficulty());
lev.cpp:            tml->monster = make_creature(*(monsters+random_range(10)));
lev.cpp:            tml->monster->x = random_range(Level->level_width);
lev.cpp:            tml->monster->y = random_range(Level->level_length);
lev.cpp:        Level->site[tml->monster->x][tml->monster->y].creature = tml->monster;
lev.cpp:        tml->monster->sense = Level->level_width;
lev.cpp:        if (m_statusp(tml->monster,ONLYSWIM)) {
lev.cpp:            Level->site[tml->monster->x][tml->monster->y].locchar = WATER;
lev.cpp:            Level->site[tml->monster->x][tml->monster->y].p_locf = L_WATER;
lev.cpp:            lset(tml->monster->x, tml->monster->y, CHANGED);
lev.cpp:        tml->next = ml;
lev.cpp:    Level->mlist = ml;
lev.cpp:        findspace(&i,&j,-1);
lev.cpp:            if (Level->depth*10+random_range(100) > 150)
lev.cpp:            else if (Level->depth*10+random_range(100) > 100)
lev.cpp:            if (! random_range(3)) monsterid = -1;
lev.cpp:            else switch(random_range(Level->depth+3)) {
lev.cpp:            else if (random_range(2) && (Level->depth == 1)) /* plane of earth */
lev.cpp:            else if (random_range(2) && (Level->depth == 2)) /* plane of air */
lev.cpp:            else if (random_range(2) && (Level->depth == 3)) /* plane of water */
lev.cpp:            else if (random_range(2) && (Level->depth == 4)) /* plane of fire */
lev.cpp:            else if (random_range(2) && (Level->depth == 5)) /* deep astral */
lev.cpp:                do monsterid = random_range(ML10-ML4)+ML4;
lev.cpp:            else switch(random_range(Level->depth/2+2)) { /* evil & fire creatures */
lev.cpp:            Level->site[i][j].creature = make_creature(monsterid);
lev.cpp:            Level->site[i][j].creature = m_create(i,j,true,difficulty());
lev.cpp:        Level->site[i][j].creature->x = i;
lev.cpp:        Level->site[i][j].creature->y = j;
lev.cpp:        if (m_statusp(Level->site[i][j].creature,ONLYSWIM)) {
lev.cpp:            Level->site[i][j].locchar = WATER;
lev.cpp:            Level->site[i][j].p_locf = L_WATER;
lev.cpp:        tml->next = ((MonsterList*) checkmalloc(sizeof(MonsterList)));
lev.cpp:        tml->next->monster = Level->site[i][j].creature;
lev.cpp:        tml = tml->next;
lev.cpp:    if (Level->mlist==NULL) {
lev.cpp:        tml->next = NULL;
lev.cpp:        Level->mlist = head->next;
lev.cpp:        tml->next = Level->mlist;
lev.cpp:        Level->mlist = head->next;
lev.cpp:        findspace(&x,&y,-1);
lev.cpp:        tml->next = Level->mlist;
lev.cpp:        tml->monster = Level->site[x][y].creature = m_create(x,y,WANDERING,difficulty());
lev.cpp:        Level->mlist = tml;
lev.cpp:/* call make_creature and place created monster on Level->mlist and Level */
lev.cpp:    if (mid > -1)  Level->site[i][j].creature = (m = make_creature(mid));
lev.cpp:    else Level->site[i][j].creature = (m = m_create(i,j,WANDERING,difficulty()));
lev.cpp:    m->x = i;
lev.cpp:    m->y = j;
lev.cpp:    ml->monster = m;
lev.cpp:    ml->next = Level->mlist;
lev.cpp:    Level->mlist = ml;
lev.cpp:    newmonster->x = x;
lev.cpp:    newmonster->y = y;
lev.cpp:/* make creature # mid, totally random if mid == -1 */
lev.cpp:    if (mid == -1) mid = random_range(ML9);
lev.cpp:            newmonster->aux1 = Country[LastCountryLocX][LastCountryLocY].aux;
lev.cpp:            newmonster->aux1 = random_range(6)+1;
lev.cpp:        newmonster->name = angeltype( mid, newmonster->aux1 );
lev.cpp:        /* generic 0th level human, or a were-human */
lev.cpp:        newmonster->corpseString = mancorpse();
lev.cpp:        newmonster->name = (newmonster->corpseString)+5;
lev.cpp:    else if ((newmonster->symbol&0xff) == '!') {
lev.cpp:            newmonster->symbol = 'n'|CLR(RED);
lev.cpp:            newmonster->name = "nymph";
lev.cpp:            newmonster->corpseString = "dead nymph";
lev.cpp:            newmonster->symbol = 's'|CLR(RED);
lev.cpp:            newmonster->name = "satyr";
lev.cpp:            newmonster->corpseString = "dead satyr";
lev.cpp:        if (newmonster->id == INCUBUS) {
lev.cpp:            if ((newmonster->symbol&0xff) == 'n')
lev.cpp:                newmonster->corpseString = "dead succubus";
lev.cpp:            else newmonster->corpseString = "dead incubus";
lev.cpp:        if (newmonster->sleep < random_range(100))
lev.cpp:        if (newmonster->startThing > -1 &&
lev.cpp:                Objects[newmonster->startThing].uniqueness <= UNIQUE_MADE) {
lev.cpp:            *ob = Objects[newmonster->startThing];
lev.cpp:            newmonster->m_pickup(ob);
lev.cpp:        /* DAG -- monster with treasure of 1 would be same as 0, shouldn't be. */
lev.cpp:        treasures = random_range(newmonster->treasure +1);
lev.cpp:                ob = (Object*) (create_object(newmonster->level));
lev.cpp:                if (ob->uniqueness != COMMON) {
lev.cpp:                    Objects[ob->id].uniqueness = UNIQUE_UNMADE;
lev.cpp:            newmonster->m_pickup(ob);
lev.cpp:    newmonster->click = (Tick + 1) % 50;
lev.cpp:            i = random_range(Level->level_width);
lev.cpp:            j = random_range(Level->level_length);
lev.cpp:        } while (Level->site[i][j].locchar != FLOOR);
lev.cpp:        i = random_range(Level->level_width);
lev.cpp:        j = random_range(Level->level_length);
lev.cpp:        Level->site[i][j].things = ((pol) checkmalloc(sizeof(oltype)));
lev.cpp:        Level->site[i][j].things->thing = ((Object*) checkmalloc(sizeof(Object)));
lev.cpp:        make_cash(Level->site[i][j].things->thing,difficulty());
lev.cpp:        Level->site[i][j].things->next = NULL;
lev.cpp:            i = random_range(Level->level_width);
lev.cpp:            j = random_range(Level->level_length);
lev.cpp:            Level->site[i][j].things = ((pol) checkmalloc(sizeof(oltype)));
lev.cpp:            Level->site[i][j].things->thing = ((Object*) checkmalloc(sizeof(Object)));
lev.cpp:            make_cash(Level->site[i][j].things->thing,difficulty());
lev.cpp:            Level->site[i][j].things->next = NULL;
lev.cpp:            i = random_range(Level->level_width);
lev.cpp:            j = random_range(Level->level_length);
lev.cpp:            Level->site[i][j].things = ((pol) checkmalloc(sizeof(oltype)));
lev.cpp:            Level->site[i][j].things->thing = ((Object*) checkmalloc(sizeof(Object)));
lev.cpp:            make_cash(Level->site[i][j].things->thing,difficulty());
lev.cpp:            Level->site[i][j].things->next = NULL;
lev.cpp:    tmp->thing = ((Object*) create_object(itemlevel));
lev.cpp:    tmp->next = Level->site[i][j].things;
lev.cpp:    Level->site[i][j].things = tmp;
lev.cpp:    tmp->thing = ((Object*) checkmalloc(sizeof(Object)));
lev.cpp:    *(tmp->thing) = Objects[itemid];
lev.cpp:    tmp->next = Level->site[i][j].things;
lev.cpp:    Level->site[i][j].things = tmp;
lev.cpp:    if (Level != NULL) depth = Level->depth;
Main.cpp:    mprint("Sorry, caught a core-dump signal.");
Main.cpp:    print1("Signal - Saving file 'Omega.Sav'.");
Main.cpp:// Always catch ^c and hang-up signals
Main.cpp:    while((i = getopt(argc, argv, "dshq")) != -1)
Main.cpp:            game->ScoresOnly(true);
Main.cpp:            game->ShowTitle(false);
Main.cpp:            game->ShowTitle(false);
Main.cpp:            game->ShowScores(false);
Main.cpp:        game->SaveFilename(argv[optind]);
Main.cpp:        game->Continuing(true);
Main.cpp:    // Alternate code for people who don't support getopt() - no enhancement
Main.cpp:        game->SaveFilename(argv[1]);
Main.cpp:        game->Continuing(true);
Main.cpp:        game->startGame();
map.cpp:    struct symbolMapping symbols[128-32]; /* Only printable characters.
map.cpp:    return m->width;
map.cpp:    return m->length;
map.cpp:    return m->depth;
map.cpp:    if ( subLevel > m->depth || subLevel < 0 )
map.cpp:              m->depth, subLevel);
map.cpp:    fseek(in,m->offset,SEEK_SET);
map.cpp:    } while ( subLevel-- );
map.cpp:    m->sites = (char*) malloc(size);
map.cpp:    fread(m->sites,size,1,in);
map.cpp:    decode(&m->sites,&size);
map.cpp:    if ( size != m->length*m->width )
map.cpp:              m->length*m->width, size);
map.cpp:        m->width = fgetc(in);
map.cpp:        m->length = fgetc(in);
map.cpp:        m->depth = fgetc(in);
map.cpp:        m->offset = fgetint(in);
map.cpp:    m->offset += MAP_HEADER_SIZE + maps*MAP_ITEM_SIZE;
map.cpp:    free(m->sites);
map.cpp:    assert(i < m->width);
map.cpp:    assert(j < m->length);
map.cpp:    assert(m->sites[j*m->width + i]);
map.cpp:    return m->sites[j*m->width + i];
mon.cpp:        return "dead neer-do-well";
mon.cpp:    /* And, if none of those work, this function's broken -- I'm gonna die. */
mon.cpp:    int st = -1;
mon.cpp:    npc->aux2 = npcid;
mon.cpp:        npc->determine_npc_behavior(Hilevel,Hibehavior);
mon.cpp:        npc->determine_npc_behavior(Priestlevel[npcid],Priestbehavior[npcid]);
mon.cpp:            npc->talkf = M_TALK_DRUID;
mon.cpp:        npc->determine_npc_behavior(Shadowlordlevel,Shadowlordbehavior);
mon.cpp:        npc->determine_npc_behavior(Commandantlevel,Commandantbehavior);
mon.cpp:        npc->determine_npc_behavior(Archmagelevel,Archmagebehavior);
mon.cpp:        npc->talkf = M_TALK_ARCHMAGE;
mon.cpp:        npc->determine_npc_behavior(Primelevel,Primebehavior);
mon.cpp:        npc->talkf = M_TALK_PRIME;
mon.cpp:        npc->specialf = M_SP_PRIME;
mon.cpp:        npc->determine_npc_behavior(Championlevel,Championbehavior);
mon.cpp:        npc->determine_npc_behavior(Dukelevel,Dukebehavior);
mon.cpp:        npc->determine_npc_behavior(Chaoslordlevel,Chaoslordbehavior);
mon.cpp:        npc->determine_npc_behavior(Lawlordlevel,Lawlordbehavior);
mon.cpp:        npc->determine_npc_behavior(Justiciarlevel,Justiciarbehavior);
mon.cpp:        npc->talkf = M_TALK_GUARD;
mon.cpp:        npc->specialf = M_SP_WHISTLEBLOWER;
mon.cpp:        npc->determine_npc_behavior(Grandmasterlevel,Grandmasterbehavior);
mon.cpp:    if (st > -1 && Objects[st].uniqueness == UNIQUE_MADE) {
mon.cpp:        npc->m_pickup(ob);
mon.cpp:    npc->name = salloc(Str2);
mon.cpp:    npc->corpseString = salloc(Str1);
mon.cpp:        if (random_range(n) == 0) {	/* this algo. from Knuth 2 - cute, eh? */
mon.cpp:            Str2[strlen(Str2) - 1] = '\0';	/* 'cos fgets reads in the \n */
mon.cpp:    npc->hp = level*20;
mon.cpp:        npc->name = salloc(Str1);
mon.cpp:        npc->corpseString = salloc(Str3);
mon.cpp:        npc->name=salloc(Str2);
mon.cpp:        npc->corpseString = salloc(Str3);
mon.cpp:    npc->determine_npc_behavior(level,behavior);
Monster.cpp:    int dx = sign(Player.x - this->x);
Monster.cpp:    int dy = sign(Player.y - this->y);
Monster.cpp:    if (this->hp < Monsters[this->id].hp/4) {
Monster.cpp:        dx = - dx;
Monster.cpp:        dy = - dy;
Monster.cpp:        this->movef = M_MOVE_SCAREDY;
Monster.cpp:        if (this->uniqueness == COMMON) {
Monster.cpp:            strcat(Str2,this->name);
Monster.cpp:        else strcpy(Str2,this->name);
Monster.cpp:        if (this->possessions != NULL) {
Monster.cpp:            this->m_dropstuff();
Monster.cpp:        this->speed = min(2,this->speed-1);
Monster.cpp:        if (m_unblocked(this,this->x+dx,this->y+dy))
Monster.cpp:            this->movemonster(this->x+dx,this->y+dy);
Monster.cpp:            if (m_unblocked(this,this->x+1,this->y+dy))
Monster.cpp:                this->movemonster(this->x+1,this->y+dy);
Monster.cpp:            else if (m_unblocked(this,this->x-1,this->y+dy))
Monster.cpp:                this->movemonster(this->x-1,this->y+dy);
Monster.cpp:            if (m_unblocked(this,this->x+dx,this->y+1))
Monster.cpp:                this->movemonster(this->x+dx,this->y+1);
Monster.cpp:            else if (m_unblocked(this,this->x+dx,this->y-1))
Monster.cpp:                this->movemonster(this->x+dx,this->y-1);
Monster.cpp:            if (m_unblocked(this,this->x+dx,this->y))
Monster.cpp:                this->movemonster(this->x+dx,this->y);
Monster.cpp:            else if (m_unblocked(this,this->x,this->y+dy))
Monster.cpp:                this->movemonster(this->x,this->y+dy);
Monster.cpp:    int dx = -sign(Player.x - this->x);
Monster.cpp:    int dy = -sign(Player.y - this->y);
Monster.cpp:        if (m_unblocked(this,this->x+dx,this->y+dy))
Monster.cpp:            this->movemonster(this->x+dx,this->y+dy);
Monster.cpp:            if (m_unblocked(this,this->x+1,this->y+dy))
Monster.cpp:                this->movemonster(this->x+1,this->y+dy);
Monster.cpp:            else if (m_unblocked(this,this->x-1,this->y+dy))
Monster.cpp:                this->movemonster(this->x-1,this->y+dy);
Monster.cpp:            if (m_unblocked(this,this->x+dx,this->y+1))
Monster.cpp:                this->movemonster(this->x+dx,this->y+1);
Monster.cpp:            else if (m_unblocked(this,this->x+dx,this->y-1))
Monster.cpp:                this->movemonster(this->x+dx,this->y-1);
Monster.cpp:            if (m_unblocked(this,this->x+dx,this->y))
Monster.cpp:                this->movemonster(this->x+dx,this->y);
Monster.cpp:            else if (m_unblocked(this,this->x,this->y+dy))
Monster.cpp:                this->movemonster(this->x,this->y+dy);
Monster.cpp:    int dx = sign(Player.x - this->x);
Monster.cpp:    int dy = sign(Player.y - this->y);
Monster.cpp:    if (this->hp < Monsters[this->id].hp/6) {
Monster.cpp:        dx = -dx;
Monster.cpp:        dy = -dy;
Monster.cpp:    if (Player.status[INVISIBLE] > 0 || !m_unblocked(this, this->x+dx, this->y+dy))
Monster.cpp:        this->movemonster(this->x+dx,this->y+dy);
Monster.cpp:    int trange,range = distance(this->x,this->y,Player.x,Player.y);
Monster.cpp:    int i,tx,ty,nx=this->x,ny=this->y;
Monster.cpp:            tx = this->x+Dirs[0][i];
Monster.cpp:            ty = this->y+Dirs[1][i];
Monster.cpp:            if (this->hp < Monsters[this->id].hp/6) {
Monster.cpp:        this->movemonster(nx,ny);
Monster.cpp:        nx = this->x+random_range(3)-1;
Monster.cpp:        ny = this->y+random_range(3)-1;
Monster.cpp:            this->movemonster(nx,ny);
Monster.cpp:        nx = this->x+random_range(3)-1;
Monster.cpp:        ny = this->y+random_range(3)-1;
Monster.cpp:            this->movemonster(nx,ny);
Monster.cpp:    if (this->uniqueness == COMMON) {
Monster.cpp:        strcat(Str2,this->name);
Monster.cpp:    else strcpy(Str2,this->name);
Monster.cpp:    this->m_remove();/* signals "death" -- no credit to player, though */
Monster.cpp:        Level->site[this->x][this->y].creature = NULL;
Monster.cpp:        putspot(this->x,this->y,getspot(this->x,this->y,false));
Monster.cpp:        findspace(&(this->x),&(this->y),-1);
Monster.cpp:        Level->site[this->x][this->y].creature = this;
Monster.cpp:    if (this->aux1 == 0) {
Monster.cpp:        this->aux1 = this->x;
Monster.cpp:        this->aux2 = this->y;
Monster.cpp:    else if (distance(this->x,this->y,this->aux1,this->aux2) > 5) {
Monster.cpp:        if (Level->site[this->aux1][this->aux2].creature != NULL) {
Monster.cpp:            if (los_p(Player.x,Player.y,this->aux1,this->aux2)) {
Monster.cpp:                if (Level->site[this->aux1][this->aux2].creature->uniqueness == COMMON) {
Monster.cpp:                    strcat(Str1, Level->site[this->aux1][this->aux2].creature->name);
Monster.cpp:                    strcpy(Str1, Level->site[this->aux1][this->aux2].creature->name);
Monster.cpp:            this->movef = M_MOVE_NORMAL;
Monster.cpp:        else if (los_p(Player.x,Player.y,this->x,this->y)) {
Monster.cpp:            plotspot(this->x, this->y, false);
Monster.cpp:        Level->site[this->x][this->y].creature = NULL;
Monster.cpp:        this->x = this->aux1;
Monster.cpp:        this->y = this->aux2;
Monster.cpp:        Level->site[this->x][this->y].creature = this;
Monster.cpp:    int range = distance(this->x, this->y, Player.x,Player.y);
Monster.cpp:        if (this->hp < Monsters[this->id].hp)
Monster.cpp:            this->hp++;
Monster.cpp:    if ((! m_statusp(this,AWAKE)) && (range <= this->wakeup)) {
Monster.cpp:            if (range <= this->sense && (m_statusp(this, HOSTILE) ||
Monster.cpp:                if ((range > 2) && (range < this->sense) && (random_range(2) == 1))
Monster.cpp:                    if (los_p(this->x,this->y,Player.x,Player.y) &&
Monster.cpp:        if (m_statusp(this,GREEDY) && (this->hp >0) )
Monster.cpp:            while (Level->site[this->x][this->y].things != NULL) {
Monster.cpp:                m_pickup(Level->site[this->x][this->y].things->thing);
Monster.cpp:                prev = Level->site[this->x][this->y].things;
Monster.cpp:                Level->site[this->x][this->y].things =
Monster.cpp:                    Level->site[this->x][this->y].things->next;
Monster.cpp:        if ((range < max(5,this->level)) && (this->hp > 0) &&
Monster.cpp:    if (Level->site[newx][newy].creature != NULL)
Monster.cpp:    if (Level->site[this->x][this->y].creature == this)
Monster.cpp:        Level->site[this->x][this->y].creature = NULL;
Monster.cpp:    this->x = newx;
Monster.cpp:    this->y = newy;
Monster.cpp:    Level->site[this->x][this->y].creature = this;
Monster.cpp:    m_movefunction(Level->site[this->x][this->y].p_locf);
Monster.cpp:    tmp->thing = o;
Monster.cpp:    tmp->next = this->possessions;
Monster.cpp:    this->possessions = tmp;
Monster.cpp:    pol tmp = this->possessions;
Monster.cpp:        while (tmp->next != NULL)
Monster.cpp:            tmp = tmp->next;
Monster.cpp:        tmp->next = Level->site[this->x][this->y].things;
Monster.cpp:        Level->site[this->x][this->y].things = this->possessions;
Monster.cpp:        this->possessions = NULL;
Monster.cpp:        if (los_p(Player.x,Player.y,this->x,this->y)) {
Monster.cpp:            if (this->uniqueness != COMMON) strcpy(Str1,this->name);
Monster.cpp:                strcat(Str1,this->name);
Monster.cpp:    else if ((this->hp -= dmg) < 1) m_death();
Monster.cpp:/* remove a monster -- death without crediting player */
Monster.cpp:    Level->site[this->x][this->y].creature = NULL;
Monster.cpp:    this->hp = -1; /* signals "death" -- no credit to player, though */
Monster.cpp:    /* DAG -- monster structure will be "cleaned up" in time_clock() which */
Monster.cpp:    this->hp = -1;
Monster.cpp:    if (los_p(Player.x,Player.y,this->x,this->y)) {
Monster.cpp:        gain_experience(this->xpv);
Monster.cpp:        if (this->uniqueness != COMMON) strcpy(Str1,this->name);
Monster.cpp:            strcat(Str1,this->name);
Monster.cpp:    this->m_dropstuff();
Monster.cpp:    if (this->id == DEATH) { /* Death */
Monster.cpp:        Level->site[this->x][this->y].creature = NULL;
Monster.cpp:        if (random_range(2) || (this->uniqueness != COMMON)) {
Monster.cpp:            drop_at(this->x,this->y,corpse);
Monster.cpp:        plotspot(this->x,this->y,false);
Monster.cpp:        switch(this->id) {
Monster.cpp:            switch(this->aux2) {
Monster.cpp:                strcpy(Priest[this->aux2],nameprint());
Monster.cpp:                Priestbehavior[this->aux2] = 2933;
Monster.cpp:                mprint("An aide-de-camp approaches, removes the corpse's insignia,");
Monster.cpp:                Player.alignment -= 100;
Monster.cpp:                    curr = Level->site[this->x][this->y].things;
Monster.cpp:                    while (curr && curr->thing->id != OB_JUSTICIAR_BADGE) {
Monster.cpp:                        curr = curr->next;
Monster.cpp:                    ml = City->mlist;
Monster.cpp:                        found = ((ml->monster->id == GUARD) && (ml->monster->hp > 0));
Monster.cpp:                        if (! found) ml=ml->next;
Monster.cpp:                            ml->monster->m_pickup(curr->thing);
Monster.cpp:                                prev->next = curr->next;
Monster.cpp:                                Level->site[this->x][this->y].things = curr->next;
Monster.cpp:                        x = ml->monster->x;
Monster.cpp:                        y = ml->monster->y;
Monster.cpp:                        ml->monster->x = x;
Monster.cpp:                        ml->monster->y = y;
Monster.cpp:                        ml->monster->click = (Tick + 1) % 60;
Monster.cpp:                        m_status_reset(ml->monster,AWAKE);
Monster.cpp:                        m_status_reset(ml->monster,HOSTILE);
Monster.cpp:            save_hiscore_npc(this->aux2);
Monster.cpp:            Player.alignment -= 10;
Monster.cpp:        switch (this->specialf) {
Monster.cpp:            monster_action(this->specialf);
Monster.cpp:        if (this->wasAttackedByPlayer == false) Player.alignment++;
Monster.cpp:        this->wasAttackedByPlayer = true;
Monster.cpp:        monster_action(this->strikef);
Monster.cpp:        monster_action(this->specialf);
Monster.cpp:    monster_action(this->talkf);
Monster.cpp:        if (distance(this->x,this->y,Player.x,Player.y)<2) {
Monster.cpp:            meleef = this->meleef;
Monster.cpp:            this->meleef = action;
Monster.cpp:            this->meleef = meleef;
Monster.cpp:        Level->site[x][y].locchar = TRAP;
Monster.cpp:        Level->site[x][y].locchar = TRAP;
Monster.cpp:        Level->site[x][y].locchar = TRAP;
Monster.cpp:        Level->site[x][y].locchar = ABYSS;
Monster.cpp:        Level->site[x][y].p_locf = L_ABYSS;
Monster.cpp:    Level->site[x][y].locchar = TRAP;
Monster.cpp:    Level->site[x][y].locchar = TRAP;
Monster.cpp:    m_damage((difficulty()+1)*7-Player.defense,NORMAL_DAMAGE);
Monster.cpp:    Level->site[x][y].locchar = TRAP;
Monster.cpp:    Level->site[x][y].locchar = TRAP;
Monster.cpp:        Level->site[x][y].locchar = TRAP;
Monster.cpp:        Level->site[x][y].locchar = TRAP;
Monster.cpp:        Level->site[x][y].locchar = TRAP;
Monster.cpp:        Level->site[x][y].locchar = TRAP;
Monster.cpp:    int altar = Level->site[x][y].aux;
Monster.cpp:        reaction = -1;	/* friendly deity will zap hostile monster */
Monster.cpp:    case -1:
Monster.cpp:    speed = max(speed-1,1);
Monster.cpp:    ol->thing = scythe;
Monster.cpp:    ol->next = NULL;
Monster.cpp:    else if (this->uniqueness == COMMON) {
Monster.cpp:        if (this->hp < Monsters[this->id].hp / 3)
Monster.cpp:        else if (this->hp < Monsters[this->id].hp / 2)
Monster.cpp:        else if (this->hp < Monsters[this->id].hp)
Monster.cpp:        else strcpy(Str2,getarticle(this->name));
Monster.cpp:        if (this->level > Monsters[this->id].level) {
Monster.cpp:            strcat(Str2,wordnum(this->level+1-Monsters[this->id].level));
Monster.cpp:        strcat(Str2,this->name);
Monster.cpp:        strcpy(Str2,this->name);
Monster.cpp:        if (this->hp < Monsters[this->id].hp / 3)
Monster.cpp:        else if (this->hp < Monsters[this->id].hp / 2)
Monster.cpp:        else if (this->hp < Monsters[this->id].hp)
Monster.cpp:        else if (Lunarity == -1) hitmod -= (Player.level / 2);
Monster.cpp:        if (! this->wasAttackedByPlayer) Player.alignment -= 2; /* chaotic action */
Monster.cpp:        this->wasAttackedByPlayer = true;
Monster.cpp:        Player.hit -= hitmod;
Monster.cpp:    if (this->id == GUARD) {
Monster.cpp:            this->monster_talk();
Monster.cpp:    else if ((this->talkf==M_NO_OP) ||
Monster.cpp:             (this->talkf==M_TALK_STUPID))
Monster.cpp:        Player.xp = max(0,Player.xp - this->xpv);
Monster.cpp:        this->level = (min(10,this->level+1));
Monster.cpp:        this->hp += this->level*20;
Monster.cpp:        this->hit += this->level;
Monster.cpp:        this->dmg += this->level;
Monster.cpp:        this->ac += this->level;
Monster.cpp:        this->xpv += this->level*10;
Monster.cpp:        if ((this->talkf == M_TALK_EVIL) && random_range(10)) {
Monster.cpp:        else if (this->id == HORNET || this->id == GUARD)
Monster.cpp:            this->m_teleport();
Monster.cpp:    else if (((this->level*2 > Player.level) && (this->hp > Player.dmg)) ||
Monster.cpp:             (this->uniqueness != COMMON))
Monster.cpp:    else if ((this->talkf != M_TALK_GREEDY) &&
Monster.cpp:             (this->talkf != M_TALK_HUNGRY) &&
Monster.cpp:             (this->talkf != M_TALK_EVIL) &&
Monster.cpp:             (this->talkf != M_TALK_MAN) &&
Monster.cpp:             (this->talkf != M_TALK_BEG) &&
Monster.cpp:             (this->talkf != M_TALK_THIEF) &&
Monster.cpp:             (this->talkf != M_TALK_MERCHANT) &&
Monster.cpp:             (this->talkf != M_TALK_IM))
Monster.cpp:            this->m_death();
Monster.cpp:            Player.alignment -= 13;
Monster.cpp:            Player.alignment-=2;
Monster.cpp:            this->m_dropstuff();
Monster.cpp:            this->m_remove();
Monster.cpp:            this->m_remove( );
Monster.cpp:    if (this->hp < 1) {
Monster.cpp:        while (i<strlen(this->combatManeuvers)) {
Monster.cpp:            if ((this->combatManeuvers[i] == 'B') || (this->combatManeuvers[i] == 'R')) {
Monster.cpp:                if (hitloc == this->combatManeuvers[i+1])
Monster.cpp:        if (! blocks) goodblocks = -1;
Monster.cpp:        hit = hitp(Player.hit+hitmod,this->ac+goodblocks*10) > 0 ? true : false;
Monster.cpp:            if (this->uniqueness == COMMON) {
Monster.cpp:                strcat(Str1,this->name);
Monster.cpp:            else strcpy(Str1,this->name);
Monster.cpp:            this->m_water();
Monster.cpp:            this->m_lava();
Monster.cpp:            this->m_fire();
Monster.cpp:            this->m_water();
Monster.cpp:            this->m_abyss();
Monster.cpp:            this->m_trap_dart();
Monster.cpp:            this->m_trap_pit();
Monster.cpp:            this->m_trap_door();
Monster.cpp:            this->m_trap_snare();
Monster.cpp:            this->m_trap_blade();
Monster.cpp:            this->m_trap_fire();
Monster.cpp:            this->m_trap_teleport();
Monster.cpp:            this->m_trap_disintegrate();
Monster.cpp:            this->m_trap_manadrain();
Monster.cpp:            this->m_trap_sleepgas();
Monster.cpp:            this->m_trap_acid();
Monster.cpp:            this->m_trap_abyss();
Monster.cpp:            this->m_altar();
Monster_mmelee.cpp:    if (this->uniqueness == COMMON) {
Monster_mmelee.cpp:        strcat(Str3,this->name);
Monster_mmelee.cpp:    else strcpy(Str3,this->name);
Monster_mmelee.cpp:    else  p_damage(random_range(this->dmg),dtype,Str3);
Monster_mmelee.cpp:    while ((i < strlen(this->combatManeuvers)) && (this->hp > 0)) {
Monster_mmelee.cpp:        if (this->uniqueness == COMMON) {
Monster_mmelee.cpp:            strcat(Str4,this->name);
Monster_mmelee.cpp:        else strcpy(Str4,this->name);
Monster_mmelee.cpp:        if (this->combatManeuvers[i] == 'A') {
Monster_mmelee.cpp:            strcat(Str4,actionlocstr(this->combatManeuvers[i+1]));
Monster_mmelee.cpp:            monster_melee(this->combatManeuvers[i+1],0);
Monster_mmelee.cpp:        else if (this->combatManeuvers[i] == 'L') {
Monster_mmelee.cpp:            strcat(Str4,actionlocstr(this->combatManeuvers[i+1]));
Monster_mmelee.cpp:            monster_melee(this->combatManeuvers[i+1],this->level);
Monster_mmelee.cpp:        if (this->wasAttackedByPlayer == false) Player.alignment++;
Monster_mmelee.cpp:        this->wasAttackedByPlayer = true;
Monster_mmelee.cpp:        if (this->uniqueness == COMMON) {
Monster_mmelee.cpp:            strcat(Str2,this->name);
Monster_mmelee.cpp:        else strcpy(Str2,this->name);
Monster_mmelee.cpp:            switch(this->meleef) {
Monster_mmelee.cpp:                if (random_range(5)==3) this->m_sp_ng();
Monster_mmelee.cpp:                if (random_range(10) < this->level) {
Monster_mmelee.cpp:                    p_poison(this->dmg);
Monster_mmelee.cpp:                drain_life(this->level);
Monster_mmelee.cpp:                if (random_range(10) < this->level) {
Monster_mmelee.cpp:                    disease(this->level);
Monster_mmelee.cpp:                if (random_range(10) < this->level) {
Monster_mmelee.cpp:                    sleep_player(this->level);
Monster_mmelee.cpp:                        this->m_damage(this->dmg,UNSTOPPABLE);
Monster_mmelee.cpp:                        this->m_dropstuff();
Monster_mmelee.cpp:                        this->speed = min(30,this->speed*2);
Monster_mmelee.cpp:                    this->m_damage(this->dmg,UNSTOPPABLE);
Monster_mmelee.cpp:                    this->m_dropstuff();
Monster_mmelee.cpp:                    this->speed = min(30,this->speed*2);
Monster_mmelee.cpp:                    strcat(Str2," made a boo-boo.");
Monster_mmelee.cpp:    if (! blocks) goodblocks = -1;
Monster_mmelee.cpp:    hit = hitp(this->hit+bonus,Player.defense+goodblocks*10);
Monster_mmelee.cpp:            if (hitp(Player.hit,this->ac)) {
Monster_mmelee.cpp:    this->combatManeuvers = mmstr;
Monster_mmelee.cpp:    if (this->id != NPC)
Monster_mmelee.cpp:        strcpy(this->combatManeuvers,Monsters[this->id].combatManeuvers);
Monster_mmelee.cpp:        strcpy(this->combatManeuvers,"");
Monster_mmelee.cpp:        for(i=0; i<this->level; i+=2)
Monster_mmelee.cpp:            strcat(this->combatManeuvers,"L?R?");
Monster_mmelee.cpp:    while (i<strlen(this->combatManeuvers)) {
Monster_mmelee.cpp:        if ((this->combatManeuvers[i] == 'A') || (this->combatManeuvers[i] == 'L')) {
Monster_mmelee.cpp:            if (this->combatManeuvers[i+1] == '?') {
Monster_mmelee.cpp:                if (this->level+random_range(30) > Player.level+random_range(20))
Monster_mmelee.cpp:                    this->combatManeuvers[i+1] = attack_loc;
Monster_mmelee.cpp:                else this->combatManeuvers[i+1] = random_loc();
Monster_mmelee.cpp:            else if (this->combatManeuvers[i+1] == 'X') this->combatManeuvers[i+1] = random_loc();
Monster_mmelee.cpp:        else if ((this->combatManeuvers[i] == 'B') || (this->combatManeuvers[i] == 'R')) {
Monster_mmelee.cpp:            if (this->combatManeuvers[i+1] == '?') {
Monster_mmelee.cpp:                if (this->level+random_range(30) > Player.level+random_range(20))
Monster_mmelee.cpp:                    this->combatManeuvers[i+1] = block_loc;
Monster_mmelee.cpp:                else this->combatManeuvers[i+1] = random_loc();
Monster_mmelee.cpp:            else if (this->combatManeuvers[i+1] == 'X') this->combatManeuvers[i+1] = random_loc();
Monster_mspec.cpp:    if (this->wasAttackedByPlayer && (random_range(3) == 1)) {
Monster_mspec.cpp:        this->m_vanish();
Monster_mspec.cpp:        this->m_vanish();
Monster_mspec.cpp:    if (distance(this->x,this->y,Player.x,Player.y) < 2)
Monster_mspec.cpp:    if (distance(this->x,this->y,Player.x,Player.y) < 3) {
Monster_mspec.cpp:    if ((distance(Player.x,Player.y,this->x,this->y)<2) &&
Monster_mspec.cpp:            (this-> hp > 0) &&
Monster_mspec.cpp:            (this->hp < Monsters[this->id].hp))
Monster_mspec.cpp:        fball(this->x,this->y,this->x,this->y,this->hp);
Monster_mspec.cpp:        if ((this->id != INCUBUS) /* succubi don't give fear */
Monster_mspec.cpp:                && los_p(this->x, this->y, Player.x, Player.y)
Monster_mspec.cpp:                Player.status[AFRAID] += this->level;
Monster_mspec.cpp:    if ((this->hp < (this->level * 5)) && (this->hp > 1))
Monster_mspec.cpp:        this->hp = 1;
Monster_mspec.cpp:        switch(this->level)
Monster_mspec.cpp:        summon(-1, mid);
Monster_mspec.cpp:        summon(-1, mid);
Monster_mspec.cpp:            (distance(this->x,this->y,Player.x,Player.y) < 3))
Monster_mspec.cpp:        this->m_vanish();
Monster_mspec.cpp:        p_damage(1,FEAR,"a ghost-inspired heart attack");
Monster_mspec.cpp:        if (! p_immune(FEAR)) Player.status[AFRAID] += this->level;
Monster_mspec.cpp:    if (m_statusp(this,HOSTILE) && los_p(Player.x,Player.y,this->x,this->y)) {
Monster_mspec.cpp:        if (this->uniqueness == COMMON) strcpy(action,"The ");
Monster_mspec.cpp:        strcat(action,this->name);
Monster_mspec.cpp:        if (! magic_resist(this->level)) switch (random_range(this->level+7)) {
Monster_mspec.cpp:                nbolt(this->x,this->y,Player.x,Player.y,this->hit,10);
Monster_mspec.cpp:                this->hp += random_range(this->level*this->level);
Monster_mspec.cpp:                haste(-1);
Monster_mspec.cpp:                cure(-1);
Monster_mspec.cpp:                 * the monster's IQ in some way -- dumb but powerful monsters
Monster_mspec.cpp:                        distance(this->x,this->y,Player.x,Player.y) > 2)
Monster_mspec.cpp:                    lball(this->x,this->y,Player.x,Player.y,20);
Monster_mspec.cpp:                    lbolt(this->x,this->y,Player.x,Player.y,this->hit,20);
Monster_mspec.cpp:                        distance(this->x,this->y,Player.x,Player.y) > 2)
Monster_mspec.cpp:                    snowball(this->x,this->y,Player.x,Player.y,30);
Monster_mspec.cpp:                    icebolt(this->x,this->y,Player.x,Player.y,this->hit,30);
Monster_mspec.cpp:                enchant(-1);
Monster_mspec.cpp:                bless(0-this->level);
Monster_mspec.cpp:                p_poison(this->level);
Monster_mspec.cpp:                sleep_player(this->level/2);
Monster_mspec.cpp:                fbolt(this->x,this->y,Player.x,Player.y,this->hit*3,50);
Monster_mspec.cpp:                acquire(0-this->level);
Monster_mspec.cpp:                dispel(-1);
Monster_mspec.cpp:                if (this->uniqueness == COMMON) {
Monster_mspec.cpp:                    strcat(Str2,this->name);
Monster_mspec.cpp:                else strcpy(Str2,this->name);
Monster_mspec.cpp:                level_drain(this->level,Str2);
Monster_mspec.cpp:    if (this->wasAttackedByPlayer) {
Monster_mspec.cpp:            this->symbol = Monsters[this->id].symbol;
Monster_mspec.cpp:        this->specialf = M_MELEE_NORMAL;
Monster_mspec.cpp:        if (this->uniqueness == COMMON) {
Monster_mspec.cpp:            strcat(Str2,this->name);
Monster_mspec.cpp:        else strcpy(Str2,this->name);
Monster_mspec.cpp:        this->m_vanish();
Monster_mspec.cpp:        summon(-1,-1);
Monster_mspec.cpp:        summon(-1,-1);
Monster_mspec.cpp:        summon(-1,-1);
Monster_mspec.cpp:    else if (distance(Player.x,Player.y,this->x,this->y) < 2)
Monster_mspec.cpp:    if (distance(Player.x,Player.y,this->x,this->y) < 2)
Monster_mspec.cpp:        if (los_p(this->x,this->y,Player.x,Player.y)) {
Monster_mspec.cpp:            if (random_range(4)) enchant(-1);
Monster_mspec.cpp:            else dispel(-1);
Monster_mspec.cpp:            Player.pow--;
Monster_mspec.cpp:            if (--Player.pow < 1) p_death("the Eater of Magic");
Monster_mspec.cpp:    if (this->hp < 10) {
Monster_mspec.cpp:        manastorm(this->x,this->y,1000);
Monster_mspec.cpp:        if (distance(this->x,this->y,Player.x,Player.y)<2) {
Monster_mspec.cpp:            if (view_los_p(this->x,this->y,Player.x,Player.y)) {
Monster_mspec.cpp:    else if (distance(this->x,this->y,Player.x,Player.y)<2)
Monster_mspec.cpp:    if ((distance(this->x,this->y,Player.x,Player.y) < 4) &&
Monster_mspec.cpp:    if (loc_statusp(this->x,this->y,LIT)) {
Monster_mspec.cpp:        spreadroomdark(this->x,this->y,Level->site[this->x][this->y].roomnumber);
Monster_mspec.cpp:            (distance(Player.x,Player.y,this->x,this->y) < 2)) {
Monster_mspec.cpp:            Player.con--;
Monster_mspec.cpp:            Player.str--;
Monster_mspec.cpp:        do mid = random_range(ML9-NML_0)+ML1;
Monster_mspec.cpp:        /* log npc, 0th level npc, high score npc or were-creature */
Monster_mspec.cpp:        this->id = Monsters[mid].id;
Monster_mspec.cpp:        this->hp += Monsters[mid].hp;
Monster_mspec.cpp:        this->status |= Monsters[mid].status;
Monster_mspec.cpp:        this->ac = Monsters[mid].ac;
Monster_mspec.cpp:        this->dmg = Monsters[mid].dmg;
Monster_mspec.cpp:        this->speed = Monsters[mid].speed;
Monster_mspec.cpp:        this->immunity |= Monsters[mid].immunity;
Monster_mspec.cpp:        this->xpv += Monsters[mid].xpv;
Monster_mspec.cpp:        this->corpseWeight = Monsters[mid].corpseWeight;
Monster_mspec.cpp:        this->symbol = Monsters[mid].symbol;
Monster_mspec.cpp:        this->talkf = Monsters[mid].talkf;
Monster_mspec.cpp:        this->meleef = Monsters[mid].meleef;
Monster_mspec.cpp:        this->strikef = Monsters[mid].strikef;
Monster_mspec.cpp:        this->specialf = Monsters[mid].specialf;
Monster_mspec.cpp:        strcpy(Str1,"were-");
Monster_mspec.cpp:        strcpy(Str2,"dead were-");
Monster_mspec.cpp:        this->name = salloc(Str1);
Monster_mspec.cpp:        this->corpseString = salloc(Str2);
Monster_mspec.cpp:        this->immunity |= pow2(NORMAL_DAMAGE); /* WDT: not +=, rather |=. */
Monster_mspec.cpp:        if (los_p(this->x,this->y,Player.x,Player.y))
Monster_mspec.cpp:    if ((this->id == SERV_LAW) && (Player.alignment < 0))
Monster_mspec.cpp:    else if ((this->id == SERV_CHAOS) && (Player.alignment > 0))
Monster_mspec.cpp:        Player.mana -= (max(0,10-distance(this->x,this->y,Player.x,Player.y)));
Monster_mspec.cpp:        if (Level->site[this->x][this->y].locchar == FLOOR) {
Monster_mspec.cpp:            Level->site[this->x][this->y].locchar = LAVA;
Monster_mspec.cpp:            Level->site[this->x][this->y].p_locf = L_LAVA;
Monster_mspec.cpp:            lset(this->x, this->y, CHANGED);
Monster_mspec.cpp:        else if (Level->site[this->x][this->y].locchar == WATER) {
Monster_mspec.cpp:            Level->site[this->x][this->y].locchar = FLOOR;
Monster_mspec.cpp:            Level->site[this->x][this->y].p_locf = L_NO_OP;
Monster_mspec.cpp:            lset(this->x, this->y, CHANGED);
Monster_mspec.cpp:    switch(this->aux1) {
Monster_mspec.cpp:        switch(this->level) {
Monster_mspec.cpp:        summon(-1,mid);
Monster_mspec.cpp:        summon(-1,mid);
Monster_mspec.cpp:        summon(-1,mid);
Monster_mspec.cpp:        this->specialf = M_NO_OP;
Monster_mspec.cpp:        if (view_los_p(this->x,this->y,Player.x,Player.y))
Monster_mspec.cpp:        summon(-1,SWARM);
Monster_mspec.cpp:    for(x=this->x-2; x<=this->x+2; x++)
Monster_mspec.cpp:        for(y=this->y-2; y<=this->y+2; y++)
Monster_mspec.cpp:                if (Level->site[x][y].things != NULL)
Monster_mspec.cpp:                    if (Level->site[x][y].things->thing->id == CORPSEID) {
Monster_mspec.cpp:                        summon(-1,Level->site[x][y].things->thing->charge);
Monster_mspec.cpp:                        t = Level->site[x][y].things;
Monster_mspec.cpp:                        Level->site[x][y].things = Level->site[x][y].things->next;
Monster_mspec.cpp:                        free_obj( t->thing, true );
Monster_mspec.cpp:    if (distance(this->x,this->y,Player.x,Player.y)==1) {
Monster_mspec.cpp:            Player.pow-=3;
Monster_mspec.cpp:            Player.iq--;
Monster_mspec.cpp:            Player.con--;
Monster_mspec.cpp:            Player.str-=2;
Monster_mspec.cpp:            Player.dex--;
Monster_mspec.cpp:            Player.agi--;
Monster_mspec.cpp:            dispel(-1);
Monster_mspec.cpp:            /* DAG -- need calc_melee/calcmana here, because of new stats */
Monster_mspec.cpp:        /* DAG -- to fix the explode but not die manaburst bug */
Monster_mspec.cpp:        this->m_remove();
Monster_mspec.cpp:    if (view_los_p(this->x,this->y,Player.x,Player.y)) {
Monster_mspec.cpp:        if (random_range(20)+6 < this->level) {
Monster_mspec.cpp:            summon(-1,this->id);
Monster_mspec.cpp:                x = this->x + random_range(13)-6;
Monster_mspec.cpp:                y = this->y + random_range(13)-6;
Monster_mspec.cpp:                    Level->site[x][y].showchar = this->symbol;
Monster_mspec.cpp:                    putspot(x,y,this->symbol);
Monster_mspec.cpp:    if (i==NPC || i==HISCORE_NPC || i==ZERO_NPC) i = this->id; /* can't imitate NPC */
Monster_mspec.cpp:        this->symbol = Monsters[this->id].symbol;
Monster_mspec.cpp:        this->name = Monsters[this->id].name;
Monster_mspec.cpp:        this->symbol = Monsters[i].symbol;
Monster_mspec.cpp:        this->name = Monsters[i].name;
Monster_mspec.cpp:            (! los_p(this->x,this->y,Player.x,Player.y)) &&
Monster_mspec.cpp:        if (distance(Player.x,Player.y,this->x,this->y) < 2) {
Monster_mspec.cpp:            if (p_immune(THEFT) || (Player.level > (this->level*2)+random_range(20)))
Monster_mspec.cpp:                else if ((Player.possessions[i]->used) ||
Monster_mspec.cpp:                         (Player.dex < this->level*random_range(10))) {
Monster_mspec.cpp:                    if (this->uniqueness == COMMON) {
Monster_mspec.cpp:                        strcat(Str2,this->name);
Monster_mspec.cpp:                    else strcpy(Str2,this->name);
Monster_mspec.cpp:                    this->m_teleport();
Monster_mspec.cpp:                    this->movef = M_MOVE_SCAREDY;
Monster_mspec.cpp:                    this->specialf = M_MOVE_SCAREDY;
Monster_mspec.cpp:                    this->m_pickup(Player.possessions[i]);
Monster_mspec.cpp:    if ((distance(Player.x,Player.y,this->x,this->y) < 2) &&
Monster_mspec.cpp:        summon(0,-1);
Monster_mspec.cpp:        summon(0,-1);
Monster_mspec.cpp:        if (this->uniqueness == COMMON) {
Monster_mspec.cpp:            strcat(Str2,this->name);
Monster_mspec.cpp:        else strcpy(Str2,this->name);
Monster_mspec.cpp:            for (ml=Level->mlist; ml!=NULL; ml=ml->next) {
Monster_mspec.cpp:                m_status_set(ml->monster,AWAKE);
Monster_mspec.cpp:                m_status_set(ml->monster,HOSTILE);
Monster_mspec.cpp:            this->specialf = M_NO_OP;
Monster_mspec.cpp:        for(ml=Level->mlist; ml!=NULL; ml=ml->next) {
Monster_mspec.cpp:            m_status_set(ml->monster,HOSTILE);
Monster_mspec.cpp:            ml->monster->m_sp_spell();
Monster_mspec.cpp:            if (ml->monster->specialf == M_SP_COURT)
Monster_mspec.cpp:                ml->monster->specialf = M_SP_SPELL;
Monster_mspec.cpp:        for(ml=Level->mlist; ml!=NULL; ml=ml->next)
Monster_mspec.cpp:            if (ml->monster->hp > 0 && ml->monster->specialf == M_SP_LAIR) {
Monster_mspec.cpp:                m_status_set(ml->monster,HOSTILE);
Monster_mspec.cpp:                fbolt(ml->monster->x,ml->monster->y,Player.x,Player.y,100,100);
Monster_mspec.cpp:                if (ml->monster->id == DRAGON_LORD)
Monster_mspec.cpp:                    ml->monster->specialf = M_SP_DRAGONLORD;
Monster_mspec.cpp:                    ml->monster->specialf = M_STRIKE_FBOLT;
Monster_mspec.cpp:        summon(-1,DEMON_PRINCE);
Monster_mspec.cpp:        summon(-1,DEMON_PRINCE);
Monster_mspec.cpp:        summon(-1,DEMON_PRINCE);
Monster_mspec.cpp:        summon(-1,DEMON_PRINCE);
Monster_mspec.cpp:    this->specialf = M_SP_SPELL;
Monster_mstrike.cpp:    fbolt(this->x,this->y,Player.x,Player.y,this->hit,this->dmg);
Monster_mstrike.cpp:    nbolt(this->x,this->y,Player.x,Player.y,this->hit,this->dmg);
Monster_mstrike.cpp:    lball(this->x,this->y,Player.x,Player.y,this->dmg);
Monster_mstrike.cpp:    fball(this->x,this->y,Player.x,Player.y,this->dmg);
Monster_mstrike.cpp:    snowball(this->x,this->y,Player.x,Player.y,this->dmg);
Monster_mstrike.cpp:            los_p(this->x,this->y,Player.x,Player.y) &&
Monster_mstrike.cpp:            (distance(this->x,this->y,Player.x,Player.y) < 5)) {
Monster_mstrike.cpp:        if (this->uniqueness == COMMON) {
Monster_mstrike.cpp:            strcat(Str2,this->name);
Monster_mstrike.cpp:        else strcpy(Str2,this->name);
Monster_mstrike.cpp:            for(ml=Level->mlist; ml!=NULL; ml=ml->next)
Monster_mstrike.cpp:                plotspot(ml->monster->x,ml->monster->y,false);
Monster_mstrike.cpp:    if (this->uniqueness == COMMON) {
Monster_mstrike.cpp:        strcat(Str2,this->name);
Monster_mstrike.cpp:    else strcpy(Str2,this->name);
Monster_mstrike.cpp:    p_damage(this->dmg,OTHER_MAGIC,"a sonic blast");
Monster_mtalk.cpp:                    Player.alignment -= Player.alignment*max(0, 10 - Player.level)/10;
Monster_mtalk.cpp:            for (curr = Level->mlist; curr; curr = curr->next)
Monster_mtalk.cpp:                m_status_reset(curr->monster, HOSTILE);
Monster_mtalk.cpp:            this->m_vanish();
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:        if ( (!CitySiteList[L_TOURIST-CITYSITEBASE][0]) &&
Monster_mtalk.cpp:            CitySiteList[L_TOURIST-CITYSITEBASE][0] = true;
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:    mprint("The black-garbed figure says apologetically:");
Monster_mtalk.cpp:        if (this->level == 2)
Monster_mtalk.cpp:            this->name = "sneak thief";
Monster_mtalk.cpp:        else this->name = "master thief";
Monster_mtalk.cpp:        this->m_vanish();
Monster_mtalk.cpp:    this->name = "master assassin";
Monster_mtalk.cpp:    if (strcmp(this->name,"itinerant merchant") != 0) {
Monster_mtalk.cpp:        this->name = "itinerant merchant";
Monster_mtalk.cpp:    if (this->possessions == NULL)
Monster_mtalk.cpp:        this->possessions->thing->known = 2;
Monster_mtalk.cpp:        mprint(itemid(this->possessions->thing));
Monster_mtalk.cpp:        mlongprint(max(10,4*true_item_value(this->possessions->thing)));
Monster_mtalk.cpp:            if (Player.cash < (max(10,4*true_item_value(this->possessions->thing)))) {
Monster_mtalk.cpp:                    gain_item(this->possessions->thing);
Monster_mtalk.cpp:                Player.cash -= max(10,(4*item_value(this->possessions->thing)));
Monster_mtalk.cpp:                gain_item(this->possessions->thing);
Monster_mtalk.cpp:            free_obj( this->possessions->thing, true );
Monster_mtalk.cpp:        tmp = this->possessions;
Monster_mtalk.cpp:        this->possessions = tmp->next;
Monster_mtalk.cpp:        if (NULL != this->possessions)
Monster_mtalk.cpp:            this->m_vanish();
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:        strcat(Str2," insults your mother-in-law.");
Monster_mtalk.cpp:        strcat(Str2," sends 'rm -r *' to your shell!");
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:        strcat(Str2," says: 'Danger -- Danger'");
Monster_mtalk.cpp:        strcat(Str2," says: 'Yo Mama -- core dumped.'");
Monster_mtalk.cpp:    mprint("It can't talk -- it's too slithy!");
Monster_mtalk.cpp:    mprint("It can't talk -- it's too mimsy!");
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:        this->talkf = M_TALK_SILENT;
Monster_mtalk.cpp:    mprint("In a flash of sweet-smelling light, the fairy vanishes....");
Monster_mtalk.cpp:    this->m_vanish();
Monster_mtalk.cpp:    mprint("She waves her black-glowing wand, which screams thinly....");
Monster_mtalk.cpp:    this->movef=M_MOVE_SMART;
Monster_mtalk.cpp:    this->meleef=M_MELEE_POISON;
Monster_mtalk.cpp:    this->specialf=M_SP_THIEF;
Monster_mtalk.cpp:    acquire(-1);
Monster_mtalk.cpp:    bless(-1);
Monster_mtalk.cpp:    sleep_player(this->level/2);
Monster_mtalk.cpp:    summon(-1,-1);
Monster_mtalk.cpp:    summon(-1,-1);
Monster_mtalk.cpp:    summon(-1,-1);
Monster_mtalk.cpp:    summon(-1,-1);
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:            strcat(Str2,this->name);
Monster_mtalk.cpp:    this->m_vanish();
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:            if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:                strcat(Str2,this->name);
Monster_mtalk.cpp:            else strcpy(Str2,this->name);
Monster_mtalk.cpp:    this->talkf = M_TALK_EVIL;
Monster_mtalk.cpp:    this->meleef = M_MELEE_SPIRIT;
Monster_mtalk.cpp:    this->specialf = M_SP_DEMON;
Monster_mtalk.cpp:    if ((this->symbol&0xff) == 's') {
Monster_mtalk.cpp:        this->symbol = 'I'|CLR(RED);
Monster_mtalk.cpp:        this->name = "incubus";
Monster_mtalk.cpp:        this->symbol = 'S'|CLR(RED);
Monster_mtalk.cpp:        this->name = "succubus";
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:            this->m_remove();
Monster_mtalk.cpp:    if (this->id == SERV_LAW) {
Monster_mtalk.cpp:        if (Level->site[x][y].creature != NULL) {
Monster_mtalk.cpp:            if (Level->site[x][y].creature->id == target) {
Monster_mtalk.cpp:                gain_experience(this->xpv);
Monster_mtalk.cpp:                Level->site[x][y].creature->m_death();
Monster_mtalk.cpp:                Level->site[this->x][this->y].creature = NULL;
Monster_mtalk.cpp:                this->x = x;
Monster_mtalk.cpp:                this->y = y;
Monster_mtalk.cpp:                Level->site[x][y].creature = this;
Monster_mtalk.cpp:                Level->site[x][y].creature->m_death();
Monster_mtalk.cpp:    if (this->uniqueness == COMMON) {
Monster_mtalk.cpp:        strcat(Str2,this->name);
Monster_mtalk.cpp:    else strcpy(Str2,this->name);
Monster_mtalk.cpp:    summon(-1,QUAIL);
Monster_mtalk.cpp:    this->talkf = M_TALK_EVIL;
Monster_mtalk.cpp:        if (Level->site[this->x][this->y].p_locf == L_THRONE) {
Monster_mtalk.cpp:            this->m_vanish();
Monster_mtalk.cpp:        mprint("of the far North-East; if you do he will give you some");
Monster_mtalk.cpp:            mprint("The Maharaja offers you goat-eyeball soup.'");
Monster_mtalk.cpp:                    Player.cash -= 250;
Monster_mtalk.cpp:                    this->m_vanish();
Monster_mtalk.cpp:            this->m_dropstuff();
Monster_mtalk.cpp:            this->m_vanish();
Monster_mtalk.cpp:                this->m_vanish();
monsters.h:    { NULL,true,0,0,0,0,0,ML0+0,1,1,10,2,4,1,0,1,50,0,1,1,1,-1,-1,COMMON,M_TALK_STUPID,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|FLYING|POISONOUS,0,'h'|CLR(YELLOW),"hornet","dead hornet","AXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML0+1,30,0,0,0,10,10,0,5,100,2,15,1000,0,-1,-1,COMMON,M_TALK_MP,M_MOVE_FOLLOW,M_MELEE_MP,M_NO_OP,M_SP_MP,MOBILE|NEEDY,0,'@'|CLR(RED),"mendicant priest","dead mendicant priest","BX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML0+2,15,0,0,0,10,10,0,7,0,3,5,1000,0,-1,-1,COMMON,M_TALK_IM,M_MOVE_FOLLOW,M_NO_OP,M_NO_OP,M_SP_ESCAPE,MOBILE,0,'@'|CLR(RED),"itinerant merchant","dead itinerant merchant","BX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML0+3,150,20,20,25,10,1,0,3,50,0,150,1000,0,-1,WEAPONID+5,COMMON,M_TALK_GUARD,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_SP_WHISTLEBLOWER,MOBILE,0,'G'|CLR(RED),"guardsman","dead guardsman","A?A?A?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML0+4,5,5,5,5,5,5,0,5,5,0,5,1000,0,-1,-1,COMMON,M_TALK_MAN,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,AWAKE|HOSTILE,0,'@'|CLR(RED),"Log NPC","dead NPC","A?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML0+5,5,5,5,1,2,1,0,5,25,0,2,200,10,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_RANDOM,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|SWIMMING|EDIBLE,0,'s'|CLR(WHITE),"sheep","side of mutton","ALBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML0+6,16,6,6,1,2,1,0,6,0,0,6,200,0,-1,-1,COMMON,M_TALK_MERCHANT,M_NO_OP,M_MELEE_NORMAL,M_NO_OP,M_SP_MERCHANT,MOBILE,0,'@'|CLR(RED),"merchant","dead merchant","A?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML0+7,10,5,5,5,5,5,0,5,25,1,5,1800,0,-1,-1,COMMON,M_TALK_MAN,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|WANDERING,0,'@'|CLR(RED),"0th level NPC","dead 0th level NPC","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML0+8,5,5,5,5,5,5,0,5,5,0,5,1000,0,-1,-1,UNIQUE_MADE,M_TALK_MAN,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,AWAKE|HOSTILE,0,'@'|CLR(RED),"Hiscore NPC","dead NPC","A?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+0,25,12,5,15,3,3,1,8,100,0,10,100,0,-1,WEAPONID+17,COMMON,M_TALK_STUPID,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|POISONOUS,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY),'g'|CLR(BROWN),"grunt","dead grunt","ACAC" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+1,1,10,5,2,10,10,1,4,0,0,3,1,5,POTIONID+5,-1,COMMON,M_TALK_STUPID,M_MOVE_FLUTTER,M_MELEE_SLEEP,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|FLYING,0,'t'|CLR(PURPLE),"tse-tse fly","dead tse-tse fly","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+2,1,0,0,0,10,10,1,10,0,1,5,2,50,SCROLLID+21,-1,COMMON,M_TALK_STUPID,M_MOVE_FLUTTER,M_NO_OP,M_NO_OP,M_SP_SUMMON,0,0,'f'|CLR(PURPLE),"fnord","fnord's antennae","" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+3,5,5,3,5,5,2,1,3,30,0,5,10,0,-1,-1,COMMON,M_TALK_STUPID,M_MOVE_FLUTTER,M_MELEE_DISEASE,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|SWIMMING,0,'r'|CLR(BROWN),"sewer rat","dead sewer rat","ALAL" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+4,12,0,0,0,10,10,1,10,0,0,1,1,0,-1,-1,COMMON,M_TALK_STUPID,M_NO_OP,M_NO_OP,M_NO_OP,M_SP_AGGRAVATE,0,pow2(FLAME),'f'|CLR(CYAN),"aggravator fungus","aggravator fungus spores","" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+5,50,0,5,0,3,3,1,24,100,2,20,20,25,SCROLLID+5,-1,COMMON,M_TALK_STUPID,M_NO_OP,M_NO_OP,M_NO_OP,M_MOVE_TELEPORT,MOBILE,0,'b'|CLR(BRIGHT_WHITE)/*|CLR(FG_BLINK)*/,"blipper","blipper organ","BX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+6,8,10,8,8,10,2,1,5,0,1,10,500,0,-1,WEAPONID+0,COMMON,M_TALK_GREEDY,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|GREEDY,0,'g'|CLR(GREEN),"goblin","dead goblin","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+7,10,10,10,10,4,4,1,9,50,1,25,5,10,SCROLLID+19,-1,COMMON,M_TALK_SILENT,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_SP_ILLUSION,MOBILE|HOSTILE|POISONOUS,pow2(SLEEP),'p'|CLR(RED),"phantasticon","phantasticon's eyes","AXAXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+8,5,10,10,15,10,3,1,12,100,0,15,25,0,-1,-1,COMMON,M_TALK_ROBOT,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE,pow2(ELECTRICITY)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'R'|CLR(GREY),"household robot","household robot battery","ACBC" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+9,1,5,5,5,10,10,1,8,50,0,1,250,0,-1,-1,COMMON,M_TALK_STUPID,M_MOVE_SCAREDY,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE,0,'g'|CLR(WHITE),"pencil-necked geek","dead pencil-necked geek","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+10,6,8,5,6,4,3,1,4,50,0,6,30,0,-1,-1,COMMON,M_TALK_MIMSY,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|FLYING|EDIBLE,0,'b'|CLR(GREEN),"borogrove","borogrove wings","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+11,3,0,15,1,4,4,1,2,50,0,1,20,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|FLYING|EDIBLE,0,'q'|CLR(BROWN),"quail","quail en brochet","" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+12,13,10,5,5,2,1,1,4,50,0,3,20,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|SWIMMING|EDIBLE,0,'b'|CLR(BROWN),"badger","badger ribs","ALAL" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+13,7,15,10,10,10,5,1,2,50,0,10,20,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|FLYING|EDIBLE,0,'h'|CLR(BROWN),"hawk","buffalo style hawk wings","AH" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+14,23,5,10,5,10,10,1,2,50,0,5,500,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|SWIMMING|EDIBLE,0,'d'|CLR(BROWN),"deer","venison","AXBXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+15,30,10,5,10,4,2,1,5,50,0,5,500,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|EDIBLE,0,'c'|CLR(BROWN),"camel","hump au jus","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+16,20,0,5,5,4,2,1,4,50,0,3,400,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|SWIMMING|EDIBLE,0,'a'|CLR(BROWN),"anteater","roast loin of anteater","AL" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+17,3,0,7,1,4,4,1,3,50,0,1,20,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|SWIMMING|EDIBLE,0,'r'|CLR(BROWN),"rabbit","bunnyburgers","AL" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+18,3,0,18,1,4,4,1,2,50,0,1,20,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_NO_OP,M_NO_OP,M_NO_OP,MOBILE|ONLYSWIM|EDIBLE,0,'t'|CLR(CYAN),"trout","filet of trout","" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+19,1,0,0,0,4,4,1,4,50,0,1,20,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_NO_OP,M_NO_OP,M_NO_OP,MOBILE|ONLYSWIM|EDIBLE,0,'b'|CLR(CYAN),"striped bass","bass filets","" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+20,5,10,10,12,10,2,1,3,50,0,5,20,0,-1,-1,COMMON,M_TALK_PARROT,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HUNGRY|FLYING|EDIBLE,0,'p'|CLR(PURPLE),"parrot","grilled breast of parrot","AH" },
monsters.h:    { NULL,true,0,0,0,0,0,ML1+21,10,10,5,5,10,2,1,4,20,0,8,20,0,-1,-1,COMMON,M_TALK_HYENA,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|SWIMMING|EDIBLE,0,'h'|CLR(BROWN),"hyena","hyena ribs","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+0,20,16,10,15,10,3,2,3,50,1,40,1000,0,-1,WEAPONID+1,COMMON,M_TALK_NINJA,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_SP_SURPRISE,MOBILE|HOSTILE|M_INVISIBLE,0,'n'|CLR(GREY),"apprentice ninja","dead ninja","A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+1,30,15,10,5,10,10,2,6,0,0,35,250,100,-1,-1,COMMON,M_TALK_TITTER,M_MOVE_FLUTTER,M_MELEE_NG,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|FLYING|POISONOUS,0,'n'|CLR(GREY),"night gaunt","dead night gaunt","ACAC" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+2,32,0,10,0,10,10,2,2,0,3,20,1000,0,-1,-1,COMMON,M_TALK_THIEF,M_MOVE_SMART,M_NO_OP,M_NO_OP,M_SP_THIEF,MOBILE|HOSTILE|GREEDY,0,'@'|CLR(RED),"sneak-thief","dead sneak-thief","AXB?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+3,25,0,0,0,10,10,2,5,0,0,10,1,20,POTIONID+16,-1,COMMON,M_NO_OP,M_MOVE_RANDOM,M_NO_OP,M_NO_OP,M_SP_EXPLODE,MOBILE|FLYING,pow2(SLEEP),'e'|CLR(GREEN),"floating eye","dead floating eye","" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+4,30,10,10,10,6,3,2,4,0,0,25,10,0,-1,-1,COMMON,M_TALK_SLITHY,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE,0,'t'|CLR(GREEN),"tove","dead tove","ALBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+5,32,15,10,5,5,3,2,8,0,1,30,50,30,POTIONID+10,-1,COMMON,M_NO_OP,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_NO_OP,MOBILE|HOSTILE|M_INVISIBLE,0,'n'|CLR(GREY),"transparent nasty","dead transparent nasty","ACAC" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+6,32,0,10,0,5,10,2,20,0,0,30,1,0,-1,-1,COMMON,M_TALK_HINT,M_MOVE_SPIRIT,M_NO_OP,M_NO_OP,M_SP_GHOST,MOBILE|WANDERING|INTANGIBLE,pow2(NORMAL_DAMAGE)|pow2(FEAR)|pow2(SLEEP),'g'|CLR(GREY),"ghost","ghost ectoplasm","" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+7,20,5,10,5,5,3,2,8,0,2,40,1,100,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_SCAREDY,M_MELEE_NORMAL,M_NO_OP,M_SP_SPELL,MOBILE|HOSTILE,pow2(COLD),'e'|CLR(RED),"enchanter","dead enchanter","AXBXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+8,7,0,0,0,10,3,2,12,0,0,40,1,10,SCROLLID+22,-1,COMMON,M_NO_OP,M_NO_OP,M_NO_OP,M_NO_OP,M_SP_BLACKOUT,AWAKE|HOSTILE|POISONOUS,0,'f'|CLR(GREY),"murk fungus","murk cloud particles","" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+9,25,20,12,10,10,3,2,4,0,1,30,1,-1,-1,WEAPONID+12,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_NO_OP,MOBILE|HOSTILE|GREEDY,pow2(FEAR),'G'|CLR(GREEN),"goblin chieftain","dead goblin chieftain","A?A?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+10,40,15,5,15,8,3,2,4,10,0,35,50,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|SWIMMING|EDIBLE,pow2(FEAR)|pow2(SLEEP),'w'|CLR(BROWN),"wolf","wolf cutlets","AXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+11,20,15,15,10,3,3,2,3,10,0,30,50,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_NORMAL,M_MELEE_POISON,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|POISONOUS,pow2(FEAR)|pow2(SLEEP),'a'|CLR(RED),"giant soldier ant","ant mandibles","AXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+12,100,25,25,50,3,3,2,12,10,0,50,500,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HUNGRY|SWIMMING|EDIBLE,0,'e'|CLR(GREY),"elephant","trunk steak","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML2+13,50,20,5,20,6,3,2,4,10,0,40,500,0,-1,-1,COMMON,M_TALK_HORSE,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HUNGRY|SWIMMING|EDIBLE,0,'h'|CLR(BROWN),"horse","steaming horsemeat","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+0,35,15,5,30,4,1,3,4,50,0,75,50,50,RINGID+4,-1,COMMON,M_TALK_STUPID,M_MOVE_FLUTTER,M_MELEE_FIRE,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|GREEDY,pow2(FLAME),'s'|CLR(LIGHT_RED),"salamander","salamander scales","AXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+1,100,10,10,20,5,2,3,8,50,0,50,10,50,RINGID+3,-1,COMMON,M_TALK_STUPID,M_MOVE_NORMAL,M_MELEE_NORMAL,M_STRIKE_BLIND,M_NO_OP,MOBILE|HOSTILE|HUNGRY|GREEDY,0,'C'|CLR(GREEN),"catoblepas","catoblepas' eyes","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+2,15,18,15,15,3,3,3,4,0,2,80,25,50,STICKID+10,-1,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_COLD,M_NO_OP,M_SP_DEMON,MOBILE|HOSTILE,pow2(COLD)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'f'|CLR(LIGHT_BLUE),"lesser frost demon","lesser frost demon's heart","A?A?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+3,10,20,0,50,5,1,3,20,0,0,60,10,0,-1,-1,COMMON,M_NO_OP,M_MOVE_FOLLOW,M_MELEE_NORMAL,M_NO_OP,M_SP_ACID_CLOUD,MOBILE|FLYING,pow2(POISON)|pow2(SLEEP),'a'|CLR(YELLOW),"acid cloud","acid pool","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+4,1,20,0,0,5,5,2,10,100,0,90,10,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_SPIRIT,M_MELEE_SPIRIT,M_NO_OP,M_SP_SURPRISE,MOBILE|HOSTILE|FLYING|INTANGIBLE|M_INVISIBLE,pow2(NORMAL_DAMAGE)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'p'|CLR(GREY),"phantom","hardly anything at all","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+5,32,18,10,32,5,20,3,5,100,3,500,100,0,-1,WEAPONID+36,UNIQUE_MADE,M_TALK_GREEDY,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_NO_OP,MOBILE|HOSTILE|GREEDY,0,'K'|CLR(LIGHT_GREEN),"The Goblin King","The Head of the Goblin King","A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+6,42,16,10,10,8,4,3,3,0,0,75,500,1,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|FLYING|EDIBLE,pow2(FEAR)|pow2(SLEEP),'P'|CLR(PURPLE),"pterodactyl","pterodactyl patee","AH" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+7,25,10,10,10,5,5,3,6,0,2,40,500,-1,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_SP_SPELL,MOBILE|HOSTILE|GREEDY,0,'G'|CLR(GREEN),"goblin shaman","dead goblin shaman","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+8,60,20,10,25,5,1,3,3,0,0,50,50,-1,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|SWIMMING|EDIBLE,0,'l'|CLR(YELLOW),"lion","lion souflee","AXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+9,30,15,10,15,5,1,3,5,0,2,75,50,-1,-1,WEAPONID+27,COMMON,M_TALK_GREEDY,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_NO_OP,MOBILE|HOSTILE|GREEDY,0,'b'|CLR(RED),"brigand","dead brigand","AXAXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+10,70,25,20,40,3,1,3,10,80,0,55,500,-1,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_ANIMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HUNGRY|SWIMMING|EDIBLE,pow2(FEAR),'b'|CLR(BROWN),"bear","bear's sirloin tips","AXAXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+11,10,25,10,20,3,1,3,3,40,0,45,30,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_NORMAL,M_MELEE_POISON,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|POISONOUS,0,'m'|CLR(RED),"mamba","mamba filet","AXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+12,40,15,10,30,3,1,3,7,0,1,40,20,0,-1,-1,COMMON,M_NO_OP,M_MOVE_NORMAL,M_MELEE_POISON,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|ONLYSWIM|POISONOUS,pow2(POISON),'M'|CLR(BLUE),"man o' war","deliquescing tentacles","AXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+13,40,5,10,10,5,2,3,5,0,1,100,20,0,-1,-1,COMMON,M_TALK_MAN,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_SP_WERE,MOBILE,0,'@'|CLR(RED),"were-human","dead were-human","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML3+14,4,0,0,1,5,2,3,5,0,1,50,20,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_SPIRIT,M_MELEE_SPIRIT,M_NO_OP,M_NO_OP,MOBILE|HOSTILE,pow2(COLD)|pow2(ELECTRICITY)|pow2(POISON)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(OTHER_MAGIC)|pow2(THEFT)|pow2(GAZE)|pow2(INFECTION),'T'|CLR(GREY),"thought-form","a velleity","ACACACACAC" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+0,100,15,12,25,6,2,4,6,25,2,150,300,20,STICKID+11,-1,COMMON,M_TALK_HUNGRY,M_MOVE_NORMAL,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_NO_OP,MOBILE|HOSTILE|HUNGRY|FLYING,0,'M'|CLR(YELLOW),"manticore","manticore spikes","AXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+1,50,12,10,10,10,10,4,2,50,0,100,300,10,POTIONID+6,-1,COMMON,M_TALK_HUNGRY,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY,0,'T'|CLR(BROWN),"tasmanian devil","dead tasmanian devil","AXAXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+2,100,15,15,50,5,2,4,7,100,0,100,100,0,-1,-1,COMMON,M_TALK_ROBOT,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_SP_POISON_CLOUD,MOBILE|HOSTILE,pow2(ELECTRICITY)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'a'|CLR(GREY),"automatum minor","automatum minor battery","ACBC" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+3,75,30,10,15,5,1,4,12,75,0,125,50,20,POTIONID+17,-1,COMMON,M_TALK_SILENT,M_MOVE_NORMAL,M_MELEE_DISEASE,M_NO_OP,M_SP_SURPRISE,MOBILE|HOSTILE|HUNGRY|M_INVISIBLE|SWIMMING,pow2(FLAME)|pow2(ELECTRICITY)|pow2(POISON),'s'|CLR(GREEN),"denebian slime devil","denebian slime","AL" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+4,50,18,12,25,5,1,4,3,75,0,125,500,0,-1,-1,COMMON,M_TALK_BURBLE,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|FLYING|EDIBLE,pow2(POISON),'j'|CLR(PURPLE),"jub-jub bird","jube-jubes","AHAH" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+5,50,15,5,20,4,1,4,7,0,0,150,500,0,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_NORMAL,M_MELEE_POISON,M_NO_OP,M_SP_SURPRISE,MOBILE|HOSTILE|HUNGRY|M_INVISIBLE|POISONOUS,pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'h'|CLR(GREY),"haunt","dessicated corpse","ACAC" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+6,50,20,10,10,4,4,4,5,0,1,150,1,200,-1,-1,COMMON,M_TALK_DEMONLOVER,M_MOVE_SMART,M_NO_OP,M_NO_OP,M_SP_DEMONLOVER,MOBILE|NEEDY|POISONOUS,pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'!'|CLR(RED),"incubus/succubus","(null)","(null)" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+7,50,0,10,0,4,4,4,6,0,0,50,1,0,-1,-1,COMMON,M_TALK_SEDUCTOR,M_MOVE_SMART,M_NO_OP,M_NO_OP,M_SP_SEDUCTOR,MOBILE|NEEDY,0,'!'|CLR(RED),"satyr or nymph","(null)","(null)" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+8,80,25,20,30,4,1,4,8,50,0,100,300,100,-1,-1,COMMON,M_NO_OP,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|ONLYSWIM,0,'c'|CLR(GREEN),"giant crocodile","crocodile hide","ALALBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+9,40,30,0,10,4,4,4,12,0,0,120,30,50,POTIONID+5,-1,COMMON,M_TALK_STUPID,M_MOVE_NORMAL,M_MELEE_SLEEP,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY,pow2(FEAR)|pow2(SLEEP),'t'|CLR(BROWN),"torpor beast","a valium gland","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+10,40,20,10,15,8,8,4,2,0,0,120,300,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_LEASH,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE,pow2(FEAR)|pow2(SLEEP),'d'|CLR(BROWN),"doberman death-hound","dead doberman death-hound","LXLXLX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+11,40,10,10,10,8,8,4,1,0,0,100,0,0,-1,-1,COMMON,M_NO_OP,M_MOVE_SPIRIT,M_MELEE_COLD,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|INTANGIBLE,pow2(FLAME)|pow2(FEAR)|pow2(SLEEP),'F'|CLR(GREY),"astral fuzzy","nothing much","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+12,30,40,40,20,8,8,4,5,0,2,120,0,0,-1,-1,COMMON,M_TALK_SERVANT,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_SP_SERVANT,MOBILE,pow2(FEAR)|pow2(SLEEP),'l'|CLR(BLUE),"servant of law","dead servant","L?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+13,40,25,20,10,8,8,4,5,0,2,120,500,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_SP_SERVANT,MOBILE,pow2(FEAR)|pow2(SLEEP),'c'|CLR(RED),"servant of chaos","dead servant","AXAXAXAX?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+14,40,15,0,10,3,0,4,10,0,0,50,1,0,-1,-1,COMMON,M_NO_OP,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_SP_SWARM,MOBILE|HOSTILE|FLYING,pow2(NORMAL_DAMAGE)|pow2(FEAR)|pow2(SLEEP),'s'|CLR(YELLOW),"swarm","dead swarm members","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+15,40,10,20,10,8,8,4,4,0,2,100,50,0,-1,-1,COMMON,M_TALK_SCREAM,M_MOVE_NORMAL,M_MELEE_SPIRIT,M_STRIKE_SONIC,M_NO_OP,MOBILE|HOSTILE|FLYING,pow2(FEAR)|pow2(SLEEP),'b'|CLR(GREY),"ban sidhe","dead ban sidhe","LX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+16,50,20,20,20,3,1,4,6,60,3,100,1,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_SPIRIT,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|INTANGIBLE,pow2(NORMAL_DAMAGE),'e'|CLR(GREEN),"etheric grue","dead etheric grue","LHAHLH" },
monsters.h:    { NULL,true,0,0,0,0,0,ML4+17,40,20,13,30,8,4,4,5,0,1,100,500,100,-1,-1,COMMON,M_TALK_NINJA,M_MOVE_NORMAL,M_MELEE_POISON,M_STRIKE_MISSILE,M_SP_SURPRISE,MOBILE|HOSTILE|M_INVISIBLE,pow2(POISON)|pow2(SLEEP),'n'|CLR(GREY),"ninja (genin)","dead ninja","A?A?R?R" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+0,50,20,15,40,10,2,5,3,90,4,180,500,50,RINGID+4,-1,COMMON,M_TALK_GREEDY,M_MOVE_NORMAL,M_MELEE_DRAGON,M_STRIKE_FBOLT,M_NO_OP,MOBILE|HOSTILE|HUNGRY|GREEDY|FLYING|EDIBLE,pow2(FLAME),'d'|CLR(LIGHT_RED),"dragonette","dragon steak","AXAXBXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+1,50,15,10,40,10,2,5,12,40,0,150,100,200,STICKID+3,-1,COMMON,M_TALK_STUPID,M_MOVE_FLUTTER,M_MELEE_ELEC,M_STRIKE_LBALL,M_NO_OP,MOBILE|HOSTILE,pow2(ELECTRICITY),'t'|CLR(LIGHT_BLUE),"tesla monster","tesla monster whip","AXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+2,100,20,12,20,4,2,5,4,80,2,150,100,150,RINGID+6,-1,COMMON,M_TALK_GREEDY,M_MOVE_NORMAL,M_MELEE_POISON,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|GREEDY|FLYING|POISONOUS,pow2(FLAME),'W'|CLR(LIGHT_RED),"wyvern","wyvern's sting","AXAXBXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+3,50,15,10,20,10,2,5,2,50,0,250,400,0,-1,-1,COMMON,M_TALK_HUNGRY,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_SP_FLUTTER,MOBILE|HOSTILE|HUNGRY|FLYING,pow2(FEAR),'c'|CLR(BROWN),"radeligian cateagle","dead radeligian cateagle","AXAXAXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+4,75,20,20,20,5,5,5,3,50,3,200,50,200,STICKID+4,-1,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_COLD,M_STRIKE_SNOWBALL,M_SP_DEMON,MOBILE|HOSTILE|POISONOUS,pow2(COLD)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'f'|CLR(WHITE),"frost demon","frost demon's heart","A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+5,75,20,20,20,5,2,5,6,50,0,200,10,200,CLOAKID+1,-1,COMMON,M_TALK_EVIL,M_MOVE_SPIRIT,M_MELEE_SPIRIT,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|FLYING,pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'S'|CLR(GREY),"spectre","spectre's veil","A?A?A?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+6,50,12,13,10,5,5,5,5,0,4,205,10,500,-1,SCROLLID+1,COMMON,M_TALK_EVIL,M_MOVE_SCAREDY,M_MELEE_NORMAL,M_NO_OP,M_SP_SPELL,MOBILE|HOSTILE,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY),'n'|CLR(RED),"necromancer","dead necromancer","A?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+7,40,18,18,20,5,5,5,7,50,2,175,2,10,SCROLLID+22,-1,COMMON,M_TALK_EVIL,M_MOVE_SPIRIT,M_MELEE_SPIRIT,M_NO_OP,M_SP_BLACKOUT,MOBILE|HOSTILE|INTANGIBLE,pow2(NORMAL_DAMAGE),'S'|CLR(GREY),"shadow spirit","shadowstuff","ACACAC" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+8,80,22,8,30,3,3,5,12,50,2,275,20,0,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_GRAPPLE,M_NO_OP,M_SP_BOG,MOBILE|HOSTILE|ONLYSWIM|POISONOUS,pow2(NORMAL_DAMAGE),'B'|CLR(GREEN),"bog thing","swamp slime","AXAXB?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+9,40,25,0,0,20,3,5,6,0,2,175,20,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_SPIRIT,M_MELEE_SPIRIT,M_NO_OP,M_SP_AV,MOBILE|HOSTILE|INTANGIBLE,pow2(NORMAL_DAMAGE)|pow2(FEAR)|pow2(SLEEP),'V'|CLR(GREY),"astral vampire","dead astral vampire","R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+10,100,40,0,60,3,1,5,10,75,0,175,2000,0,-1,-1,COMMON,M_NO_OP,M_MOVE_NORMAL,M_MELEE_FIRE,M_NO_OP,M_SP_LW,MOBILE|HOSTILE|SWIMMING|POISONOUS,pow2(FLAME),'W'|CLR(LIGHT_RED),"lava worm","dead lava worm","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+11,1,0,0,0,30,30,5,20,0,0,100,0,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_RANDOM,M_NO_OP,M_NO_OP,M_SP_MB,MOBILE|HOSTILE|INTANGIBLE,0,'m'|CLR(PURPLE),"manaburst","feeling of warmth","BX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+12,120,25,20,20,6,6,5,4,0,1,150,2000,0,-1,WEAPONID+8,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_FIRE,M_MELEE_POISON,M_SP_DEMON,MOBILE|HOSTILE|POISONOUS,pow2(FLAME)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'d'|CLR(LIGHT_RED),"outer circle demon","dead outer circle demon","L?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML5+13,40,15,10,30,8,8,5,6,0,1,100,20,0,-1,-1,COMMON,M_NO_OP,M_MOVE_SMART,M_MELEE_SPIRIT,M_NO_OP,M_SP_MIRROR,MOBILE|HOSTILE,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY),'m'|CLR(GREY),"mirrorshade","some broken glass","AXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+0,125,30,0,50,10,2,6,4,100,0,250,1,200,STICKID+7,-1,COMMON,M_TALK_SILENT,M_MOVE_NORMAL,M_MELEE_FIRE,M_STRIKE_FBALL,M_NO_OP,MOBILE|HOSTILE|FLYING,pow2(FLAME)|pow2(POISON)|pow2(ACID)|pow2(SLEEP),'F'|CLRS(WHITE,RED),"fire elemental","essence of fire elemental","AXAXAXRXRX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+1,125,25,0,20,10,2,6,2,100,0,250,1,200,CLOAKID+2,-1,COMMON,M_TALK_SILENT,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_SP_WHIRL,MOBILE|HOSTILE|FLYING|INTANGIBLE,pow2(ELECTRICITY)|pow2(POISON)|pow2(ACID)|pow2(SLEEP),'A'|CLRS(WHITE,BLUE),"air elemental","essence of air elemental","AXAXAXAXBXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+2,100,15,10,30,5,1,6,6,100,0,250,1,200,STICKID+14,-1,COMMON,M_TALK_SILENT,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|ONLYSWIM,pow2(COLD)|pow2(SLEEP),'W'|CLRS(WHITE,BLUE),"water elemental","essence of water elemental","AXAXBXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+3,200,20,25,100,5,1,6,15,100,0,250,1,200,CLOAKID+4,-1,COMMON,M_TALK_SILENT,M_MOVE_SPIRIT,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE,pow2(POISON)|pow2(SLEEP),'E'|CLRS(WHITE,BROWN),"earth elemental","essence of earth elemental","AXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+4,100,20,20,50,3,1,6,2,50,1,250,1000,100,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE,pow2(SLEEP),'b'|CLRS(YELLOW,BROWN),"bandersnatch","bandersnatch hide","AXAXAXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+5,100,15,20,50,5,1,6,3,50,5,300,100,1000,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_SPIRIT,M_NO_OP,M_SP_SPELL,MOBILE|HOSTILE,pow2(FLAME)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'L'|CLRS(BLACK,WHITE),"lich","lich's skeleton","A?A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+6,100,20,20,30,5,3,6,5,30,3,300,10,500,-1,WEAPONID+21,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_SP_SPELL,MOBILE|HOSTILE|SWIMMING,pow2(SLEEP),'T'|CLRS(LIGHT_GREEN,BLUE),"triton","dead triton","A?A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+7,100,0,20,0,10,3,6,3,0,5,200,10,0,-1,THINGID+2,COMMON,M_TALK_THIEF,M_MOVE_SMART,M_NO_OP,M_NO_OP,M_SP_THIEF,MOBILE|HOSTILE|GREEDY|SWIMMING,0,'@'|CLR(RED),"human","dead master thief","A?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+8,200,50,50,80,3,1,6,8,0,0,300,100000,0,-1,-1,COMMON,M_TALK_ANIMAL,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|SWIMMING,pow2(FEAR)|pow2(SLEEP),'T'|CLRS(GREEN,BROWN),"triceratops","dead triceratops","LX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+9,100,20,20,20,10,2,6,3,50,4,250,10,0,-1,WEAPONID+5,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_FBOLT,M_SP_ILLUSION,MOBILE|HOSTILE,pow2(FLAME)|pow2(FEAR)|pow2(SLEEP),'R'|CLRS(YELLOW,WHITE),"rakshasa","dead rakshasa","L?L?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+10,100,40,20,30,5,1,6,7,90,4,250,10,500,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_NORMAL,M_MELEE_POISON,M_STRIKE_FBALL,M_SP_DEMON,MOBILE|HOSTILE|SWIMMING,pow2(FLAME)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'S'|CLRS(GREEN,RED),"demon serpent","demon serpent's jewel","L?L?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+11,120,30,20,20,10,10,6,4,0,1,250,10,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_SP_ANGEL,MOBILE|FLYING,pow2(FEAR)|pow2(SLEEP),'a'|CLRS(YELLOW,WHITE),"angel","angel's gown","L?R?RX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML6+12,100,25,15,40,9,4,6,4,0,1,200,100,100,-1,-1,COMMON,M_TALK_NINJA,M_MOVE_NORMAL,M_MELEE_POISON,M_STRIKE_MISSILE,M_SP_SURPRISE,MOBILE|HOSTILE|M_INVISIBLE,pow2(POISON)|pow2(SLEEP),'n'|CLRS(BLACK,WHITE),"ninja (chunin)","dead ninja","A?A?R?R?R" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+0,300,30,5,120,3,3,7,15,100,0,400,500,50,RINGID+2,-1,COMMON,M_TALK_STUPID,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_SP_HUGE,MOBILE|HOSTILE|SWIMMING,pow2(ELECTRICITY),'B'|CLRS(BLACK,BROWN),"behemoth","behemoth's gonads","AHBXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+1,250,40,20,20,10,5,7,5,0,0,500,100,2000,-1,WEAPONID+24,COMMON,M_TALK_EVIL,M_MOVE_SPIRIT,M_MELEE_SPIRIT,M_NO_OP,M_SP_SPELL,MOBILE|HOSTILE|FLYING,pow2(COLD)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'N'|CLRS(BLACK,WHITE),"nazgul","nazgul's husk","A?A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+2,100,100,30,50,10,3,7,2,50,0,400,100,500,RINGID+6,-1,COMMON,M_TALK_SILENT,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_MOVE_SCAREDY,MOBILE|SWIMMING,pow2(POISON)|pow2(FEAR),'U'|CLRS(BLACK,WHITE),"unicorn","unicorn's horn","ACACB?B?B?B?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+3,150,30,20,50,10,3,7,3,50,0,400,100,0,-1,-1,COMMON,M_NO_OP,M_MOVE_NORMAL,M_MELEE_DISEASE,M_NO_OP,M_SP_SURPRISE,MOBILE|HOSTILE|HUNGRY|M_INVISIBLE|SWIMMING,pow2(FEAR),'r'|CLRS(BLACK,BROWN),"rodent of unusual size","dead R.O.U.S.","AXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+4,100,20,25,30,10,2,7,5,50,3,400,0,0,-1,-1,COMMON,M_NO_OP,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_SP_ILLUSION,MOBILE|HOSTILE|GREEDY,pow2(OTHER_MAGIC),'F'|CLRS(BLACK,WHITE),"illusory fiend","not much of anything","AXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+5,250,40,30,20,10,1,7,5,100,8,500,1500,2000,-1,WEAPONID+34,UNIQUE_MADE,M_TALK_EVIL,M_MOVE_NORMAL,M_MELEE_NORMAL,M_MELEE_COLD,M_SP_WYRM,MOBILE|HOSTILE|SWIMMING,pow2(COLD)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'W'|CLRS(GREY,RED),"Great Wyrm","The head of the Great Wyrm","AXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+6,150,30,30,20,10,1,7,1,100,8,350,1500,0,-1,WEAPONID+33,COMMON,M_NO_OP,M_MOVE_SMART,M_MELEE_FIRE,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|FLYING,pow2(FLAME)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'F'|CLRS(GREY,RED),"flame devil","dead flame devil","A?A?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+7,150,50,10,20,1,0,7,1,100,4,400,1500,0,-1,-1,COMMON,M_NO_OP,M_NO_OP,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,HOSTILE|HUNGRY,0,OPEN_DOOR,"lurker at the threshold","dead lurker","L?L?L?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+8,50,30,30,20,10,1,7,4,0,2,450,500,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_NORMAL,M_MELEE_SLEEP,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|FLYING,pow2(NORMAL_DAMAGE)|pow2(SLEEP),'S'|CLRS(YELLOW,BROWN),"sandman","mound of sand","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+9,50,40,10,10,10,10,7,2,0,5,350,50,0,-1,-1,COMMON,M_NO_OP,M_MOVE_SMART,M_MELEE_SLEEP,M_NO_OP,M_SP_MIRROR,MOBILE|HOSTILE|FLYING,pow2(OTHER_MAGIC),'m'|CLRS(RED,WHITE),"mirror master","shards of glass","AXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+10,150,30,30,20,10,1,7,4,90,2,450,500,0,-1,-1,COMMON,M_TALK_HUNGRY,M_MOVE_NORMAL,M_MELEE_POISON,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|FLYING,pow2(POISON)|pow2(FEAR),'G'|CLRS(GREY,GREEN),"elder etheric grue","dead elder etheric grue","AXAXAXL?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+11,150,50,40,60,3,3,7,8,90,6,380,500,0,-1,-1,COMMON,M_TALK_HUNGRY,M_MOVE_NORMAL,M_MELEE_POISON,M_NO_OP,M_SP_ACID_CLOUD,MOBILE|HOSTILE|HUNGRY|SWIMMING,pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'S'|CLRS(GREY,GREEN),"loathly serpent","dead loathly serpent","AXAXAXL?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+12,100,10,30,20,8,3,7,3,20,2,460,500,0,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_SCAREDY,M_MELEE_SPIRIT,M_NO_OP,M_SP_RAISE,MOBILE|HOSTILE,pow2(FEAR),'Z'|CLRS(BLACK,WHITE),"zombie overlord","extremely dead zombie overlord","L?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+13,50,30,30,2,13,1,7,1,30,0,250,50,0,-1,-1,COMMON,M_TALK_STUPID,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_MOVE_FLUTTER,MOBILE|HOSTILE|FLYING,0,'r'|CLRS(GREY,BROWN),"ricochet","dead ricochet","L?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML7+14,240,35,30,40,8,8,7,3,0,3,300,3000,0,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_FIRE,M_MELEE_SLEEP,M_SP_DEMON,MOBILE|HOSTILE|POISONOUS,pow2(FLAME)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'D'|CLRS(GREY,RED),"inner circle demon","dead inner circle demon","L?L?R?R?R?RXRXRX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+0,1,0,100,0,6,2,8,3,0,0,50,100,0,-1,-1,COMMON,M_TALK_GF,M_MOVE_RANDOM,M_NO_OP,M_NO_OP,M_NO_OP,MOBILE|FLYING,pow2(FLAME)|pow2(COLD)|pow2(SLEEP),'f'|CLRS(YELLOW,WHITE),"fairy","good fairy dust","B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+1,100,50,50,20,10,10,8,3,0,0,500,3,0,-1,-1,COMMON,M_TALK_EF,M_MOVE_RANDOM,M_NO_OP,M_NO_OP,M_NO_OP,MOBILE|FLYING|POISONOUS,pow2(FLAME)|pow2(COLD)|pow2(SLEEP),'f'|CLRS(YELLOW,WHITE),"fairy","evil fairy dust","B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+2,500,30,50,100,5,2,8,3,100,0,500,1000,0,-1,WEAPONID+23,COMMON,M_TALK_ROBOT,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_LBALL,M_SP_POISON_CLOUD,MOBILE|HOSTILE,pow2(ELECTRICITY)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'A'|CLRS(GREY,WHITE),"automatum major","automatum major components","A?A?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+3,500,50,30,75,20,1,8,5,100,7,750,500,1000,ARMORID+12,-1,COMMON,M_TALK_GREEDY,M_MOVE_NORMAL,M_MELEE_DRAGON,M_STRIKE_FBOLT,M_NO_OP,MOBILE|HOSTILE|HUNGRY|GREEDY|FLYING,pow2(FLAME)|pow2(POISON)|pow2(SLEEP),'D'|CLRS(GREY,RED),"dragon","dragon scales","A?A?A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+4,500,40,25,100,5,1,8,2,75,2,600,500,1000,WEAPONID+31,-1,COMMON,M_TALK_BURBLE,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY,pow2(POISON)|pow2(SLEEP),'J'|CLRS(BROWN,RED),"jabberwock","jabberwock's head","A?A?A?A?A?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+5,350,40,40,40,10,10,8,2,25,5,700,100,500,WEAPONID+24,-1,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_COLD,M_STRIKE_SNOWBALL,M_SP_DEMON,MOBILE|HOSTILE|HUNGRY,pow2(COLD)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'F'|CLRS(LIGHT_BLUE,WHITE),"frost demon lord","frost demon lord's sigil","A?A?A?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+6,350,35,30,40,10,4,8,2,25,0,700,100,100,-1,-1,COMMON,M_NO_OP,M_MOVE_NORMAL,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|HUNGRY|ONLYSWIM,pow2(COLD)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'T'|CLRS(YELLOW,BLUE),"tigershark","tigershark pelt","AXAXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+7,250,40,25,50,10,4,8,3,0,2,800,100,100,-1,-1,COMMON,M_TALK_NINJA,M_MOVE_NORMAL,M_MELEE_POISON,M_STRIKE_MISSILE,M_SP_SURPRISE,MOBILE|HOSTILE|M_INVISIBLE,pow2(POISON)|pow2(SLEEP),'n'|CLRS(BLACK,WHITE),"ninja (jonin)","dead ninja","A?A?R?R?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+8,250,30,40,30,10,4,8,3,0,3,500,10,75,RINGID+0,-1,COMMON,M_TALK_EVIL,M_MOVE_SPIRIT,M_MELEE_POISON,M_SP_SPELL,M_SP_BLACKOUT,MOBILE|HOSTILE|INTANGIBLE|M_INVISIBLE,pow2(NORMAL_DAMAGE)|pow2(POISON)|pow2(SLEEP),'S'|CLRS(BLACK,WHITE),"shadow slayer","shadow matrix","A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+9,250,30,30,30,10,4,8,6,0,3,700,10,75,-1,WEAPONID+13,COMMON,M_TALK_SILENT,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_SP_SPELL,MOBILE|HOSTILE,pow2(SLEEP),'@'|CLR(RED),"militant priest","dead militant priest","A?A?A?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+10,150,25,40,30,10,4,8,5,0,3,500,10,75,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_SMART,M_MELEE_SLEEP,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|M_INVISIBLE,pow2(SLEEP),'C'|CLRS(GREY,BROWN),"coma beast","dead coma beast","AXAXAXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML8+11,250,50,40,30,10,10,8,3,0,3,500,10,0,-1,-1,COMMON,M_TALK_SILENT,M_MOVE_SMART,M_MELEE_NORMAL,M_STRIKE_FBOLT,M_SP_ANGEL,MOBILE|FLYING,pow2(FLAME)|pow2(FEAR)|pow2(SLEEP),'A'|CLRS(YELLOW,WHITE),"high angel","high angel's robes","L?R?RXRX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML9+0,750,80,50,200,10,2,9,8,90,5,1000,500,2000,-1,WEAPONID+38,COMMON,M_TALK_GREEDY,M_MOVE_NORMAL,M_MELEE_NORMAL,M_STRIKE_MISSILE,M_SP_HUGE,MOBILE|HOSTILE|HUNGRY|GREEDY,pow2(COLD)|pow2(FEAR),'J'|CLRS(GREY,BROWN),"jotun","jotun's head","AHAHB?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML9+1,1000,50,30,40,20,2,9,4,40,0,750,100,200,CLOAKID+2,-1,COMMON,M_TALK_SILENT,M_MOVE_FLUTTER,M_MELEE_NORMAL,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|FLYING|M_INVISIBLE,pow2(ELECTRICITY),'i'|CLRS(BLACK,WHITE),"invisible slayer","dead slayer","AXAXAX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML9+2,700,50,32,50,5,2,9,3,80,4,1000,100,50,RINGID+6,-1,COMMON,M_TALK_GREEDY,M_MOVE_NORMAL,M_MELEE_POISON,M_NO_OP,M_NO_OP,MOBILE|HOSTILE|GREEDY|FLYING,pow2(FLAME)|pow2(POISON),'W'|CLRS(GREEN,RED),"king wyvern","king wyvern's sting","AXAXAXBXBX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML9+3,500,30,50,30,10,2,9,4,50,0,500,40,500,WEAPONID+33,-1,COMMON,M_NO_OP,M_MOVE_RANDOM,M_MELEE_NORMAL,M_NO_OP,M_SP_EXPLODE,MOBILE|HOSTILE|HUNGRY|FLYING|POISONOUS,pow2(FLAME),'d'|CLRS(BLACK,WHITE),"deathstar","deathstar's eye","BX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML9+4,250,20,25,25,5,5,9,4,50,4,1500,50,3000,-1,-1,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_NORMAL,M_SP_SPELL,M_SP_SPELL,MOBILE,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY),'T'|CLRS(YELLOW,WHITE),"high thaumaturgist","dead thaumaturgist","A?B?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML9+5,750,70,50,50,10,1,9,2,50,0,1000,1,200,CLOAKID+1,-1,COMMON,M_TALK_EVIL,M_MOVE_SPIRIT,M_MELEE_SPIRIT,M_MELEE_SPIRIT,M_SP_SURPRISE,MOBILE|HOSTILE|FLYING|M_INVISIBLE,pow2(POISON)|pow2(FEAR)|pow2(SLEEP),'V'|CLRS(BLACK,RED),"vampire lord","vampire dust","A?A?A?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML9+6,1000,100,50,50,20,20,9,2,100,5,1500,15,3000,-1,WEAPONID+34,COMMON,M_TALK_SILENT,M_MOVE_SMART,M_MELEE_NORMAL,M_MELEE_SLEEP,M_SP_ANGEL,MOBILE|FLYING,pow2(FLAME)|pow2(COLD)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP)|pow2(OTHER_MAGIC),'A'|CLRS(YELLOW,WHITE),"archangel","archangel's diadem","L?R?R?R?R?R?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML9+7,800,80,40,80,12,12,9,2,0,5,1200,4500,3000,-1,WEAPONID+24,COMMON,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_NORMAL,M_MELEE_NORMAL,M_SP_DEMON,MOBILE|HOSTILE|FLYING|POISONOUS,pow2(FLAME)|pow2(POISON)|pow2(FEAR)|pow2(SLEEP)|pow2(OTHER_MAGIC),'D'|CLRS(BLACK,RED),"demon prince","dead demon prince","LLLCLHRLRCRHRLRCRH" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+0,100,10,10,1,100,100,100,10,0,0,0,0,1,-1,WEAPONID+39,UNIQUE_MADE,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_DEATH,M_NO_OP,M_SP_DEATH,MOBILE|HOSTILE,pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(OTHER_MAGIC),'D'|CLRS(BLACK,WHITE),"Death","No way can you be seeing this!","AX" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+1,1000,0,20,0,3,3,10,5,50,0,10000,1000,250,STICKID+13,-1,UNIQUE_MADE,M_TALK_SILENT,M_MOVE_RANDOM,M_NO_OP,M_NO_OP,M_SP_EATER,MOBILE,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY)|pow2(POISON)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(OTHER_MAGIC)|pow2(THEFT)|pow2(GAZE)|pow2(INFECTION),'E'|CLRS(BLACK,WHITE),"The Eater of Magic","The Heart of the Eater of Magic","B?B?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+2,500,50,50,50,5,3,10,5,50,0,10000,1000,2000,-1,WEAPONID+34,UNIQUE_MADE,M_TALK_LB,M_MOVE_SMART,M_MELEE_NORMAL,M_NO_OP,M_SP_LAWBRINGER,MOBILE,pow2(NORMAL_DAMAGE),'L'|CLRS(BRIGHT_WHITE,BLUE),"The LawBringer","The LawBringer's Crown","A?A?B?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+3,2000,100,100,100,10,1,10,1,100,10,10000,1000,2000,ARMORID+12,-1,UNIQUE_MADE,M_TALK_EVIL,M_MOVE_NORMAL,M_MELEE_DRAGON,M_STRIKE_FBOLT,M_SP_DRAGONLORD,MOBILE|HOSTILE|FLYING,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY)|pow2(ACID),'D'|CLRS(BRIGHT_WHITE,RED),"The Dragon Lord","The Dragon Lord's Hide","A?A?A?A?A?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+4,3000,200,100,200,20,20,10,2,0,7,20000,1000,3000,-1,ARTIFACTID+23,UNIQUE_MADE,M_TALK_EVIL,M_MOVE_SPIRIT,M_MELEE_SPIRIT,M_MELEE_NORMAL,M_SP_DEMON,MOBILE|HOSTILE|INTANGIBLE|M_INVISIBLE,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY)|pow2(POISON)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(OTHER_MAGIC)|pow2(THEFT)|pow2(GAZE)|pow2(INFECTION),'D'|CLRS(GREY,RED),"The Demon Emperor","The Demon Emperor's Regalia","L?L?L?L?L?R?R?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+5,2000,200,100,200,5,1,10,12,0,0,5000,10000,1,-1,ARTIFACTID+4,UNIQUE_MADE,M_TALK_SILENT,M_MOVE_SPIRIT,M_MELEE_NORMAL,M_MELEE_NORMAL,M_SP_DE,MOBILE|INTANGIBLE,pow2(FLAME)|pow2(COLD)|pow2(POISON)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(OTHER_MAGIC)|pow2(THEFT)|pow2(GAZE)|pow2(INFECTION),'E'|CLRS(BROWN,WHITE),"The Elemental Lord of Earth","some dirt","A?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+6,1000,100,50,50,20,1,10,1,100,0,5000,0,1,-1,ARTIFACTID+3,UNIQUE_MADE,M_TALK_SILENT,M_MOVE_SPIRIT,M_MELEE_NORMAL,M_STRIKE_LBALL,M_SP_WHIRL,MOBILE|FLYING|INTANGIBLE|M_INVISIBLE,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY)|pow2(POISON)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(THEFT)|pow2(GAZE)|pow2(INFECTION),'A'|CLRS(LIGHT_BLUE,WHITE),"The Elemental Lord of Air","some air","A?A?A?A?A?A?A?A?A?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+7,1500,100,100,100,5,1,10,5,100,0,5000,10,1,-1,ARTIFACTID+1,UNIQUE_MADE,M_TALK_SILENT,M_MOVE_NORMAL,M_MELEE_NORMAL,M_STRIKE_SNOWBALL,M_NO_OP,MOBILE|ONLYSWIM,pow2(COLD)|pow2(ELECTRICITY)|pow2(POISON)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(OTHER_MAGIC)|pow2(THEFT)|pow2(GAZE)|pow2(INFECTION),'W'|CLRS(BLUE,WHITE),"The Elemental Lord of Water","some water","A?A?A?B?B?B?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+8,1500,200,100,300,10,1,10,3,100,0,5000,1000,1,-1,ARTIFACTID+2,UNIQUE_MADE,M_TALK_SILENT,M_MOVE_NORMAL,M_MELEE_FIRE,M_STRIKE_FBALL,M_NO_OP,MOBILE,pow2(FLAME)|pow2(ELECTRICITY)|pow2(POISON)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(OTHER_MAGIC)|pow2(THEFT)|pow2(GAZE)|pow2(INFECTION),'F'|CLRS(LIGHT_RED,WHITE),"The Elemental Lord of Fire","a spark","A?A?A?R?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+9,1000,200,200,200,20,20,10,2,0,10,10000,10000,1,-1,ARTIFACTID+0,UNIQUE_MADE,M_TALK_EVIL,M_MOVE_SMART,M_MELEE_MASTER,M_STRIKE_MASTER,M_SP_MASTER,MOBILE|FLYING|SWIMMING,pow2(NORMAL_DAMAGE)|pow2(COLD)|pow2(ELECTRICITY)|pow2(POISON)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(OTHER_MAGIC)|pow2(THEFT)|pow2(GAZE)|pow2(INFECTION),'M'|CLRS(PURPLE,WHITE),"The Elemental Master","A burning mound of bubbling mud","A?A?A?A?R?R?R?R?" },
monsters.h:    { NULL,true,0,0,0,0,0,ML10+10,1150,90,90,48,10,20,10,2,0,7,6000,40,40,-1,ARTIFACTID+25,UNIQUE_MADE,M_TALK_MAHARAJA,M_MOVE_SMART,M_MELEE_NORMAL,M_MELEE_NORMAL,M_SP_DEMON,MOBILE|HOSTILE,pow2(FLAME)|pow2(COLD)|pow2(ELECTRICITY)|pow2(ACID)|pow2(FEAR)|pow2(SLEEP)|pow2(NEGENERGY)|pow2(THEFT)|pow2(INFECTION),'D'|CLRS(GREY,RED),"The Maharaja","The Maharaja's Skull","L?L?B?B?R?R?R?" }
move.cpp:        Player.alignment -= 50;
move.cpp:    print1("Very clever -- walking into a pool of lava...");
move.cpp:    p_damage(random_range(100),FLAME,"self-immolation");
move.cpp:        strategic_teleport(-1);
move.cpp:            if (Player.alignment > -10)
move.cpp:                print1("The All-In-One must have taken pity on you.");
move.cpp:                change_level(Level->depth,Level->depth+1,false);
move.cpp:                Player.alignment -= 50;
move.cpp:            if (Level->depth+i>MaxDungeonLevels) {
move.cpp:                change_level(Level->depth,Level->depth+i,false);
move.cpp:    Level->site[Player.x][Player.y].locchar = FLOOR;
move.cpp:    Level->site[Player.x][Player.y].p_locf = L_NO_OP;
move.cpp:        if (response == 'u' && Level->depth - levelnum < 1) {
move.cpp:            distance = levelnum - Level->depth;
move.cpp:        else if (response == 'd' && Level->depth + levelnum > MaxDungeonLevels) {
move.cpp:            levelnum = MaxDungeonLevels - Level->depth;
move.cpp:        change_level(Level->depth,
move.cpp:                      Level->depth+levelnum :
move.cpp:                      Level->depth-levelnum),
move.cpp:        augment(-1);
move.cpp:            Player.possessions[O_WEAPON_HAND]->plus += random_range(10)+1;
move.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
move.cpp:    Level->site[Player.x][Player.y].p_locf = L_TRAP_PIT;
move.cpp:    int screwup = random_range(100) - (Player.agi + Player.level);
move.cpp:    for (i=max(Player.x-5,0); i<min(Player.x+6,Level->level_width); i++)
move.cpp:        for(j=max(Player.y-5,0); j<min(Player.y+6,Level->level_length); j++) {
move.cpp:            if ((Level->site[i][j].p_locf == L_PORTCULLIS) &&
move.cpp:                    (Level->site[i][j].locchar != PORTCULLIS)) {
move.cpp:                Level->site[i][j].locchar = PORTCULLIS;
move.cpp:    for(j=0; j<Level->level_length; j++)
move.cpp:        for(i=0; i<Level->level_width; i++) {
move.cpp:            if (Level->site[i][j].p_locf == L_DROP_EVERY_PORTCULLIS) {
move.cpp:                Level->site[i][j].p_locf = L_NO_OP;
move.cpp:            else if ((Level->site[i][j].p_locf == L_PORTCULLIS) &&
move.cpp:                     (Level->site[i][j].locchar != PORTCULLIS)) {
move.cpp:                Level->site[i][j].locchar = PORTCULLIS;
move.cpp:    for(j=0; j<Level->level_length; j++)
move.cpp:        for(i=0; i<Level->level_width; i++) {
move.cpp:            if (Level->site[i][j].locchar == PORTCULLIS) {
move.cpp:                Level->site[i][j].locchar = FLOOR;
move.cpp:    if (Level->mlist) {
move.cpp:        print3("'Bye-bye,' he says... 'We'll meet again.'");
move.cpp:         * but I wasn't offered a choice -- the man pages don't document any other
move.cpp:            Player.pow -= (15+random_range(15));
move.cpp:                Level->site[Player.x][Player.y].locchar = FLOOR;
move.cpp:                Level->site[Player.x][Player.y].p_locf = L_NO_OP;
move.cpp:    else print2("You flinch away from the all-consuming fire.");
move.cpp:            Player.con -= (15+random_range(15));
move.cpp:                Level->site[Player.x][Player.y].locchar = FLOOR;
move.cpp:                Level->site[Player.x][Player.y].p_locf = L_NO_OP;
move.cpp:            Player.iq -= (random_range(15)+15);
move.cpp:                Level->site[Player.x][Player.y].locchar = FLOOR;
move.cpp:                Level->site[Player.x][Player.y].p_locf = L_NO_OP;
move.cpp:    if (find_item(&o,OB_SALT_WATER,-1))
move.cpp:            Player.str -= (15+random_range(15));
move.cpp:                Level->site[Player.x][Player.y].locchar = FLOOR;
move.cpp:                Level->site[Player.x][Player.y].p_locf = L_NO_OP;
move.cpp:    for(j=0; j<Level->level_length; j++)
move.cpp:        for(i=0; i<Level->level_width; i++)
move.cpp:            if ((Level->site[i][j].locchar == WATER) ||
move.cpp:                    (Level->site[i][j].locchar == HEDGE) ||
move.cpp:                    (Level->site[i][j].locchar == WHIRLWIND) ||
move.cpp:                    (Level->site[i][j].locchar == FIRE))
move.cpp:        if (Level->mlist == NULL) {
move.cpp:    Level->site[Player.x][Player.y].p_locf = L_NO_OP;
move.cpp:    Level->site[Player.x][Player.y].p_locf = L_NO_OP;
move.cpp:    Level->site[Player.x][Player.y].p_locf = L_NO_OP;
move.cpp:        if (! find_item(&o,OB_SCEPTRE,-1)) {
move.cpp:            print1("The throne emits an eerie violet-black radiance.");
move.cpp:            dispel(-1);
move.cpp:                        print2("They appear to describe some high-powered spell.");
move.cpp:                    Level->site[Player.x][Player.y].locchar = RUBBLE;
move.cpp:                    Level->site[Player.x][Player.y].p_locf = L_RUBBLE;
move.cpp:                    if (find_and_remove_item(OB_SCEPTRE,-1)) {
move.cpp:        if (stonecheck(-1)) {
move.cpp:                Player.xp -= Player.xp/4;
move.cpp:    print1("This is a stele carved of blueish-green feldspar.");
move.cpp:    print1("is attracted to the bulk of Star Peak to the North-East.");
move.cpp:                Player.possessions[i]->blessing = 0;
move.cpp:                Player.possessions[i]->plus = 0;
move.cpp:                Player.possessions[i]->usef = I_NOTHING;
move.cpp:            print2("You feel your life-force being sucked away!");
move.cpp:                Player.hp -= sacrifice;
move.cpp:                Player.maxhp -= sacrifice/2;
move.cpp:                    p_death("self-sacrifice");
movef.cpp:    if ((Level->site[x][y].p_locf >= CITYSITEBASE) &&
movef.cpp:            (Level->site[x][y].p_locf < CITYSITEBASE+NUMCITYSITES))
movef.cpp:        CitySiteList[Level->site[x][y].p_locf - CITYSITEBASE][0] = true;
movef.cpp:    switch(Level->site[x][y].p_locf) {
movef.cpp:        if (Level->site[x][y].locchar == FLOOR)
movef.cpp:            print2("Commandant Sonder's Rampart-fried Lyzzard partes. Open 24 hrs.");
movef.cpp:            print2("The Centaur and Nymph -- J. Riley, prop.");
movef.cpp:        print2("Rampart City Cemetary. Closed -- Full.");
movef.cpp:        print2("Rampart Botanical Gardens---Do not deface statues.");
movef.cpp:        print2("Rampart City Gaol -- always room for more.");
newrand.cpp:/* A C-program for MT19937: Integer     version                   */
newrand.cpp:/* which is uniformly distributed among 0 to 2^32-1  for each     */
newrand.cpp:/* called once. (seed is any 32-bit integer except for 0).        */
newrand.cpp:/* Topher Cooper and Marc Rieffel in July-Aug. 1997.              */
newrand.cpp:/* 02111-1307  USA                                                 */
newrand.cpp:#define UPPER_MASK 0x80000000 /* most significant w-r bits */
newrand.cpp:        mt[mti] = (69069 * mt[mti-1]) & 0xffffffff;
newrand.cpp:        for (kk=0; kk<N-M; kk++) {
newrand.cpp:        for (; kk<N-1; kk++) {
newrand.cpp:            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
newrand.cpp:        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
newrand.cpp:        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];
Object.cpp:    id = -1;
Object.cpp:    return (id == -1 ?
Object.cpp:    return id == -1;
objects.h:    Object( THINGID+17,10,0,0,0,0,89,1,3,30,0,0,0,0,COMMON,I_TRAP,0,THING,"spring-loaded tube","dart-trap component","dart-trap component" ),
objects.h:    Object( THINGID+18,10,0,0,0,0,98,1,3,30,0,0,0,0,COMMON,I_TRAP,0,THING,"pressurized cannister","acid-trap component","acid-trap component" ),
objects.h:    Object( THINGID+20,10,0,0,0,0,94,1,3,30,0,0,0,0,COMMON,I_TRAP,0,THING,"mound of powdered aluminum","fire-trap component","fire-trap component" ),
objects.h:    Object( THINGID+21,10,0,0,0,0,95,1,3,30,0,0,0,0,COMMON,I_TRAP,0,THING,"powerful rune","teleport-trap component","teleport-trap component" ),
objects.h:    Object( THINGID+22,10,0,0,0,0,97,1,3,30,0,0,0,0,COMMON,I_TRAP,0,THING,"pressurized cannister","sleepgas-trap component","sleepgas-trap component" ),
objects.h:    Object( THINGID+23,10,0,0,0,0,96,1,3,30,0,0,0,0,COMMON,I_TRAP,0,THING,"powerful rune","disintegration-trap component","disintegration-trap component" ),
objects.h:    Object( THINGID+24,10,0,0,0,0,100,1,3,30,0,0,0,0,COMMON,I_TRAP,0,THING,"dark fabric patch","abyss-trap component","abyss-trap component" ),
objects.h:    Object( THINGID+25,10,0,0,0,0,99,1,3,30,0,0,0,0,COMMON,I_TRAP,0,THING,"powerful rune","manadrain-trap component","manadrain-trap component" ),
objects.h:    /*Object( 172,1,0,0,0,0,0,1,10,100,0,0,0,0,COMMON,I_PERM_KNOWLEDGE,0,RING,"?","ring of self-knowledge","ring of delusion" ),*/
objects.h:    Object( THINGID+26,1,0,0,0,0,0,1,10,100,0,0,0,0,COMMON,I_PERM_KNOWLEDGE,0,THING,"small mirror","mirror of self-knowledge","mirror of delusion" ),
objects.h:    Object( THINGID+29,2,0,0,0,0,0,1,10,1,0,0,0,0,COMMON,I_NO_OP,1,THING,"plastic card with square gold patch","pre-paid card","pre-paid card"),
objects.h:    Object( FOODID+7,20,0,0,0,0,-1,1,0,25,0,0,0,0,COMMON,I_POISON_FOOD,1,FOOD,"food ration","poisoned ration","poisoned ration" ),
objects.h:    Object( FOODID+10,2,0,0,0,0,6,1,0,7,0,0,0,0,COMMON,I_FOOD,2,FOOD,"brown bag with strange ideograms","hunan take-out","hunan take-out" ),
objects.h:    Object( FOODID+12,2,0,0,0,0,3,1,0,3,0,0,0,0,COMMON,I_FOOD,2,FOOD,"squiggly orange spirals","cheese-doodles","cheese-doodles" ),
objects.h:    Object( FOODID+13,2,0,0,0,0,4,1,0,3,0,0,0,0,COMMON,I_FOOD,2,FOOD,"sweet nutty-smelling disks","pecan twirls","pecan_twirls" ),
objects.h:    Object( SCROLLID+16,5,0,0,0,0,0,1,1,10,0,0,0,0,COMMON,I_KNOWLEDGE,1,SCROLL,"?","scroll of self-knowledge","scroll of delusion" ),
objects.h:    Object( SCROLLID+20,5,0,0,0,0,0,1,1,250,0,0,0,0,COMMON,I_DISPEL,3,SCROLL,"?","scroll of dispelling","scroll of self-dispelling" ),
objects.h:    Object( POTIONID+8,20,-1,0,0,0,0,1,5,1500,0,0,0,0,COMMON,I_AZOTH,7,POTION,"mercury","Azoth","mercury" ),
objects.h:    Object( WEAPONID+5,75,0,0,20,7,0,1,15,400,0,0,0,CUTTING,COMMON,I_NORMAL_WEAPON,5,WEAPON,"great-sword","great-sword","great-sword" ),
objects.h:    Object( WEAPONID+10,25,0,0,8,10,0,1,15,50,0,0,0,CUTTING,COMMON,I_NORMAL_WEAPON,1,WEAPON,"hand-axe","hand-axe","hand-axe" ),
objects.h:    Object( WEAPONID+11,50,0,0,12,8,0,1,15,100,0,0,0,CUTTING,COMMON,I_NORMAL_WEAPON,2,WEAPON,"battle-axe","battle-axe","battle-axe" ),
objects.h:    Object( WEAPONID+12,100,0,0,24,7,0,1,15,200,0,0,0,CUTTING,COMMON,I_NORMAL_WEAPON,5,WEAPON,"great-axe","great-axe","great-axe" ),
objects.h:    Object( WEAPONID+14,50,0,0,14,6,0,1,15,60,0,0,0,STRIKING,COMMON,I_NORMAL_WEAPON,2,WEAPON,"war-hammer","war-hammer","war-hammer" ),
objects.h:    Object( WEAPONID+15,60,0,0,16,7,0,1,15,150,0,0,0,STRIKING,COMMON,I_NORMAL_WEAPON,5,WEAPON,"morning-star","morning-star","morning-star" ),
objects.h:    Object( WEAPONID+24,500,8,0,16,8,1003,1,15,1000,0,0,-8,CUTTING,COMMON,I_DEMONBLADE,9,WEAPON,"bastard sword","Demonblade","Demonblade" ),
objects.h:    Object( WEAPONID+31,40,5,0,12,9,1008,1,15,3000,0,0,0,CUTTING,COMMON,I_NORMAL_WEAPON,7,WEAPON,"broad sword","vorpal sword","sword of self-mutilation" ),
objects.h:    Object( WEAPONID+32,100,7,0,20,7,1009,1,15,5000,0,0,-7,CUTTING,COMMON,I_DESECRATE,9,WEAPON,"great-sword","Desecrator","Desecrator" ),
objects.h:    Object( WEAPONID+33,60,7,0,16,7,1010,1,15,2000,0,0,0,STRIKING,COMMON,I_PERM_FIRE_RESIST,6,WEAPON,"morning-star","firestar","firestar" ),
objects.h:    Object( WEAPONID+36,500,6,0,32,6,0,1,15,2000,0,0,0,CUTTING,UNIQUE_MADE,I_NORMAL_WEAPON,7,WEAPON,"great-axe","Goblins' Hewer","Goblins' Hewer" ),
objects.h:    Object( WEAPONID+37,100,20,0,30,10,0,1,15,500,0,0,-10,CUTTING,COMMON,I_NORMAL_WEAPON,6,WEAPON,"scythe","scythe of slicing","scythe of slicing" ),
objects.h:    Object( WEAPONID+38,250,0,0,50,-10,0,1,15,100,0,0,0,STRIKING,COMMON,I_NORMAL_WEAPON,5,WEAPON,"giant club","giant club","giant club" ),
objects.h:    Object( ARMORID+16,100,5,0,5,0,0,1,20,2000,0,0,-9,0,COMMON,I_PERM_ENERGY_RESIST,3,ARMOR,"demonhide armor","demonhide armor","demonhide armor" ),
objects.h:    Object( RINGID+1,1,0,0,0,0,0,1,10,1,0,0,-1,0,COMMON,I_PERM_BURDEN,0,RING,"?","ring of burden","ring of burden" ),
objects.h:    /*Object( RINGID+172,1,0,0,0,0,0,1,10,100,0,0,0,0,COMMON,I_PERM_KNOWLEDGE,0,RING,"?","ring of self-knowledge","ring of delusion" ),*/
objects.h:    Object( STICKID+13,80,0,0,0,0,0,1,10,750,0,0,0,0,COMMON,I_DISPEL,6,STICK,"?","staff of dispelling","staff of self-dispelling" ),
objects.h:    Object( ARTIFACTID+5,25,0,0,0,0,0,1,15,100,0,0,0,0,COMMON,I_ORBDEAD,1,ARTIFACT,"Black Orb","Burnt-out Orb","Burnt-out Orb" ),
objects.h:    Object( ARTIFACTID+7,25,0,0,0,0,0,1,15,1000,0,0,0,0,COMMON,I_ANTIOCH,5,ARTIFACT,"Metal Pineapple","Holy Hand-Grenade of Antioch","Holy Hand-Grenade of Antioch" ),
omega.cpp:/* this file includes main() and some top-level functions */
omega.cpp:int DG_debug_flag = 0; /* debug flag -- set by -d commandline option */
omega.cpp:/* locations of city sites [0] - found, [1] - x, [2] - y */
omega.cpp:int Current_Dungeon= -1;              /* What is Dungeon now */
omega.cpp:{ { 1,1,-1,-1,1,-1,0,0,0} , { 1,-1,1,-1,0,0,1,-1,0 } };
omega.cpp:int SymbolUseHour= -1;                /* holy symbol use marker */
omega.cpp:int SymbolUseDay= -1;                /* holy symbol use marker */
omega.cpp:int ViewHour= -1;                     /* crystal ball use marker */
omega.cpp:int ViewDay= -1;                     /* crystal ball use marker */
omega.cpp:int ZapHour= -1;                      /* staff of enchantment use marker */
omega.cpp:int ZapDay= -1;                      /* staff of enchantment use marker */
omega.cpp:int HelmHour= -1;                     /* helm of teleportation use marker*/
omega.cpp:int HelmDay= -1;                     /* helm of teleportation use marker*/
omega.cpp:int LastDay= -1;                      /* DPW date of dole */
omega.cpp:int LastFreeGymDay = -1;              // Date of last free gym session
omega.cpp:int LastFreeYogaDay = -1;              /* Last free gifted Yoga session */
omega.cpp:int RitualHour= -1;                   /* last use of ritual magic */
omega.cpp:int RitualRoom= -1;                   /* last room of ritual magic */
omega.cpp:int tavern_hinthour = -1;
omega.cpp:/* environment is the environment about to be generated, or -1 for the first */
omega.cpp:/* time, or -2 if we want to restore the random number point */
OmegaRPG.cpp:    printf("Usage: omega [-shqd] [savefile]\n");
OmegaRPG.cpp:    printf("Usage: omega [-shq] [savefile]\n");
OmegaRPG.cpp:    printf("  -s  Display high score list only\n");
OmegaRPG.cpp:    printf("  -h  Display this message\n");
OmegaRPG.cpp:    printf("  -q  Quick launch (skip title and high score list)\n");
OmegaRPG.cpp:    printf("  -d  Enable debug mode\n");
OmegaRPG.cpp:    if (filecheck() == 0) exit(-1);
OmegaRPG.cpp:    if (this->ShowTitle()) {
OmegaRPG.cpp:    if (this->ShowScores() || this->ScoresOnly()) {
OmegaRPG.cpp:    if (this->ScoresOnly()) {
OmegaRPG.cpp:    if (this->Continuing())
OmegaRPG.cpp:        game_restore(this->SaveFilename());
OmegaRPG.cpp:        this->Continuing(initplayer()); /* RM: 04-19-2000 loading patch */
OmegaRPG.cpp:        this->SaveFilename(Player.name);
OmegaRPG.cpp:    if (!this->Continuing())
OmegaRPG.cpp:        init_world();  /* RM: 04-19-2000 loading patch */
OmegaRPG.cpp:        showroom(Level->site[Player.x][Player.y].roomnumber);
OmegaRPG.cpp:    if (!this->Continuing())
pdcurses.h:/*----------------------------------------------------------------------*
pdcurses.h: *----------------------------------------------------------------------*/
pdcurses.h:/*man-start**************************************************************
pdcurses.h:    PDC_WIDE        True if building wide-character support.
pdcurses.h:    PDCURSES        Enables access to PDCurses-only routines.
pdcurses.h:**man-end****************************************************************/
pdcurses.h:#define PDCURSES        1      /* PDCurses-only routines */
pdcurses.h:/*----------------------------------------------------------------------*/
pdcurses.h:/*----------------------------------------------------------------------
pdcurses.h:# define ERR (-1)
pdcurses.h:/*----------------------------------------------------------------------
pdcurses.h:typedef unsigned long chtype;  /* 16-bit attr + 16-bit char */
pdcurses.h:typedef unsigned short chtype; /* 8-bit attr + 8-bit char */
pdcurses.h:/*----------------------------------------------------------------------
pdcurses.h: *  PDCurses Mouse Interface -- SYSVR4, with extensions
pdcurses.h: *                                 1 <- button 1 has changed
pdcurses.h: *                                10 <- button 2 has changed
pdcurses.h: *                               100 <- button 3 has changed
pdcurses.h: *                              1000 <- mouse has moved
pdcurses.h: *                             10000 <- mouse position report
pdcurses.h: *                            100000 <- mouse wheel up
pdcurses.h: *                           1000000 <- mouse wheel down
pdcurses.h:#define BUTTON_CHANGED(x)       (Mouse_status.changes & (1 << ((x) - 1)))
pdcurses.h:#define BUTTON_STATUS(x)        (Mouse_status.button[(x) - 1])
pdcurses.h:/* mouse bit-masks */
pdcurses.h:/* For the ncurses-compatible functions only, BUTTON4_PRESSED and 
pdcurses.h:/*----------------------------------------------------------------------
pdcurses.h:    int   _cury;          /* current pseudo-cursor */
pdcurses.h:/* Avoid using the SCREEN struct directly -- use the corresponding 
pdcurses.h:    bool  autocr;         /* if cr -> lf */
pdcurses.h:    short line_color;     /* color of line attributes - default -1 */
pdcurses.h:/*----------------------------------------------------------------------
pdcurses.h:/*man-start**************************************************************
pdcurses.h:The following is the structure of a win->_attrs chtype:
pdcurses.h:-------------------------------------------------
pdcurses.h:-------------------------------------------------
pdcurses.h:The available non-color attributes are bold, reverse and blink. Others 
pdcurses.h:physical colors (defined in color.c) -- 32 foreground/background color 
pdcurses.h:----------------------------------------------------------------------------
pdcurses.h:----------------------------------------------------------------------------
pdcurses.h:The available non-color attributes are bold, underline, invisible, 
pdcurses.h:right-line, left-line, protect, reverse and blink. 256 color pairs (8 
pdcurses.h:**man-end****************************************************************/
pdcurses.h:/* For use with attr_t -- X/Open says, "these shall be distinct", so 
pdcurses.h:   this is a non-conforming implementation. */
pdcurses.h:/* 'w' = 32-bit chtype; acs_map[] index | A_ALTCHARSET
pdcurses.h:   'n' = 16-bit chtype; it gets the fallback set because no bit is 
pdcurses.h:/* VT100-compatible symbols -- box chars */
pdcurses.h:#define ACS_HLINE     ACS_PICK('q', '-')
pdcurses.h:/* VT100-compatible symbols -- other */
pdcurses.h:#define ACS_S1        ACS_PICK('o', '-')
pdcurses.h:/* Teletype 5410v1 symbols -- these are defined in SysV curses, but
pdcurses.h:   are not well-supported by most terminals. Stick to VT100 characters
pdcurses.h:#define ACS_UARROW    ACS_PICK('-', '^')
pdcurses.h:/* That goes double for these -- undocumented SysV symbols. Don't use
pdcurses.h:#define ACS_S3        ACS_PICK('p', '-')
pdcurses.h:#define ACS_S7        ACS_PICK('r', '-')
pdcurses.h:# define WACS_UARROW   (&(acs_map['-']))
pdcurses.h:/*----------------------------------------------------------------------
pdcurses.h:/* PDCurses-specific key definitions -- PC only */
pdcurses.h:#define CTL_LEFT      0x1bb  /* Control-Left-Arrow */
pdcurses.h:#define CTL_PADENTER  0x1cc  /* ctl-enter on keypad */
pdcurses.h:#define ALT_PADENTER  0x1cd  /* alt-enter on keypad */
pdcurses.h:#define CTL_PADSTOP   0x1d2  /* ctl-stop on keypad */
pdcurses.h:#define CTL_PADCENTER 0x1d3  /* ctl-enter on keypad */
pdcurses.h:#define CTL_PADPLUS   0x1d4  /* ctl-plus on keypad */
pdcurses.h:#define CTL_PADMINUS  0x1d5  /* ctl-minus on keypad */
pdcurses.h:#define CTL_PADSLASH  0x1d6  /* ctl-slash on keypad */
pdcurses.h:#define CTL_PADSTAR   0x1d7  /* ctl-star on keypad */
pdcurses.h:#define ALT_PADPLUS   0x1d8  /* alt-plus on keypad */
pdcurses.h:#define ALT_PADMINUS  0x1d9  /* alt-minus on keypad */
pdcurses.h:#define ALT_PADSLASH  0x1da  /* alt-slash on keypad */
pdcurses.h:#define ALT_PADSTAR   0x1db  /* alt-star on keypad */
pdcurses.h:#define ALT_PADSTOP   0x1dc  /* alt-stop on keypad */
pdcurses.h:#define CTL_INS       0x1dd  /* ctl-insert */
pdcurses.h:#define ALT_DEL       0x1de  /* alt-delete */
pdcurses.h:#define ALT_INS       0x1df  /* alt-insert */
pdcurses.h:#define CTL_UP        0x1e0  /* ctl-up arrow */
pdcurses.h:#define CTL_DOWN      0x1e1  /* ctl-down arrow */
pdcurses.h:#define CTL_TAB       0x1e2  /* ctl-tab */
pdcurses.h:#define ALT_UP        0x1ea  /* alt-up arrow */
pdcurses.h:#define ALT_DOWN      0x1eb  /* alt-down arrow */
pdcurses.h:#define ALT_RIGHT     0x1ec  /* alt-right arrow */
pdcurses.h:#define ALT_LEFT      0x1ed  /* alt-left arrow */
pdcurses.h:#define ALT_ENTER     0x1ee  /* alt-enter */
pdcurses.h:#define ALT_ESC       0x1ef  /* alt-escape */
pdcurses.h:#define ALT_BQUOTE    0x1f0  /* alt-back quote */
pdcurses.h:#define ALT_LBRACKET  0x1f1  /* alt-left bracket */
pdcurses.h:#define ALT_RBRACKET  0x1f2  /* alt-right bracket */
pdcurses.h:#define ALT_SEMICOLON 0x1f3  /* alt-semi-colon */
pdcurses.h:#define ALT_FQUOTE    0x1f4  /* alt-forward quote */
pdcurses.h:#define ALT_COMMA     0x1f5  /* alt-comma */
pdcurses.h:#define ALT_STOP      0x1f6  /* alt-stop */
pdcurses.h:#define ALT_FSLASH    0x1f7  /* alt-forward slash */
pdcurses.h:#define ALT_BKSP      0x1f8  /* alt-backspace */
pdcurses.h:#define CTL_BKSP      0x1f9  /* ctl-backspace */
pdcurses.h:#define CTL_PAD0      0x1fb  /* ctl-keypad 0 */
pdcurses.h:#define ALT_PAD0      0x205  /* alt-keypad 0 */
pdcurses.h:#define CTL_DEL       0x20f  /* clt-delete */
pdcurses.h:#define ALT_BSLASH    0x210  /* alt-back slash */
pdcurses.h:#define CTL_ENTER     0x211  /* ctl-enter */
pdcurses.h:#define SHF_PADENTER  0x212  /* shift-enter on keypad */
pdcurses.h:#define SHF_PADSLASH  0x213  /* shift-slash on keypad */
pdcurses.h:#define SHF_PADSTAR   0x214  /* shift-star  on keypad */
pdcurses.h:#define SHF_PADPLUS   0x215  /* shift-plus  on keypad */
pdcurses.h:#define SHF_PADMINUS  0x216  /* shift-minus on keypad */
pdcurses.h:#define SHF_UP        0x217  /* shift-up on keypad */
pdcurses.h:#define SHF_DOWN      0x218  /* shift-down on keypad */
pdcurses.h:#define SHF_IC        0x219  /* shift-insert on keypad */
pdcurses.h:#define SHF_DC        0x21a  /* shift-delete on keypad */
pdcurses.h:#define KEY_SHIFT_L   0x21c  /* Left-shift */
pdcurses.h:#define KEY_SHIFT_R   0x21d  /* Right-shift */
pdcurses.h:#define KEY_CONTROL_L 0x21e  /* Left-control */
pdcurses.h:#define KEY_CONTROL_R 0x21f  /* Right-control */
pdcurses.h:#define KEY_ALT_L     0x220  /* Left-alt */
pdcurses.h:#define KEY_ALT_R     0x221  /* Right-alt */
pdcurses.h:/*----------------------------------------------------------------------
pdcurses.h:/* Wide-character functions */
pdcurses.h:/* Quasi-standard */
pdcurses.h:#define getsyx(y, x)       { if (curscr->_leaveit) (y)=(x)=-1; \
pdump.cpp:    "Ex-gladiator",
pdump.cpp:    if ( !dump( dumpfile, "-- Possessions (Carried) --\n\n", false ) )
pdump.cpp:        if ( !dump( dumpfile, "-- Possessions (In Pack) --\n\n", false ) )
pdump.cpp:        if ( !dump( dumpfile, "-- Possessions (In Condo) --\n\n", false ) )
pdump.cpp:        for( ol = Condoitems; ol; ol = ol->next )
pdump.cpp:            sprintf( dump_buf, "%s\n", itemid( ol->thing ) );
pdump.cpp:    if ( !dump( dumpfile, "-- Current Ranks --\n\n", false ) )
pdump.cpp:            sprintf( cp, "%d opponents defeated\n", Arena_Opponent - 3 );
pdump.cpp:        sprintf( cp, "%d%s quest completed\n", Player.rank[ NOBILITY ] - 1,
pdump.cpp:                 ordinal( Player.rank[ NOBILITY ] - 1 ) );
pdump.cpp:    if (( dump_col + slen ) > ( 80 - col_width ))
pdump.cpp:    if ( !dump( dumpfile, "-- Current Stati --\n\n", false ) )
pdump.cpp:    if ( !dump( dumpfile, "-- Current Immunities --\n\n", false ) )
pdump.cpp:        if ( !dump( dumpfile, "\n-- Cheats --\n\n", false ) )
pdump.cpp:      Player.str, Player.maxstr, &curcol, 26 - curcol, spaces,
pdump.cpp:      Player.hp,  Player.maxhp,  &curcol, 57 - curcol, spaces,
pdump.cpp:    sprintf( cp, "Exp      : %-10ld          Armor   : %d\n", Player.xp,  Player.absorption );
pdump.cpp:    sprintf( cp, "Carry    : %-10d          Speed   : %d.%d\n",
pdump.cpp:    for( account = bank; account; account = account->next_account )
pdump.cpp:        if ( account->player )
pdump.cpp:            total_balance += account->balance;
pdump.cpp:    "Neutral-",
priest.cpp:    else deity = Level->site[Player.x][Player.y].aux;
priest.cpp:                        Player.xp -= (Player.xp/4);
priest.cpp:                        dispel(-1);
priest.cpp:                        p_damage(Player.hp-1,UNSTOPPABLE,"a god's pique");
priest.cpp:                        if (Player.possessions[i]->used) {
priest.cpp:                            Player.possessions[i]->used = false;
priest.cpp:                            Player.possessions[i]->blessing =
priest.cpp:                                -1 - abs(Player.possessions[i]->blessing);
priest.cpp:                            Player.possessions[i]->used = true;
priest.cpp:                        else Player.possessions[i]->blessing =
priest.cpp:                                -1 - abs(Player.possessions[i]->blessing);
priest.cpp:        Player.pow--;
priest.cpp:        Player.maxpow--;
priest.cpp:                                (Player.possessions[i]->blessing > -1))
priest.cpp:            else Player.alignment -= 40;
priest.cpp:            Level->site[Player.x][Player.y].locchar = FLOOR;
priest.cpp:            Level->site[Player.x][Player.y].p_locf = L_NO_OP;
priest.cpp:            Player.xp -= Player.level*Player.level;
priest.cpp:        if (find_item(&o,OB_SYMBOL_SET,-1))
priest.cpp:        if (find_item(&o,OB_SYMBOL_ODIN,-1))
priest.cpp:        if (find_item(&o,OB_SYMBOL_HECATE,-1))
priest.cpp:        if (find_item(&o,OB_SYMBOL_ATHENA,-1))
priest.cpp:        if (find_item(&o,OB_SYMBOL_ODIN,-1))
priest.cpp:        else if (find_item(&o,OB_SYMBOL_SET,-1))
priest.cpp:        else if (find_item(&o,OB_SYMBOL_ATHENA,-1))
priest.cpp:        else if (find_item(&o,OB_SYMBOL_HECATE,-1))
priest.cpp:        if (find_item(&o,OB_SYMBOL_DESTINY,-1))
priest.cpp:    print1("A full-scale heavenly choir chants 'Hallelujah' all around you!");
priest.cpp:    o->known = 2;
priest.cpp:    o->charge = 17; /* random hack to convey bit that symbol is functional */
save.cpp:                slashpos--)
save.cpp:            if (access(savestr, W_OK) == -1)
save.cpp:        for (i = 0, current = save; current; current = current->next, i++)
save.cpp:        for (current = save; current; current = current->next)
save.cpp:/* also saves some globals like Level->depth... */
save.cpp:    for( account = bank; account; account = account->next_account ) i++;
save.cpp:    for( account = bank; account; account = account->next_account )
save.cpp:        ok &= ( fwrite( (char *)(&(account->player)), sizeof(short), 1, fd ) > 0 );
save.cpp:        ok &= ( fwrite( (char *)(&(account->balance)), sizeof(long), 1, fd ) > 0 );
save.cpp:        ok &= ( fwrite( (char *)(&(account->number)), sizeof(long), 1, fd ) > 0 );
save.cpp:        ok &= ( fprintf( fd, "%s\n", account->password ) >= 0 );
save.cpp:    int width = level->level_width;
save.cpp:    int length = level->level_length;
save.cpp:    ok &= (fwrite((char *)&level->depth,sizeof(char),1,fd) > 0);
save.cpp:    ok &= (fwrite((char *)&level->numrooms,sizeof(char),1,fd) > 0);
save.cpp:    ok &= (fwrite((char *)&level->tunnelled,sizeof(char),1,fd) > 0);
save.cpp:    ok &= (fwrite((char *)&level->environment,sizeof(int),1,fd) > 0);
save.cpp:    ok &= (fwrite((char *)&level->level_width,sizeof(int),1,fd) > 0);
save.cpp:    ok &= (fwrite((char *)&level->level_length,sizeof(int),1,fd) > 0);
save.cpp:            if (level->site[i][j].lstatus&CHANGED) {	/* this loc has been changed */
save.cpp:                        level->site[run][j].lstatus&CHANGED; run++)
save.cpp:                    ok &= (fwrite((char *)&level->site[i][j],sizeof(struct location),1,fd) > 0);
save.cpp:            if (level->site[i][j].lstatus&SEEN)
save.cpp:                mask |= (1<<(sizeof(long int)*8 - 1));
save.cpp:            run--;
save.cpp:    ok &= save_monsters(fd,level->mlist);
save.cpp:            if (level->site[i][j].things) {
save.cpp:                ok &= save_itemlist(fd,level->site[i][j].things);
save.cpp:    for(tml=ml; tml!=NULL; tml=tml->next)
save.cpp:        if (tml->monster->hp > 0) nummonsters++;
save.cpp:    for(tml=ml; tml!=NULL; tml=tml->next) {
save.cpp:        if (tml->monster->hp > 0) {
save.cpp:            ok &= (fwrite((char *)tml->monster,sizeof(Monster),1,fd) > 0);
save.cpp:            if (tml->monster->id != HISCORE_NPC) {
save.cpp:                if (tml->monster->name != Monsters[tml->monster->id].name)
save.cpp:                if (tml->monster->corpseString != Monsters[tml->monster->id].corpseString)
save.cpp:                /*     preserves save-file compatibility without requiring code changes */
save.cpp:                    ok &= (fprintf(fd,"%s\n",tml->monster->name) >= 0);
save.cpp:                    ok &= (fprintf(fd,"%s\n",tml->monster->corpseString) >= 0);
save.cpp:             * to fix the well-known 'Star Gem' bug; it should allow the
save.cpp:            ok &= save_itemlist(fd,tml->monster->possessions);
save.cpp:        if (strcmp(o->objstr, Objects[o->id].objstr))
save.cpp:        if (strcmp(o->truename, Objects[o->id].truename))
save.cpp:        if (strcmp(o->cursestr, Objects[o->id].cursestr))
save.cpp:        if ( (type && o->cursestr == o->objstr) && (o->cursestr == o->truename) )
save.cpp:            ok &= (fprintf(fd,"%s\n",o->objstr) >= 0);
save.cpp:            ok &= (fprintf(fd,"%s\n",o->truename) >= 0);
save.cpp:            ok &= (fprintf(fd,"%s\n",o->cursestr) >= 0);
save.cpp:    for(tol=ol; tol!=NULL; tol=tol->next) numitems++;
save.cpp:    for(tol=ol; tol!=NULL; tol=tol->next)
save.cpp:        ok &= save_item(fd,tol->thing);
save.cpp:                mask |= (1<<(sizeof(long int)*8 - 1));
save.cpp:            run--;
save.cpp:       until we actually re-install some type of backwards compatibility. DAG */
save.cpp:    if (access(savestr, F_OK|R_OK|W_OK) == -1) /* access uses real uid */
save.cpp:        print1("Error restoring game -- aborted.");
save.cpp:        for (; i > 0; i--) {
save.cpp:            if (Level->environment == Current_Dungeon) {
save.cpp:                Level->next = Dungeon;
save.cpp:        ScreenOffset = -1000;	/* to force a redraw */
save.cpp:        fread( (char *)(&(account->player)), sizeof(short), 1, fd );
save.cpp:        fread( (char *)(&(account->balance)), sizeof(long), 1, fd );
save.cpp:        fread( (char *)(&(account->number)), sizeof(long), 1, fd );
save.cpp:        account->password = salloc( pw_buf );
save.cpp:        account->next_account = bank;
save.cpp:            twohandedp(Player.possessions[O_WEAPON_HAND]->id))
save.cpp:        /* DAG -- added object 215 (bag of holding) in 9001;  have to renumber */
save.cpp:            if (obj->id >= 215)
save.cpp:                obj->id++;
save.cpp:            obj->objstr = obj->truename = obj->cursestr = salloc(tempstr);
save.cpp:                obj->objstr = salloc(tempstr);
save.cpp:                obj->objstr = Objects[obj->id].objstr;
save.cpp:                obj->truename = salloc(tempstr);
save.cpp:                obj->truename = Objects[obj->id].truename;
save.cpp:                obj->cursestr = salloc(tempstr);
save.cpp:                obj->cursestr = Objects[obj->id].cursestr;
save.cpp:        newObject->thing = restore_item(fd, version);
save.cpp:        newObject->next = NULL;
save.cpp:            cur->next = newObject;
save.cpp:    fread((char *)&Level->depth,sizeof(char),1,fd);
save.cpp:    fread((char *)&Level->numrooms,sizeof(char),1,fd);
save.cpp:    fread((char *)&Level->tunnelled,sizeof(char),1,fd);
save.cpp:    fread((char *)&Level->environment,sizeof(int),1,fd);
save.cpp:    fread((char *)&Level->level_width,sizeof(int),1,fd);
save.cpp:    fread((char *)&Level->level_length,sizeof(int),1,fd);
save.cpp:    width = Level->level_width;
save.cpp:    length = Level->level_length;
save.cpp:    Level->generated = true;
save.cpp:    Current_Environment = Level->environment;
save.cpp:    switch(Level->environment) {
save.cpp:        initrand(Current_Environment, Level->depth);
save.cpp:        if ((random_range(4)==0) && (Level->depth < MaxDungeonLevels))
save.cpp:        initrand(Current_Environment, Level->depth);
save.cpp:        if ((random_range(4)==0) && (Level->depth < MaxDungeonLevels))
save.cpp:        initrand(Current_Environment, Level->depth);
save.cpp:        initrand(Current_Environment, Level->depth);
save.cpp:        initrand(Current_Environment, Level->depth);
save.cpp:        initrand(Current_Environment, Level->depth);
save.cpp:        load_house(Level->environment, false);
save.cpp:    if (Level->depth > 0) {	/* dungeon... */
save.cpp:        make_stairs(-1);
save.cpp:        make_stairs(-1);
save.cpp:            fread((char *)&Level->site[i][j],sizeof(struct location),1,fd);
save.cpp:            Level->site[i][j].creature = NULL;
save.cpp:            Level->site[i][j].things = NULL;
save.cpp:            run--;
save.cpp:        Level->site[i][j].things = restore_itemlist(fd, version);
save.cpp:    npc->name = salloc(Str2);
save.cpp:    npc->corpseString = salloc(Str1);
save.cpp:        status = npc->status;
save.cpp:        npc->determine_npc_behavior(level,behavior);
save.cpp:        npc->status = status;
save.cpp:    level->mlist = NULL;
save.cpp:        ml->monster = ((Monster*) checkmalloc(sizeof(Monster)));
save.cpp:        ml->next = NULL;
save.cpp:        fread((char *)ml->monster,sizeof(Monster),1,fd);
save.cpp:        if (ml->monster->id == HISCORE_NPC)
save.cpp:                temp_x = ml->monster->x;
save.cpp:                temp_y = ml->monster->y;
save.cpp:                make_hiscore_npc(ml->monster, ml->monster->aux2);
save.cpp:                ml->monster->x = temp_x;
save.cpp:                ml->monster->y = temp_y;
save.cpp:                restore_hiscore_npc(ml->monster, ml->monster->aux2);
save.cpp:                m_status_set( ml->monster, ALLOC );
save.cpp:                    ml->monster->name = salloc(tempstr);
save.cpp:                    ml->monster->name = salloc( Monsters[ml->monster->id].name );
save.cpp:                    ml->monster->corpseString = salloc(tempstr);
save.cpp:                    ml->monster->corpseString = salloc( Monsters[ml->monster->id].corpseString );
save.cpp:                ml->monster->corpseString = Monsters[ml->monster->id].corpseString;
save.cpp:                ml->monster->name = Monsters[ml->monster->id].name;
save.cpp:                ml->monster->possessions = restore_itemlist(fd,version);
save.cpp:            ml->monster->combatManeuvers = Monsters[ml->monster->id].combatManeuvers;
save.cpp:            ml->monster->possessions = restore_itemlist(fd,version);
save.cpp:        level->site[ml->monster->x][ml->monster->y].creature = ml->monster;
save.cpp:        ml->next = level->mlist;
save.cpp:        level->mlist = ml;
save.cpp:            run--;
scr.cpp: * should simplify history-keeping, since we only need to
scr.cpp:        if (right > Level->level_width) right = Level->level_width;
scr.cpp:        if (bottom > Level->level_length) bottom = Level->level_length;
scr.cpp:/* case insensitive mgetc -- sends uppercase to lowercase */
scr.cpp:        return(c+(int)('a'-'A'));
scr.cpp:/* for run on-messages -- print1 clears first.... */
scr.cpp:/* for run on-messages -- print2 clears first.... */
scr.cpp:/* for run on-messages -- print3 clears first.... */
scr.cpp:    ScreenLength = LINES - 6;
scr.cpp:    Bankw = newwin( 20, 50, ( ScreenLength - 20 ) / 2 + 3, 7 );
scr.cpp:    if (EOF == response || ESCAPE == response) response = -1;
scr.cpp: *   choices: a \0-terminated array containing the characters which are
scr.cpp: *   line1-3: The 3 lines of text, each at most 80 chars long.  Any may
scr.cpp: *   -1 if ESC was pressed; otherwise the character chosen.
scr.cpp:        if (-1 == response) break;
scr.cpp:int lastx= -1,lasty= -1;
scr.cpp:    if (Level->site[x][y].roomnumber < ROOMBASE) return(false);
scr.cpp:    static int oldx = -1,oldy = -1;
scr.cpp:                for (i= -2; i<3; i++)
scr.cpp:                    for (j= -2; j<3; j++)
scr.cpp:                for (i= -1; i<2; i++)
scr.cpp:                    for (j= -1; j<2; j++)
scr.cpp:        for (i= -1; i<2; i++)
scr.cpp:            for (j= -1; j<2; j++)
scr.cpp:/* draws a particular spot under if in line-of-sight */
scr.cpp:        if (c != Level->site[x][y].showchar)
scr.cpp:                Level->site[x][y].showchar = c;
scr.cpp:/* draws a particular spot regardless of line-of-sight */
scr.cpp:        if (c != Level->site[x][y].showchar) {
scr.cpp:            Level->site[x][y].showchar = c;
scr.cpp:        if (Level->site[i][j].locchar == FLOOR)  {
scr.cpp:            Level->site[i][j].showchar = SPACE;
scr.cpp:        Level->site[i][j].showchar = SPACE;
scr.cpp:    if (! offscreen(m->x,m->y)) {
scr.cpp:        wmove(Levelw,screenmody(m->y),screenmodx(m->x));
scr.cpp:            wattrset(Levelw, CHARATTR(m->symbol));
scr.cpp:        waddch(Levelw,(m->symbol&0xff));
scr.cpp:    for (ml=Level->mlist; ml!=NULL; ml=ml->next) {
scr.cpp:        if (ml->monster->hp > 0) {
scr.cpp:                if (view_los_p(Player.x,Player.y,ml->monster->x,ml->monster->y)) {
scr.cpp:                    if (Player.status[TRUESIGHT] || (! m_statusp(ml->monster,M_INVISIBLE))) {
scr.cpp:                                (ml->monster->level > 5) &&
scr.cpp:                                ((ml->monster->symbol&0xff) != '@') &&
scr.cpp:                                ((ml->monster->symbol&0xff) != '|')) wstandout(Levelw);
scr.cpp:                        putspot(ml->monster->x,ml->monster->y,ml->monster->symbol);
scr.cpp:            else erase_monster(ml->monster);
scr.cpp:    if (loc_statusp(m->x,m->y,SEEN))
scr.cpp:        putspot(m->x,m->y,getspot(m->x,m->y,false));
scr.cpp:    else blotspot(m->x,m->y);
scr.cpp:        if ( Level->site[x][y].roomnumber == RS_DRUID )
scr.cpp:            return(HEDGE);  /* secret doors in druid temple are brambles -DAG */
scr.cpp:    else switch (Level->site[x][y].locchar) {
scr.cpp:            if (Level->site[x][y].creature == NULL)
scr.cpp:            else if (m_statusp(Level->site[x][y].creature,SWIMMING))
scr.cpp:                return(Level->site[x][y].creature->symbol);
scr.cpp:            return(Level->site[x][y].locchar);
scr.cpp:            if (showmonster && (Level->site[x][y].creature != NULL)) {
scr.cpp:                if ((m_statusp(Level->site[x][y].creature,M_INVISIBLE)) &&
scr.cpp:                else return (Level->site[x][y].creature->symbol);
scr.cpp:            else return(Level->site[x][y].locchar);
scr.cpp:            if (showmonster && (Level->site[x][y].creature != NULL)) {
scr.cpp:                if ((m_statusp(Level->site[x][y].creature,M_INVISIBLE)) &&
scr.cpp:                else return (Level->site[x][y].creature->symbol);
scr.cpp:            else if (Level->site[x][y].things != NULL) {
scr.cpp:                if (Level->site[x][y].things->next != NULL)
scr.cpp:                else return(Level->site[x][y].things->thing->objchar);
scr.cpp:            else return(Level->site[x][y].locchar);
scr.cpp:            if (account) account->balance += SalaryAmount;
scr.cpp:    if (y >= ScreenLength - 2) {
scr.cpp:    if (y >= ScreenLength - 2) {
scr.cpp:                i--;
scr.cpp:    else for (i=0; i<Level->level_width; i++)
scr.cpp:            for(j=0; j<Level->level_length; j++)
scr.cpp:            else if ((atom=='<') && (value > 1)) value--;
scr.cpp:                    value--;
scr.cpp:                --numlen;
scr.cpp:                mvwaddch(w, ypos, --xpos, ' ');
scr.cpp:            amount = 10 * amount + (ch - '0');
scr.cpp: * interface.  Returns ABORT (-1) if aborted. */
scr.cpp:    int place = -1;
scr.cpp:            if (place > -1) {
scr.cpp:                place--;
scr.cpp:                wmove(Cinema,y,x-1);
scr.cpp:                wmove(Cinema,y,x-1);
scr.cpp:        for (i=place; i>=0; i--) {
scr.cpp:            num += mult*(number[i]-'0');
scr.cpp:    if (y >= ScreenLength - 2) {
scr.cpp:    if (y >= ScreenLength - 2) {
scr.cpp:        wmove(Msgw,y,x-1);
scr.cpp:        wmove(Msgw,y,x-1);
scr.cpp:    if (((y-ScreenOffset) < (ScreenLength/8)) ||
scr.cpp:            ((y-ScreenOffset) > (7*ScreenLength/8))) {
scr.cpp:        ScreenOffset = y - (ScreenLength/2);
scr.cpp:    ScreenOffset = y - (ScreenLength/2);
scr.cpp:    ScreenXOffset = x - (ScreenWidth/2);
scr.cpp:    if (((y-ScreenOffset) < (ScreenLength/8)) ||
scr.cpp:            ((y-ScreenOffset) > (7*ScreenLength/8))) {
scr.cpp:        ScreenOffset = y - (ScreenLength/2);
scr.cpp:    if (((x-ScreenXOffset) < (ScreenWidth/8)) ||
scr.cpp:            ((x-ScreenXOffset) > (7*ScreenWidth/8))) {
scr.cpp:            width = Level->level_width;
scr.cpp:        if ( ( (x-ScreenXOffset) + (7*ScreenWidth/8) ) < width +( ScreenWidth/8 ) )
scr.cpp:            ScreenXOffset = x - (ScreenWidth/2);
scr.cpp:            Level->site[x][y].roomnumber == roomno) {
scr.cpp:        spreadroomlight(x-1,y,roomno);
scr.cpp:        spreadroomlight(x,y-1,roomno);
scr.cpp:    Level->site[x][y].showchar = c;
scr.cpp:        if (loc_statusp(x,y,LIT) && (Level->site[x][y].roomnumber == roomno)) {
scr.cpp:            spreadroomdark(x-1,y,roomno);
scr.cpp:            spreadroomdark(x,y-1,roomno);
scr.cpp:    char usechar = ')', idchar = '-';
scr.cpp:        if (Player.possessions[slotnum]->used)
scr.cpp:        wprintw(W,"-- Object 'up in air':",usechar);
scr.cpp:        wprintw(W,"-- %c%c ready hand: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c weapon hand: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c left shoulder: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c right shoulder: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c belt: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c belt: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c belt: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c shield: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c armor: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c boots: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c cloak: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c finger: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c finger: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c finger: ",idchar,usechar);
scr.cpp:        wprintw(W,"-- %c%c finger: ",idchar,usechar);
scr.cpp:        waddstr(Showline[oldslot],"--");
scr.cpp:        wprintw(Showline[slot],"-- Option BELLICOSE [TF]: ");
scr.cpp:        wprintw(Showline[slot],"-- Option JUMPMOVE [TF]: ");
scr.cpp:        wprintw(Showline[slot],"-- Option RUNSTOP [TF]: ");
scr.cpp:        wprintw(Showline[slot],"-- Option PICKUP [TF]: ");
scr.cpp:        wprintw(Showline[slot],"-- Option CONFIRM [TF]: ");
scr.cpp:        wprintw(Showline[slot],"-- Option TOPINV [TF]: ");
scr.cpp:        wprintw(Showline[slot],"-- Option PACKADD [TF]: ");
scr.cpp:        wprintw(Showline[slot],"-- Option COLOUR [TF]: ");
scr.cpp:                "-- Option VERBOSITY [(T)erse,(M)edium,(V)erbose]: (now ");
scr.cpp:        wprintw(Showline[slot],"-- Option SEARCHNUM [0>x>10]: (now %d)",Searchnum);
scr.cpp:        wprintw(Showline[slot],"-- Strength ... [%d]: ", Player.str);
scr.cpp:        wprintw(Showline[slot],"-- Constitution [%d]: ", Player.con);
scr.cpp:        wprintw(Showline[slot],"-- Dexterity .. [%d]: ", Player.dex);
scr.cpp:        wprintw(Showline[slot],"-- Agility .... [%d]: ", Player.agi);
scr.cpp:        wprintw(Showline[slot],"-- Intelligence [%d]: ", Player.iq);
scr.cpp:        wprintw(Showline[slot],"-- Power ...... [%d]: ", Player.pow);
scr.cpp:        wprintw(Showline[slot],"-- HP ......... [%d]: ", Player.hp);
scr.cpp:        wprintw(Showline[slot],"-- Max HP ..... [%d]: ", Player.maxhp);
scr.cpp:        wprintw(Showline[slot],"-- Mana ....... [%d]: ", Player.mana);
scr.cpp:        wprintw(Showline[slot],"-- Max Mana ... [%d]: ", Player.maxmana);
scr.cpp:        wprintw(Showline[slot],"-- Cash ....... [%d]: ", Player.cash);
scr.cpp:    int pos = bufferpos - 1;
scr.cpp:        pos = STRING_BUFFER_SIZE - 1;
scr.cpp:    if (strlen(Stringbuffer[pos]) + strlen(s) < 80 - 1) {
scr.cpp:    int i = bufferpos - 1, c, finished = 0;
scr.cpp:        if (i < 0) i = STRING_BUFFER_SIZE - 1;
scr.cpp:            i--;
Scroll.h:/* Scroll - scroll objects */
site1.cpp:        print3("Unfortunately, this is Julie's lunch hour -- try again later.");
site1.cpp:        i = item - 'a';
site1.cpp:        newitem->known = 2;
site1.cpp:                Player.cash -= 2*true_item_value(newitem);
site1.cpp:                    Player.cash -= 100;
site1.cpp:    if (Date - LastFreeGymDay >= 1 && physicalSum < 50 && Gymcredit < 2000) {
site1.cpp:        print1("As you enter the gym, you're approached by a beefy-looking trainer.");
site1.cpp:            nprint1(" -- Gym Credit: ");
site1.cpp:    switch(random_range(difficulty()+4)-1) {
site1.cpp:        Level->site[x][y].locchar = RUBBLE;
site1.cpp:        Level->site[x][y].p_locf = L_RUBBLE;
site1.cpp:        Level->site[x][y].locchar = RUBBLE;
site1.cpp:        Level->site[x][y].p_locf = L_RUBBLE;
site1.cpp:                (Level->depth < MaxDungeonLevels)) ||
site1.cpp:            /* DAG -- added level test above, to skip this case if at bottom
site1.cpp:            Level->site[x][y].locchar = STAIRS_DOWN;
site1.cpp:            Level->site[x][y].p_locf = L_NO_OP;
site1.cpp:        dispel(-1);
site1.cpp:            item->blessing = -1-abs(item->blessing);
site1.cpp:        for(j=0; j<Level->level_length; j++)
site1.cpp:            for(i=0; i<Level->level_width; i++) {
site1.cpp:    if (Level->site[x][y].locchar == STATUE) {
site1.cpp:        Level->site[x][y].locchar = FLOOR;
site1.cpp:        tml->monster =
site1.cpp:            (Level->site[x][y].creature = m_create(x,y,0,difficulty()+1));
site1.cpp:        m_status_set(Level->site[x][y].creature,HOSTILE);
site1.cpp:        tml->next = Level->mlist;
site1.cpp:        Level->mlist = tml;
site1.cpp:                    Player.cash -= 100;
site1.cpp:                        winnings -= 100;
site1.cpp:                    Player.cash -= 1000;
site1.cpp:                        else if (a==1) print1(" 0 - 0 ");
site1.cpp:                            mnumprint(a-1);
site1.cpp:                    else if (a==1) print1(" 0 - 0 ");
site1.cpp:                        mnumprint(a-1);
site1.cpp:                        winnings -= 1000;
site1.cpp:    print1("Commandant Sonder's Rampart-fried Lyzzard partes. Open 24 hrs.");
site1.cpp:            Player.cash -= num*5;
site1.cpp:            food->number = num;
site1.cpp:            Player.cash -= 25;
site1.cpp:                Player.cash -= 1000;
site1.cpp:    print1("The Centaur and Nymph -- J. Riley, prop.");
site1.cpp:        menuprint("a: Pint of Riley's ultra-dark 1Au\n");
site1.cpp:                Player.cash -= 1;
site1.cpp:                if (tavern_hinthour == -1)  /* first time... */
site1.cpp:                        if (! CitySiteList[L_BROTHEL-CITYSITEBASE][0])
site1.cpp:                            print2("He nudge-nudges you, and says, 'You should visit the House of the Eclipse'");
site1.cpp:                            CitySiteList[L_BROTHEL-CITYSITEBASE][0] = true;
site1.cpp:                            print2("He says, 'Did you enjoy your visit to the House of the Eclipse?', wink-wink.");
site1.cpp:                                Player.cash -= 10;
site1.cpp:                                CitySiteList[L_BROTHEL-CITYSITEBASE][0] = true;
site1.cpp:                                CitySiteList[L_THIEVES_GUILD-CITYSITEBASE][0] = true;
site1.cpp:                Player.cash -= 10;
site1.cpp:                Player.cash -= 100;
site1.cpp:                        Player.alignment--;
site1.cpp:                    else if (Player.alignment > 0) Player.alignment--;
site1.cpp:                Player.cash -= 25;
site1.cpp:                    if (Monsters[obj->charge].transformId == -1) {
site1.cpp:                        if (obj->basevalue > 0)
site1.cpp:                        mnumprint(obj->basevalue/3);
site1.cpp:                            Player.cash += (obj->basevalue/3);
site1.cpp:                    if (Monsters[obj->charge].transformId == -1)
site1.cpp:                        mlevel = Monsters[obj->charge].level;
site1.cpp:                        mnumprint(max(10,obj->basevalue*2));
site1.cpp:                            if (Player.cash < max(10,obj->basevalue*2))
site1.cpp:                                Player.cash -= max(10,obj->basevalue*2);
site1.cpp:                                *obj = Objects[Monsters[obj->charge].transformId];
site1.cpp:                                if ((obj->id >= STICKID) && (obj->id < STICKID+NUMSTICKS))
site1.cpp:                                    obj->charge = 20;
site1.cpp:                                if (obj->plus == 0) obj->plus = mlevel;
site1.cpp:                                if (obj->blessing == 0) obj->blessing = 1;
site1.cpp:    if (Date - LastDay < 7)
site1.cpp:                Str1[0] += 'A' - 'a';
site1.cpp:            mnumprint(fee=max(50,1000-(18-Player.maxiq)*125));
site1.cpp:                    Player.cash -= fee;
site1.cpp:                            print1("You unroll a slick four-color document...");
site1.cpp:                                        fee != max(50,1000-(18-Player.maxiq)*125))
site1.cpp:                                    mnumprint(fee=max(50,1000-(18-Player.maxiq)*125));
site1.cpp:        limit = min(5,Date-Pawndate);
site1.cpp:                if (Objects[Pawnitems[0]->id].uniqueness > UNIQUE_UNMADE)
site1.cpp:                    Objects[Pawnitems[0]->id].uniqueness = UNIQUE_UNMADE;
site1.cpp:            for (i=0; i<PAWNITEMS-1; i++)
site1.cpp:            Pawnitems[PAWNITEMS-1] = NULL;
site1.cpp:                        Pawnitems[i]->known = 2;
site1.cpp:                    } while ((Pawnitems[i]->objchar == CASH) ||
site1.cpp:                             (Pawnitems[i]->objchar == ARTIFACT) ||
site1.cpp:                    i = item - 'a';
site1.cpp:                        mlongprint(Pawnitems[i]->number*true_item_value(Pawnitems[i]));
site1.cpp:                                    Pawnitems[i]->number *
site1.cpp:                                Player.cash -=
site1.cpp:                                    Pawnitems[i]->number*
site1.cpp:                                Objects[Pawnitems[i]->id].known = 1;
site1.cpp:                    if (Player.possessions[i]->isCursed()) {
site1.cpp:                            number = getnumber(Player.possessions[i]->number);
site1.cpp:                            if ((number >= Player.possessions[i]->number) &&
site1.cpp:                                    Player.possessions[i]->used) {
site1.cpp:                                Player.possessions[i]->used = false;
site1.cpp:                            for(j=0; j<PAWNITEMS - 1; j++)
site1.cpp:                            Pawnitems[PAWNITEMS - 1] = copy_obj( Player.possessions[i] );
site1.cpp:                            Pawnitems[PAWNITEMS - 1]->number = number;
site1.cpp:                            Pawnitems[PAWNITEMS - 1]->known = 2;
site1.cpp:                    if (Player.pack[i]->blessing > -1 &&
site1.cpp:                            number = getnumber(Player.pack[i]->number);
site1.cpp:                                for(j=0; j<PAWNITEMS - 1; j++)
site1.cpp:                                Pawnitems[PAWNITEMS - 1] = copy_obj( Player.pack[i] );
site1.cpp:                                Pawnitems[PAWNITEMS - 1]->number = number;
site1.cpp:                                Pawnitems[PAWNITEMS - 1]->known = 2;
site1.cpp:                                Player.pack[i]->number -= number;
site1.cpp:                                if (Player.pack[i]->number < 1) {
site2.cpp:                    Player.cash-=50000;
site2.cpp:                    Player.cash -=1000;
site2.cpp:                    if (Player.possessions[i]->blessing < 0)
site2.cpp:                        ol->thing = Player.possessions[i];
site2.cpp:                        ol->next = Condoitems;
site2.cpp:                    nprint1(itemid(ol->thing));
site2.cpp:                    /* DAG -- fix memory leak where object list nodes weren't deleted */
site2.cpp:                        gain_item(ol->thing);
site2.cpp:                            ol = ol->next;
site2.cpp:                            ol=ol->next;
site2.cpp:                            free( prev->next );
site2.cpp:                            prev->next = ol;
site2.cpp:                        ol = ol->next;
site2.cpp:        if (Gymcredit > 2000) Gymcredit -= 2000;
site2.cpp:            Player.cash -= (2000-Gymcredit);
site2.cpp:        Player.cash -= 50;
site2.cpp:        Player.cash -= 250;
site2.cpp:    for(ml=Level->mlist; ml!=NULL; ml=ml->next)
site2.cpp:        if ((ml->monster->id == GUARD) || /*guard*/
site2.cpp:                ((ml->monster->id == HISCORE_NPC) && (ml->monster->aux2 == 15))) {/* justiciar */
site2.cpp:            m_status_reset(ml->monster,HOSTILE);
site2.cpp:            ml->monster->specialf = M_NO_OP;
site2.cpp:            if (ml->monster->id == GUARD && ml->monster->hp > 0 && ml->monster->aux1 > 0) {
site2.cpp:                if (Level->site[ml->monster->x][ml->monster->y].creature == ml->monster)
site2.cpp:                    Level->site[ml->monster->x][ml->monster->y].creature = NULL;
site2.cpp:                ml->monster->x = ml->monster->aux1;
site2.cpp:                ml->monster->y = ml->monster->aux2;
site2.cpp:                Level->site[ml->monster->x][ml->monster->y].creature = ml->monster;
site2.cpp:            else if (ml->monster->id == HISCORE_NPC && ml->monster->hp > 0 &&
site2.cpp:                if (Level->site[ml->monster->x][ml->monster->y].creature == ml->monster)
site2.cpp:                    Level->site[ml->monster->x][ml->monster->y].creature = NULL;
site2.cpp:                ml->monster->x = 40;
site2.cpp:                ml->monster->y = 62;
site2.cpp:                Level->site[ml->monster->x][ml->monster->y].creature = ml->monster;
site2.cpp:        Level->site[40][60].p_locf = L_ORDER; /* undoes action in alert_guards */
site2.cpp:        Player.rank[ORDER] = -1;
site2.cpp:                    Player.level--;
site2.cpp:                print1("Luckily for you, a smooth-tongued advocate from the");
site2.cpp:                    print2("As a first-time offender, you are given probation.");
site2.cpp:                    print1("The guards recognize you as a 'three-time-loser'");
site2.cpp:        damage += Level->depth/2+1;
site2.cpp:        print2("Razor-edged vines covered in suckers attach themselves to you.");
site2.cpp:        if (find_and_remove_item(OB_SALT_WATER,-1)) {
site2.cpp:            Level->site[Player.x][Player.y].locchar = FLOOR;
site2.cpp:            Level->site[Player.x][Player.y].p_locf = L_NO_OP;
site2.cpp:                print1("The hedge enjoys your camp play-acting....");
site2.cpp:        Level->site[12][56].locchar = FLOOR;
site2.cpp:        Level->site[12][56].locchar = WALL;
site2.cpp:                Level->site[12][56].locchar = FLOOR;
site2.cpp:                        Player.cash -= 500;
site2.cpp:                        if (hour() > 12) Time += ((24-hour())+8) * 60;
site2.cpp:                            Time += ((9-hour())*60);
site2.cpp:                            Player.iq++; /* whatever :-) */
site2.cpp:        attempt = (2*Player.dex + Player.rank[THIEVES]*10 - random_range(100))/10;
site2.cpp:        attempt = (Player.dmg - random_range(100))/10;
site2.cpp:        Player.alignment -= 4;
site2.cpp:        Level->site[Player.x][Player.y].locchar = FLOOR;
site2.cpp:        Level->site[Player.x][Player.y].p_locf = L_NO_OP;
site2.cpp:        if (attempt == -1) {
site2.cpp:        else if (attempt == -2) {
site2.cpp:            print2("The safe has self-destructed.");
site2.cpp:            Level->site[Player.x][Player.y].locchar = RUBBLE;
site2.cpp:            Level->site[Player.x][Player.y].p_locf = L_RUBBLE;
site2.cpp:        else if (attempt == -3) {
site2.cpp:        else if (attempt < -3) {
site2.cpp:                Player.possessions[O_ARMOR]->dmg-=3;
site2.cpp:                Player.possessions[O_ARMOR]->hit-=3;
site2.cpp:                Player.possessions[O_ARMOR]->aux-=3;
site2.cpp:            Player.cash -= 500;
site2.cpp:            for(i=x-15; i<=x+15; i++)
site2.cpp:                for(j=y-15; j<=y+15; j++)
site2.cpp:            Player.cash -= donation;
site2.cpp:            Player.cash -= donation;
site2.cpp:        if (! CitySiteList[L_ARMORER-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_ARMORER-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_CLUB-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_CLUB-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_GYM-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_GYM-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_HEALER-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_HEALER-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_CASINO-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_CASINO-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_DINER-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_DINER-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_CRAP-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_CRAP-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_COMMANDANT-CITYSITEBASE][0])
site2.cpp:            menuprint("Commandant Sonder's Rampart-fried Lyzzard partes\n");
site2.cpp:        CitySiteList[L_COMMANDANT-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_TAVERN-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_TAVERN-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_ALCHEMIST-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_ALCHEMIST-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_DPW-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_DPW-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_LIBRARY-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_LIBRARY-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_PAWN_SHOP-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_PAWN_SHOP-CITYSITEBASE][0] = true;
site2.cpp:        if (! CitySiteList[L_CONDO-CITYSITEBASE][0])
site2.cpp:        CitySiteList[L_CONDO-CITYSITEBASE][0] = true;
spell.cpp:    sanctify(-1);
spell.cpp:    summon(0,-1);
spell.cpp:        mprint("Your concentration was broken -- the ritual fails!");
spell.cpp:        else if ( (roomno=Level->site[Player.x][Player.y].roomnumber) >= ROOMBASE )
spell.cpp:                        Level->site[Player.x+Dirs[0][i]][Player.y+Dirs[1][i]].locchar =
spell.cpp:                        Level->site[Player.x+Dirs[0][i]][Player.y+Dirs[1][i]].p_locf =
spell.cpp:                    while (x >= 0 && Level->site[x - 1][y].roomnumber == RS_SHRINE)
spell.cpp:                        x--;
spell.cpp:                    while (y >= 0 && Level->site[x][y - 1].roomnumber == RS_SHRINE)
spell.cpp:                        y--;
spell.cpp:                    for (i = 0; Level->site[x][y].roomnumber == RS_SHRINE;) {
spell.cpp:                        Level->site[x][y].roomnumber = RS_ZORCH;
spell.cpp:                        if (Level->site[x][y].roomnumber != RS_SHRINE) {
spell.cpp:                            x -= i;
spell.cpp:                    summon(-1,-1);
spell.cpp:                    m_status_reset(Level->mlist->monster,MOBILE);
spell.cpp:                                    (! find_item(&symbol,OB_SYMBOL_DESTINY,-1))) {
spell.cpp:                                symbol->known = 2;
spell.cpp:                                symbol->charge = 17;
spell.cpp:            if (RitualRoom == Level->site[Player.x][Player.y].roomnumber)
spell.cpp:                RitualRoom = Level->site[Player.x][Player.y].roomnumber;
spell.cpp:    int spell= ABORT - 1;
spell.cpp:    last = NUMSPELLS - 1;
spell.cpp:                prefix[--pos] = '\0';
spell.cpp:                byte = prefix[pos - 1];
spell.cpp:                    f--;
spell.cpp:                last = NUMSPELLS - 1;
spell.cpp:                byte += 'a' - 'A';
spell.cpp:                l--;
spell.cpp:            nprint2(prefix + pos - 1);
stats.cpp:            to = slot - 1;
Thing.cpp:Thing Thing::create_object( int id = -1 )
Thing.h:/* thing - parent class for thing objects*/
time.cpp:    a change-environment to the country, the monsters on the old Level
time.cpp:        prev = &(Level->mlist);
time.cpp:            if (ml->monster->hp > 0) {
time.cpp:                if (Level->site[ml->monster->x][ml->monster->y].creature != ml->monster)
time.cpp:                    fix_phantom(ml->monster);
time.cpp:                if (Tick == ml->monster->click) {
time.cpp:                    ml->monster->click += ml->monster->speed;
time.cpp:                    while (ml->monster->click > 60) ml->monster->click -= 60;
time.cpp:                    ml->monster->m_pulse();
time.cpp:                prev = &(ml->next);
time.cpp:                ml = ml->next;
time.cpp:            else if (ml->monster != Arena_Monster) {
time.cpp:                *prev = ml->next;
time.cpp:                if ( m_statusp( ml->monster, ALLOC ) )
time.cpp:                    free( ml->monster->name );
time.cpp:                    free( ml->monster->corpseString );
time.cpp:                free((char *) ml->monster);
time.cpp:                ml = ml->next;
time.cpp:    if (Level->site[m->x][m->y].creature == NULL) {
time.cpp:        Level->site[m->x][m->y].creature = m;
time.cpp:        findspace(&(m->x),&(m->y),-1);
time.cpp:        Level->site[m->x][m->y].creature = m;
time.cpp:        m->m_death();
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:    print2("'Intruder Alert -- Intruder Alert -- Intruder Alert'");
trap.cpp:            summon(-1,DEMON_PRINCE); /* prime circle demon */
trap.cpp:            summon(-1,DEMON_PRINCE);
trap.cpp:            summon(-1,DEMON_PRINCE);
trap.cpp:        for(ml=Level->mlist; ml!=NULL; ml=ml->next) {
trap.cpp:            m_status_set(ml->monster,AWAKE);
trap.cpp:            ml->monster->sense *= 2;
trap.cpp:                    ((Current_Environment == E_VILLAGE) && (ml->monster->id == GUARD)) ||
trap.cpp:                    ((Current_Environment == E_CITY) && (ml->monster->id == GUARD)))
trap.cpp:                m_status_set(ml->monster,HOSTILE);
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:        Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:            if (Level->site[Player.x][Player.y].aux != S_DISINTEGRATE) {
trap.cpp:                p_damage(Level->depth*difficulty(),UNSTOPPABLE,"a rockslide");
trap.cpp:            change_level(Level->depth,Level->depth+1,false);
trap.cpp:            if (Level->site[Player.x][Player.y].aux != S_DISINTEGRATE) {
trap.cpp:                p_damage(Level->depth*difficulty(),UNSTOPPABLE,"a rockslide");
trap.cpp:            change_level(Level->depth,Level->depth+1,false);
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:            p_damage(random_range(difficulty()*3)+difficulty()-Player.absorption,
trap.cpp:    Level->site[Player.x][Player.y].locchar = FIRE;
trap.cpp:    Level->site[Player.x][Player.y].p_locf = L_FIRE;
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:    else p_teleport(-1);
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:    Level->site[Player.x][Player.y].locchar = ABYSS;
trap.cpp:    Level->site[Player.x][Player.y].locchar = TRAP;
trap.cpp:            mprint("The manadrain trap overloads -- positive feedback....");
trap.cpp:            Level->site[Player.x][Player.y].locchar = FLOOR;
trap.cpp:            Level->site[Player.x][Player.y].p_locf = L_NO_OP;
trap.cpp:        dispel(-1);
util.cpp:        return((x>=0)&&(y>=0)&&(x<(Level->level_width))&&(y<(Level->level_length)));
util.cpp:    return(y-ScreenOffset);
util.cpp:/* PGM - horizontal scrolling */
util.cpp:    return(x-ScreenXOffset);
util.cpp:        width = Level->level_width;
util.cpp:        length = Level->level_length;
util.cpp:            (y>ScreenOffset+ScreenLength-1) ||
util.cpp:            (x>ScreenXOffset+ScreenWidth-1) ||
util.cpp:    else return((roll < (hit - ac)) ? true : false );
util.cpp:    return(max(abs(x2-x1),abs(y2-y1)));
util.cpp:            (Level->site[x][y].creature != NULL) ||
util.cpp:            (Level->site[x][y].locchar == WALL) ||
util.cpp:            (Level->site[x][y].locchar == PORTCULLIS) ||
util.cpp:            (Level->site[x][y].locchar == STATUE) ||
util.cpp:            (Level->site[x][y].locchar == HEDGE) ||
util.cpp:            (Level->site[x][y].locchar == CLOSED_DOOR) ||
util.cpp:    else if ((Level->site[x][y].creature != NULL) ||
util.cpp:             (Level->site[x][y].locchar == SPACE)) return(false);
util.cpp:        return(Level->site[x][y].locchar == WATER);
util.cpp:        if (m->movef == M_MOVE_SMART) {
util.cpp:    else if ((Level->site[x][y].locchar == FLOOR) ||
util.cpp:             (Level->site[x][y].locchar == OPEN_DOOR))
util.cpp:    else if ((Level->site[x][y].locchar == PORTCULLIS) ||
util.cpp:             (Level->site[x][y].locchar == WALL) ||
util.cpp:             (Level->site[x][y].locchar == STATUE))
util.cpp:    else if (Level->site[x][y].locchar==WATER)
util.cpp:    else if (Level->site[x][y].locchar == CLOSED_DOOR) {
util.cpp:        if (m->movef==M_MOVE_SMART) {
util.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
util.cpp:        else if (random_range(m->dmg) > random_range(100)) {
util.cpp:            Level->site[x][y].locchar = RUBBLE;
util.cpp:    else if (Level->site[x][y].locchar == LAVA)
util.cpp:    else if (Level->site[x][y].locchar == FIRE)
util.cpp:    else if ((Level->site[x][y].locchar == TRAP) ||
util.cpp:             (Level->site[x][y].locchar == HEDGE) ||
util.cpp:             (Level->site[x][y].locchar == ABYSS))
util.cpp:        return((m->movef == M_MOVE_CONFUSED) ||
util.cpp:    else if ((Level->site[x][y].locchar == WALL) ||
util.cpp:             (Level->site[x][y].locchar == STATUE) ||
util.cpp:             (Level->site[x][y].locchar == HEDGE) ||
util.cpp:             (Level->site[x][y].locchar == FIRE) ||
util.cpp:             (Level->site[x][y].locchar == CLOSED_DOOR) ||
util.cpp:    if (x2 - *x1 < 0) dx = 5;
util.cpp:    else if (x2 - *x1 > 0) dx = 4;
util.cpp:    else dx = -1;
util.cpp:    if (y2 - *y1 < 0) dy = 7;
util.cpp:    else if (y2 - *y1 > 0) dy = 6;
util.cpp:    else dy = -1;
util.cpp:    if (abs(x2 - *x1) > abs(y2 - *y1)) {
util.cpp:        step = abs(x2 - *x1);
util.cpp:        delta = 2*abs(y2 - *y1);
util.cpp:        step = abs(y2 - *y1);
util.cpp:        delta = 2*abs(x2 - *x1);
util.cpp:    if (major == -1)	/* x1,y2 already == x2,y2 */
util.cpp:            error -= 2*step;
util.cpp:            *x1 -= Dirs[0][minor];
util.cpp:            *y1 -= Dirs[1][minor];
util.cpp:        Level->site[*x1][*y1].showchar = pyx;
util.cpp:    if (x2 - *x1 < 0) dx = 5;
util.cpp:    else if (x2 - *x1 > 0) dx = 4;
util.cpp:    else dx = -1;
util.cpp:    if (y2 - *y1 < 0) dy = 7;
util.cpp:    else if (y2 - *y1 > 0) dy = 6;
util.cpp:    else dy = -1;
util.cpp:    if (abs(x2 - *x1) > abs(y2 - *y1)) {
util.cpp:        step = abs(x2 - *x1);
util.cpp:        delta = 2*abs(y2 - *y1);
util.cpp:        step = abs(y2 - *y1);
util.cpp:        delta = 2*abs(x2 - *x1);
util.cpp:    if (major == -1)	/* x1,y2 already == x2,y2 */
util.cpp:            error -= 2*step;
util.cpp:            *x1 -= Dirs[0][minor];
util.cpp:            *y1 -= Dirs[1][minor];
util.cpp:            Level->site[*x1][*y1].showchar = pyx;
util.cpp:    if (Level->site[*x1][*y1].creature == NULL && blocked) {
util.cpp:    if (x2-x1 < 0) dx = 5;
util.cpp:    else if (x2-x1 > 0) dx = 4;
util.cpp:    else dx = -1;
util.cpp:    if (y2-y1 < 0) dy = 7;
util.cpp:    else if (y2-y1 > 0) dy = 6;
util.cpp:    else dy = -1;
util.cpp:    if (abs(x2-x1) > abs(y2-y1)) {
util.cpp:        step = abs(x2 - x1);
util.cpp:        delta = 2*abs(y2 - y1);
util.cpp:        step = abs(y2 - y1);
util.cpp:        delta = 2*abs(x2 - x1);
util.cpp:    if (major == -1)	/* x1,y2 already == x2,y2 */
util.cpp:            error -= 2*step;
util.cpp:            x1 -= Dirs[0][minor];
util.cpp:            y1 -= Dirs[1][minor];
util.cpp:    if (x2-x1 < 0) dx = 5;
util.cpp:    else if (x2-x1 > 0) dx = 4;
util.cpp:    else dx = -1;
util.cpp:    if (y2-y1 < 0) dy = 7;
util.cpp:    else if (y2-y1 > 0) dy = 6;
util.cpp:    else dy = -1;
util.cpp:    if (abs(x2-x1) > abs(y2-y1)) {
util.cpp:        step = abs(x2 - x1);
util.cpp:        delta = 2*abs(y2 - y1);
util.cpp:        step = abs(y2 - y1);
util.cpp:        delta = 2*abs(x2 - x1);
util.cpp:    if (major == -1)	/* x1,y2 already == x2,y2 */
util.cpp:            error -= 2*step;
util.cpp:            x1 -= Dirs[0][minor];
util.cpp:            y1 -= Dirs[1][minor];
util.cpp:            points += Player.possessions[i]->level*(Player.possessions[i]->known+1);
util.cpp:            points += Player.pack[i]->level*(Player.pack[i]->known+1);
util.cpp:    if (FLOOR != Level->site[x_idx][y_idx].locchar) return false;
util.cpp:    if (Level->site[x_idx][y_idx].creature) return false;
util.cpp:    if (Level->site[x_idx][y_idx].buildaux == baux) return false;
util.cpp:    for (count = 0; count < (lev->level_width * lev->level_length / 4); ++count)
util.cpp:        *x_idx = random_range(lev->level_width);
util.cpp:        *y_idx = random_range(lev->level_length);
util.cpp:    x_idx = x_start = random_range(lev->level_width);
util.cpp:    y_idx = y_start = random_range(lev->level_length);
util.cpp:                        --y_idx;
util.cpp:                        if (y_idx == -1)
util.cpp:                            y_idx = lev->level_length - 1;
util.cpp:                    --x_idx;
util.cpp:                    if (x_idx == -1)
util.cpp:                        x_idx = lev->level_width - 1;
util.cpp:                        if (y_idx == lev->level_length)
util.cpp:                    --x_idx;
util.cpp:                    if (x_idx == -1)
util.cpp:                        x_idx = lev->level_width - 1;
util.cpp:                        --y_idx;
util.cpp:                        if (y_idx == -1)
util.cpp:                            y_idx = lev->level_length - 1;
util.cpp:                    if (x_idx == lev->level_width)
util.cpp:                        if (y_idx == lev->level_length)
util.cpp:                    if (x_idx == lev->level_width)
util.cpp:                        --x_idx;
util.cpp:                        if (x_idx == -1)
util.cpp:                            x_idx = lev->level_width - 1;
util.cpp:                    --y_idx;
util.cpp:                    if (y_idx == -1)
util.cpp:                        y_idx = lev->level_length - 1;
util.cpp:                        if (x_idx == lev->level_width)
util.cpp:                    --y_idx;
util.cpp:                    if (y_idx == -1)
util.cpp:                        y_idx = lev->level_length - 1;
util.cpp:                        --x_idx;
util.cpp:                        if (x_idx == -1)
util.cpp:                            x_idx = lev->level_width - 1;
util.cpp:                    if (y_idx == lev->level_length)
util.cpp:                        if (x_idx == lev->level_width)
util.cpp:                    if (y_idx == lev->level_length)
util.cpp:/* WSS - Maybe I'm not understanding something here, but isn't "strmem" just */
util.cpp:/* WSS - a lame version of the standard library function strchr? */
util.cpp:            weight += Player.possessions[i]->weight *	Player.possessions[i]->number;
util.cpp:        weight -= Player.possessions[O_READY_HAND]->weight *
util.cpp:                  Player.possessions[O_READY_HAND]->number;
util.cpp:            weight += Player.pack[i]->weight *
util.cpp:                      Player.pack[i]->number;
util.cpp:    else return((level->environment != E_CITY) &&
util.cpp:                    (level->environment != E_VILLAGE) &&
util.cpp:                    (level->environment != Current_Dungeon));
util.cpp:    if ( flag && (obj->id == CORPSEID) && (obj->level & ALLOC) )
util.cpp:        free( obj->objstr );
util.cpp:    if ( (obj->id == CORPSEID) && (obj->level & ALLOC) )
util.cpp:        newObject->objstr = newObject->cursestr = newObject->truename = salloc( obj->objstr );
util.cpp:        free_obj( (tmp = po)->thing, true );
util.cpp:        po = po->next;
util.cpp:        free_objlist((tmp = mlist)->monster->possessions);
util.cpp:        if ( m_statusp( tmp->monster, ALLOC ) )
util.cpp:            free( tmp->monster->name );
util.cpp:            free( tmp->monster->corpseString );
util.cpp:        free(tmp->monster);
util.cpp:        mlist = mlist->next;
util.cpp:    free_mons_and_objs(level->mlist);
util.cpp:    for (i = 0; i < level->level_width; i++)
util.cpp:        for (j = 0; j < level->level_length; j++)
util.cpp:            if (level->site[i][j].things) {
util.cpp:                free_objlist(level->site[i][j].things);
util.cpp:                level->site[i][j].things = NULL;
util.cpp:/* malloc function that checks its return value - if NULL, tries to free */
util.cpp:    for (curr = Dungeon, oldest = prev = &Dungeon; curr; curr = curr->next) {
util.cpp:        if ((*oldest)->last_visited > curr->last_visited)
util.cpp:        prev = &(curr->next);
util.cpp:        *oldest = (*oldest)->next;
util.cpp:    int i= -1;
util.cpp:    if (Level != NULL) depth = Level->depth;
util.cpp:        key += 3*(fname[pos] - ' ');
village.cpp:    Level->environment = E_VILLAGE;
village.cpp:    Level->level_width = map_getWidth(village);
village.cpp:    Level->level_length = map_getLength(village);
village.cpp:    for(j=0; j<Level->level_length; j++) {
village.cpp:        for(i=0; i<Level->level_width; i++) {
village.cpp:            Level->site[i][j].p_locf = L_NO_OP;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].p_locf = L_GRANARY;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].p_locf = L_STABLES;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].p_locf = L_COMMONS;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].p_locf = L_COUNTRYSIDE;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                    Level->site[i][j].creature->aux1 = i;
village.cpp:                    Level->site[i][j].creature->aux2 = j;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:                Level->site[i][j].p_locf = L_TRAP_SIREN;
village.cpp:                Level->site[i][j].locchar = HEDGE;
village.cpp:                Level->site[i][j].p_locf = L_HEDGE;
village.cpp:                Level->site[i][j].locchar = WATER;
village.cpp:                Level->site[i][j].p_locf = L_WATER;
village.cpp:                Level->site[i][j].locchar = WATER;
village.cpp:                Level->site[i][j].p_locf = L_CHAOS;
village.cpp:                Level->site[i][j].locchar = HEDGE;
village.cpp:                Level->site[i][j].p_locf = L_TRIFID;
village.cpp:                Level->site[i][j].locchar = WALL;
village.cpp:                Level->site[i][j].aux = 100;
village.cpp:                Level->site[i][j].locchar = FLOOR;
village.cpp:            case '-':
village.cpp:                Level->site[i][j].locchar = CLOSED_DOOR;
village.cpp:                Level->site[i][j].locchar = STATUE;
village.cpp:                Level->site[i][j].showchar = WALL;
village.cpp:            else Level->site[i][j].showchar = Level->site[i][j].locchar;
village.cpp:    tml->monster = (Level->site[i][j].creature = make_creature(GUARD));
village.cpp:    tml->monster->x = i;
village.cpp:    tml->monster->y = j;
village.cpp:    tml->next = Level->mlist;
village.cpp:    Level->mlist = tml;
village.cpp:    tml->monster = (Level->site[i][j].creature = make_creature(SHEEP));
village.cpp:    tml->monster->x = i;
village.cpp:    tml->monster->y = j;
village.cpp:    tml->next = Level->mlist;
village.cpp:    Level->mlist = tml;
village.cpp:        tol->thing = ((Object*) checkmalloc(sizeof(Object)));
village.cpp:        make_food(tol->thing,15); /* grain */
village.cpp:        tol->next = Level->site[i][j].things;
village.cpp:        Level->site[i][j].things = tol;
village.cpp:    tml->monster = (Level->site[i][j].creature = make_creature(HORSE));
village.cpp:    tml->monster->x = i;
village.cpp:    tml->monster->y = j;
village.cpp:    tml->next = Level->mlist;
village.cpp:    Level->mlist = tml;
village.cpp:	tml->monster = (Level->site[i][j].creature = make_creature(MERCHANT));
village.cpp:    tml->monster->x = i;
village.cpp:    tml->monster->y = j;
village.cpp:    tml->next = Level->mlist;
village.cpp:    Level->mlist = tml;
village.cpp:        lset(x-1,y,STOPS);
village.cpp:        lset(x,y-1,STOPS);
village.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
village.cpp:            Level->site[x][y].p_locf = L_ARMORER;
village.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
village.cpp:            Level->site[x][y].p_locf = L_HEALER;
village.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
village.cpp:            Level->site[x][y].p_locf = L_TAVERN;
village.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
village.cpp:            Level->site[x][y].p_locf = L_COMMANDANT;
village.cpp:            Level->site[x][y].locchar = OPEN_DOOR;
village.cpp:            Level->site[x][y].p_locf = L_CARTOGRAPHER;
village.cpp:            Level->site[x][y].locchar = CLOSED_DOOR;
village.cpp:                Level->site[x][y].aux = LOCKED;
village.cpp:                Level->site[x][y].p_locf = L_HOVEL;
village.cpp:            else Level->site[x][y].p_locf = L_HOUSE;
village.cpp:	Level->site[i][j].locchar = ALTAR;
village.cpp:	Level->site[i][j].p_locf = vil_stone;
